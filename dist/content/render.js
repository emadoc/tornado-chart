var SDKComponent = function(React2) {
  "use strict";
  let {
    useLocale,
    useContext,
    usePrompts,
    useQueryBuilder,
    useCustomQuery,
    useQuery,
    LoadingOverlay,
    ErrorOverlay
  } = window.incortaSDKApi ?? {};
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var Chart$1 = { exports: {} };
  //! moment.js
  //! version : 2.29.3
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  var hookCallback;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
  }
  function isObject(input) {
    return input != null && Object.prototype.toString.call(input) === "[object Object]";
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;
      for (k in obj) {
        if (hasOwnProp(obj, k)) {
          return false;
        }
      }
      return true;
    }
  }
  function isUndefined(input) {
    return input === void 0;
  }
  function isNumber(input) {
    return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
  }
  function map(arr, fn) {
    var res = [], i, arrLen = arr.length;
    for (i = 0; i < arrLen; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, "toString")) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, "valueOf")) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function createUTC(input, format2, locale2, strict) {
    return createLocalOrUTC(input, format2, locale2, strict, true).utc();
  }
  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this), len = t.length >>> 0, i;
      for (i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
        return i != null;
      }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m._isValid;
  }
  function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  var momentProperties = hooks.momentProperties = [], updateInProgress = false;
  function copyConfig(to2, from2) {
    var i, prop, val, momentPropertiesLen = momentProperties.length;
    if (!isUndefined(from2._isAMomentObject)) {
      to2._isAMomentObject = from2._isAMomentObject;
    }
    if (!isUndefined(from2._i)) {
      to2._i = from2._i;
    }
    if (!isUndefined(from2._f)) {
      to2._f = from2._f;
    }
    if (!isUndefined(from2._l)) {
      to2._l = from2._l;
    }
    if (!isUndefined(from2._strict)) {
      to2._strict = from2._strict;
    }
    if (!isUndefined(from2._tzm)) {
      to2._tzm = from2._tzm;
    }
    if (!isUndefined(from2._isUTC)) {
      to2._isUTC = from2._isUTC;
    }
    if (!isUndefined(from2._offset)) {
      to2._offset = from2._offset;
    }
    if (!isUndefined(from2._pf)) {
      to2._pf = getParsingFlags(from2);
    }
    if (!isUndefined(from2._locale)) {
      to2._locale = from2._locale;
    }
    if (momentPropertiesLen > 0) {
      for (i = 0; i < momentPropertiesLen; i++) {
        prop = momentProperties[i];
        val = from2[prop];
        if (!isUndefined(val)) {
          to2[prop] = val;
        }
      }
    }
    return to2;
  }
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = /* @__PURE__ */ new Date(NaN);
    }
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
      console.warn("Deprecation warning: " + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [], arg, i, key, argLen = arguments.length;
        for (i = 0; i < argLen; i++) {
          arg = "";
          if (typeof arguments[i] === "object") {
            arg += "\n[" + i + "] ";
            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ": " + arguments[0][key] + ", ";
              }
            }
            arg = arg.slice(0, -2);
          } else {
            arg = arguments[i];
          }
          args.push(arg);
        }
        warn(
          msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
        );
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  function isFunction(input) {
    return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
  }
  function set(config) {
    var prop, i;
    for (i in config) {
      if (hasOwnProp(config, i)) {
        prop = config[i];
        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this["_" + i] = prop;
        }
      }
    }
    this._config = config;
    this._dayOfMonthOrdinalParseLenient = new RegExp(
      (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
    );
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i, res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
  };
  function calendar(key, mom, now2) {
    var output = this._calendar[key] || this._calendar["sameElse"];
    return isFunction(output) ? output.call(mom, now2) : output;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
    return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
  function addFormatToken(token2, padded, ordinal2, callback) {
    var func = callback;
    if (typeof callback === "string") {
      func = function() {
        return this[callback]();
      };
    }
    if (token2) {
      formatTokenFunctions[token2] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal2) {
      formatTokenFunctions[ordinal2] = function() {
        return this.localeData().ordinal(
          func.apply(this, arguments),
          token2
        );
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, "");
    }
    return input.replace(/\\/g, "");
  }
  function makeFormatFunction(format2) {
    var array = format2.match(formattingTokens), i, length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = "", i2;
      for (i2 = 0; i2 < length; i2++) {
        output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
      }
      return output;
    };
  }
  function formatMoment(m, format2) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format2 = expandFormat(format2, m.localeData());
    formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
    return formatFunctions[format2](m);
  }
  function expandFormat(format2, locale2) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale2.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format2)) {
      format2 = format2.replace(
        localFormattingTokens,
        replaceLongDateFormatTokens
      );
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format2;
  }
  var defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  };
  function longDateFormat(key) {
    var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format2 || !formatUpper) {
      return format2;
    }
    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
      if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
        return tok.slice(1);
      }
      return tok;
    }).join("");
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = "Invalid date";
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace("%d", number);
  }
  var defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff2, output) {
    var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
    return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {}, normalizedProp, prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [], u;
    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({ unit: u, priority: priorities[u] });
      }
    }
    units.sort(function(a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion, value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }
  function makeGetSet(unit, keepTime) {
    return function(value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }
  function get(mom, unit) {
    return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
  }
  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
          value,
          mom.month(),
          daysInMonth(value, mom.month())
        );
      } else {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
      }
    }
  }
  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (typeof units === "object") {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
      for (i = 0; i < prioritizedLen; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
  regexes = {};
  function addRegexToken(token2, regex, strictRegex) {
    regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token2, config) {
    if (!hasOwnProp(regexes, token2)) {
      return new RegExp(unescapeFormat(token2));
    }
    return regexes[token2](config._strict, config._locale);
  }
  function unescapeFormat(s) {
    return regexEscape(
      s.replace("\\", "").replace(
        /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
        function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }
      )
    );
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var tokens = {};
  function addParseToken(token2, callback) {
    var i, func = callback, tokenLen;
    if (typeof token2 === "string") {
      token2 = [token2];
    }
    if (isNumber(callback)) {
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    tokenLen = token2.length;
    for (i = 0; i < tokenLen; i++) {
      tokens[token2[i]] = func;
    }
  }
  function addWeekParseToken(token2, callback) {
    addParseToken(token2, function(input, array, config, token3) {
      config._w = config._w || {};
      callback(input, config._w, config, token3);
    });
  }
  function addTimeToArrayFromToken(token2, input, config) {
    if (input != null && hasOwnProp(tokens, token2)) {
      tokens[token2](input, config._a, config, token2);
    }
  }
  var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
  function mod(n, x) {
    return (n % x + x) % x;
  }
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o) {
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  }
  addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function(format2) {
    return this.localeData().monthsShort(this, format2);
  });
  addFormatToken("MMMM", 0, 0, function(format2) {
    return this.localeData().months(this, format2);
  });
  addUnitAlias("month", "M");
  addUnitPriority("month", 8);
  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", function(isStrict, locale2) {
    return locale2.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function(isStrict, locale2) {
    return locale2.monthsRegex(isStrict);
  });
  addParseToken(["M", "MM"], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
    var month = config._locale.monthsParse(input, token2, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
    "_"
  ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
  function localeMonths(m, format2) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months["standalone"];
    }
    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
  }
  function localeMonthsShort(m, format2) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
  }
  function handleStrictParse(monthName, format2, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = createUTC([2e3, i]);
        this._shortMonthsParse[i] = this.monthsShort(
          mom,
          ""
        ).toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format2 === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format2 === "MMM") {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format2, strict) {
    var i, mom, regex;
    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format2, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      mom = createUTC([2e3, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp(
          "^" + this.months(mom, "").replace(".", "") + "$",
          "i"
        );
        this._shortMonthsParse[i] = new RegExp(
          "^" + this.monthsShort(mom, "").replace(".", "") + "$",
          "i"
        );
      }
      if (!strict && !this._monthsParse[i]) {
        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
        this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      return mom;
    }
    if (typeof value === "string") {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        if (!isNumber(value)) {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, "Month");
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsShortRegex")) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, "_monthsRegex")) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, "_monthsRegex")) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
    for (i = 0; i < 12; i++) {
      mom = createUTC([2e3, i]);
      shortPieces.push(this.monthsShort(mom, ""));
      longPieces.push(this.months(mom, ""));
      mixedPieces.push(this.months(mom, ""));
      mixedPieces.push(this.monthsShort(mom, ""));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp(
      "^(" + longPieces.join("|") + ")",
      "i"
    );
    this._monthsShortStrictRegex = new RegExp(
      "^(" + shortPieces.join("|") + ")",
      "i"
    );
  }
  addFormatToken("Y", 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : "+" + y;
  });
  addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addUnitAlias("year", "y");
  addUnitPriority("year", 1);
  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function(input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function(input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
  };
  var getSetYear = makeGetSet("FullYear", true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function createDate(y, m, d, h, M, s, ms) {
    var date;
    if (y < 100 && y >= 0) {
      date = new Date(y + 400, m, d, h, M, s, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }
    return date;
  }
  function createUTCDate(y) {
    var date, args;
    if (y < 100 && y >= 0) {
      args = Array.prototype.slice.call(arguments);
      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }
    return date;
  }
  function firstWeekOffset(year, dow, doy) {
    var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");
  addUnitPriority("week", 5);
  addUnitPriority("isoWeek", 5);
  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match2);
  addWeekParseToken(
    ["w", "ww", "W", "WW"],
    function(input, week, config, token2) {
      week[token2.substr(0, 1)] = toInt(input);
    }
  );
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6
    // The week that contains Jan 6th is the first week of the year.
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, "d");
  }
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function(format2) {
    return this.localeData().weekdaysMin(this, format2);
  });
  addFormatToken("ddd", 0, 0, function(format2) {
    return this.localeData().weekdaysShort(this, format2);
  });
  addFormatToken("dddd", 0, 0, function(format2) {
    return this.localeData().weekdays(this, format2);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");
  addUnitPriority("day", 11);
  addUnitPriority("weekday", 11);
  addUnitPriority("isoWeekday", 11);
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function(isStrict, locale2) {
    return locale2.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function(isStrict, locale2) {
    return locale2.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function(isStrict, locale2) {
    return locale2.weekdaysRegex(isStrict);
  });
  addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
    var weekday = config._locale.weekdaysParse(input, token2, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
    week[token2] = toInt(input);
  });
  function parseWeekday(input, locale2) {
    if (typeof input !== "string") {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale2.weekdaysParse(input);
    if (typeof input === "number") {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale2) {
    if (typeof input === "string") {
      return locale2.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }
  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }
  var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
  function localeWeekdays(m, format2) {
    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }
  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }
  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(weekdayName, format2, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = createUTC([2e3, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(
          mom,
          ""
        ).toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(
          mom,
          ""
        ).toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format2 === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format2 === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format2 === "dddd") {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format2 === "ddd") {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format2, strict) {
    var i, mom, regex;
    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format2, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      mom = createUTC([2e3, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp(
          "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
          "i"
        );
        this._shortWeekdaysParse[i] = new RegExp(
          "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
          "i"
        );
        this._minWeekdaysParse[i] = new RegExp(
          "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
          "i"
        );
      }
      if (!this._weekdaysParse[i]) {
        regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
        this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
      }
      if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, "d");
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, "d");
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysShortRegex")) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, "_weekdaysRegex")) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, "_weekdaysMinRegex")) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
      mom = createUTC([2e3, 1]).day(i);
      minp = regexEscape(this.weekdaysMin(mom, ""));
      shortp = regexEscape(this.weekdaysShort(mom, ""));
      longp = regexEscape(this.weekdays(mom, ""));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp(
      "^(" + longPieces.join("|") + ")",
      "i"
    );
    this._weekdaysShortStrictRegex = new RegExp(
      "^(" + shortPieces.join("|") + ")",
      "i"
    );
    this._weekdaysMinStrictRegex = new RegExp(
      "^(" + minPieces.join("|") + ")",
      "i"
    );
  }
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, kFormat);
  addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token2, lowercase) {
    addFormatToken(token2, 0, 0, function() {
      return this.localeData().meridiem(
        this.hours(),
        this.minutes(),
        lowercase
      );
    });
  }
  meridiem("a", true);
  meridiem("A", false);
  addUnitAlias("hour", "h");
  addUnitPriority("hour", 13);
  function matchMeridiem(isStrict, locale2) {
    return locale2._meridiemParse;
  }
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("k", match1to2);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addRegexToken("kk", match1to2, match2);
  addRegexToken("hmm", match3to4);
  addRegexToken("hmmss", match5to6);
  addRegexToken("Hmm", match3to4);
  addRegexToken("Hmmss", match5to6);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function(input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(["a", "A"], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("Hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken("Hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  function localeIsPM(input) {
    return (input + "").toLowerCase().charAt(0) === "p";
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
  function localeMeridiem(hours2, minutes2, isLower) {
    if (hours2 > 11) {
      return isLower ? "pm" : "PM";
    } else {
      return isLower ? "am" : "AM";
    }
  }
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  var locales = {}, localeFamilies = {}, globalLocale;
  function commonPrefix(arr1, arr2) {
    var i, minl = Math.min(arr1.length, arr2.length);
    for (i = 0; i < minl; i += 1) {
      if (arr1[i] !== arr2[i]) {
        return i;
      }
    }
    return minl;
  }
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }
  function chooseLocale(names) {
    var i = 0, j, next, locale2, split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split("-");
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split("-") : null;
      while (j > 0) {
        locale2 = loadLocale(split.slice(0, j).join("-"));
        if (locale2) {
          return locale2;
        }
        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return globalLocale;
  }
  function isLocaleNameSane(name) {
    return name.match("^[^/\\\\]*$") != null;
  }
  function loadLocale(name) {
    var oldLocale = null, aliasedRequire;
    if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = require;
        aliasedRequire("./locale/" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        locales[name] = null;
      }
    }
    return locales[name];
  }
  function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        globalLocale = data;
      } else {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(
            "Locale " + key + " not found. Did you forget to load it?"
          );
        }
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var locale2, parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple(
          "defineLocaleOverride",
          "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
        );
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale2 = loadLocale(config.parentLocale);
          if (locale2 != null) {
            parentConfig = locale2._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }
            localeFamilies[config.parentLocale].push({
              name,
              config
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function(x) {
          defineLocale(x.name, x.config);
        });
      }
      getSetGlobalLocale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale2, tmpLocale, parentConfig = baseConfig;
      if (locales[name] != null && locales[name].parentLocale != null) {
        locales[name].set(mergeConfigs(locales[name]._config, config));
      } else {
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        if (tmpLocale == null) {
          config.abbr = name;
        }
        locale2 = new Locale(config);
        locale2.parentLocale = locales[name];
        locales[name] = locale2;
      }
      getSetGlobalLocale(name);
    } else {
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }
  function getLocale(key) {
    var locale2;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      locale2 = loadLocale(key);
      if (locale2) {
        return locale2;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow, a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, false],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
    ["YYYYDDD", /\d{7}/],
    ["YYYYMM", /\d{6}/, false],
    ["YYYY", /\d{4}/, false]
  ], isoTimes = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/]
  ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function configFromISO(config) {
    var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDatesLen; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimesLen; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            timeFormat = (match[2] || " ") + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = "Z";
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
      untruncateYear(yearStr),
      defaultLocaleMonthsShort.indexOf(monthStr),
      parseInt(dayStr, 10),
      parseInt(hourStr, 10),
      parseInt(minuteStr, 10)
    ];
    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }
    return result;
  }
  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2e3 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }
  function preprocessRFC2822(s) {
    return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
        parsedInput[0],
        parsedInput[1],
        parsedInput[2]
      ).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }
    return true;
  }
  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      return 0;
    } else {
      var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
      return h * 60 + m;
    }
  }
  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
    if (match) {
      parsedArray = extractFromRFC2822Strings(
        match[4],
        match[3],
        match[2],
        match[5],
        match[6],
        match[7]
      );
      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }
      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  }
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = /* @__PURE__ */ new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    configFromRFC2822(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    if (config._strict) {
      config._isValid = false;
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  hooks.createFromInputFallback = deprecate(
    "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
    function(config) {
      config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
    }
  );
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
      return [
        nowValue.getUTCFullYear(),
        nowValue.getUTCMonth(),
        nowValue.getUTCDate()
      ];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }
  function configFromArray(config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(
      null,
      input
    );
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
    if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = defaults(
        w.GG,
        config._a[YEAR],
        weekOfYear(createLocal(), 1, 4).year
      );
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
      week = defaults(w.w, curWeek.week);
      if (w.d != null) {
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
  hooks.ISO_8601 = function() {
  };
  hooks.RFC_2822 = function() {
  };
  function configFromStringAndFormat(config) {
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
    tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    tokenLen = tokens2.length;
    for (i = 0; i < tokenLen; i++) {
      token2 = tokens2[i];
      parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(
          string.indexOf(parsedInput) + parsedInput.length
        );
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token2]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token2);
        }
        addTimeToArrayFromToken(token2, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token2);
      }
    }
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = void 0;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    config._a[HOUR] = meridiemFixWrap(
      config._locale,
      config._a[HOUR],
      config._meridiem
    );
    era = getParsingFlags(config).era;
    if (era !== null) {
      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
    }
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale2, hour, meridiem2) {
    var isPm;
    if (meridiem2 == null) {
      return hour;
    }
    if (locale2.meridiemHour != null) {
      return locale2.meridiemHour(hour, meridiem2);
    } else if (locale2.isPM != null) {
      isPm = locale2.isPM(meridiem2);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
    if (configfLen === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = /* @__PURE__ */ new Date(NaN);
      return;
    }
    for (i = 0; i < configfLen; i++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (isValid(tempConfig)) {
        validFormatFound = true;
      }
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
    config._a = map(
      [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
      function(obj) {
        return obj && parseInt(obj, 10);
      }
    );
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      res.add(1, "d");
      res._nextDay = void 0;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i, format2 = config._f;
    config._locale = config._locale || getLocale(config._l);
    if (input === null || format2 === void 0 && input === "") {
      return createInvalid({ nullInput: true });
    }
    if (typeof input === "string") {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format2)) {
      configFromStringAndArray(config);
    } else if (format2) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === "string") {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
    var c = {};
    if (format2 === true || format2 === false) {
      strict = format2;
      format2 = void 0;
    }
    if (locale2 === true || locale2 === false) {
      strict = locale2;
      locale2 = void 0;
    }
    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = void 0;
    }
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale2;
    c._i = input;
    c._f = format2;
    c._strict = strict;
    return createFromConfig(c);
  }
  function createLocal(input, format2, locale2, strict) {
    return createLocalOrUTC(input, format2, locale2, strict, false);
  }
  var prototypeMin = deprecate(
    "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
    function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    }
  ), prototypeMax = deprecate(
    "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
    function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }
  );
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isBefore", args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isAfter", args);
  }
  var now = function() {
    return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
  };
  var ordering = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function isDurationValid(m) {
    var key, unitHasDecimal = false, i, orderLen = ordering.length;
    for (key in m) {
      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }
    for (i = 0; i < orderLen; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false;
        }
        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput);
    this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
    minutes2 * 6e4 + // 1000 * 60
    hours2 * 1e3 * 60 * 60;
    this._days = +days2 + weeks2 * 7;
    this._months = +months2 + quarters * 3 + years2 * 12;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function offset(token2, separator) {
    addFormatToken(token2, 0, 0, function() {
      var offset2 = this.utcOffset(), sign2 = "+";
      if (offset2 < 0) {
        offset2 = -offset2;
        sign2 = "-";
      }
      return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
    });
  }
  offset("Z", ":");
  offset("ZZ", "");
  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = (string || "").match(matcher), chunk, parts, minutes2;
    if (matches === null) {
      return null;
    }
    chunk = matches[matches.length - 1] || [];
    parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    minutes2 = +(parts[1] * 60) + toInt(parts[2]);
    return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
  }
  function cloneWithOffset(input, model) {
    var res, diff2;
    if (model._isUTC) {
      res = model.clone();
      diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
      res._d.setTime(res._d.valueOf() + diff2);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset());
  }
  hooks.updateOffset = function() {
  };
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset2 = this._offset || 0, localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }
      if (offset2 !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(
            this,
            createDuration(input - offset2, "m"),
            1,
            false
          );
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset2 : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === "string") {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {}, other;
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(input, key) {
    var duration = input, match = null, sign2, ret, diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input) || !isNaN(+input)) {
      duration = {};
      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign2 = match[1] === "-" ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign2,
        h: toInt(match[HOUR]) * sign2,
        m: toInt(match[MINUTE]) * sign2,
        s: toInt(match[SECOND]) * sign2,
        ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
        // the millisecond decimal point is included in the match
      };
    } else if (match = isoRegex.exec(input)) {
      sign2 = match[1] === "-" ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign2),
        M: parseIso(match[3], sign2),
        w: parseIso(match[4], sign2),
        d: parseIso(match[5], sign2),
        h: parseIso(match[6], sign2),
        m: parseIso(match[7], sign2),
        s: parseIso(match[8], sign2)
      };
    } else if (duration == null) {
      duration = {};
    } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
      diffRes = momentsDifference(
        createLocal(duration.from),
        createLocal(duration.to)
      );
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, "_locale")) {
      ret._locale = input._locale;
    }
    if (isDuration(input) && hasOwnProp(input, "_isValid")) {
      ret._isValid = input._isValid;
    }
    return ret;
  }
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  function parseIso(inp, sign2) {
    var res = inp && parseFloat(inp.replace(",", "."));
    return (isNaN(res) ? 0 : res) * sign2;
  }
  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, "M").isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, "M");
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return { milliseconds: 0, months: 0 };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function createAdder(direction, name) {
    return function(val, period) {
      var dur, tmp;
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(
          name,
          "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
        );
        tmp = val;
        val = period;
        period = tmp;
      }
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
    if (!mom.isValid()) {
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (months2) {
      setMonth(mom, get(mom, "Month") + months2 * isAdding);
    }
    if (days2) {
      set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
    }
    if (milliseconds2) {
      mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days2 || months2);
    }
  }
  var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
  function isString(input) {
    return typeof input === "string" || input instanceof String;
  }
  function isMomentInput(input) {
    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
  }
  function isMomentInputObject(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "years",
      "year",
      "y",
      "months",
      "month",
      "M",
      "days",
      "day",
      "d",
      "dates",
      "date",
      "D",
      "hours",
      "hour",
      "h",
      "minutes",
      "minute",
      "m",
      "seconds",
      "second",
      "s",
      "milliseconds",
      "millisecond",
      "ms"
    ], i, property, propertyLen = properties.length;
    for (i = 0; i < propertyLen; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function isNumberOrStringArray(input) {
    var arrayTest = isArray(input), dataTypeTest = false;
    if (arrayTest) {
      dataTypeTest = input.filter(function(item) {
        return !isNumber(item) && isString(input);
      }).length === 0;
    }
    return arrayTest && dataTypeTest;
  }
  function isCalendarSpec(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
      "sameDay",
      "nextDay",
      "lastDay",
      "nextWeek",
      "lastWeek",
      "sameElse"
    ], i, property;
    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }
    return objectTest && propertyTest;
  }
  function getCalendarFormat(myMoment, now2) {
    var diff2 = myMoment.diff(now2, "days", true);
    return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
  }
  function calendar$1(time, formats) {
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time = void 0;
        formats = void 0;
      } else if (isMomentInput(arguments[0])) {
        time = arguments[0];
        formats = void 0;
      } else if (isCalendarSpec(arguments[0])) {
        formats = arguments[0];
        time = void 0;
      }
    }
    var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
    return this.format(
      output || this.localeData().calendar(format2, this, createLocal(now2))
    );
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from2, to2, units, inclusivity) {
    var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }
    inclusivity = inclusivity || "()";
    return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input), inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || "millisecond";
    if (units === "millisecond") {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that, zoneDelta, output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    switch (units) {
      case "year":
        output = monthDiff(this, that) / 12;
        break;
      case "month":
        output = monthDiff(this, that);
        break;
      case "quarter":
        output = monthDiff(this, that) / 3;
        break;
      case "second":
        output = (this - that) / 1e3;
        break;
      case "minute":
        output = (this - that) / 6e4;
        break;
      case "hour":
        output = (this - that) / 36e5;
        break;
      case "day":
        output = (this - that - zoneDelta) / 864e5;
        break;
      case "week":
        output = (this - that - zoneDelta) / 6048e5;
        break;
      default:
        output = this - that;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    if (a.date() < b.date()) {
      return -monthDiff(b, a);
    }
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  function toString() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(
        m,
        utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    if (isFunction(Date.prototype.toISOString)) {
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
      }
    }
    return formatMoment(
      m,
      utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  function inspect() {
    if (!this.isValid()) {
      return "moment.invalid(/* " + this._i + " */)";
    }
    var func = "moment", zone = "", prefix, year, datetime, suffix;
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
      zone = "Z";
    }
    prefix = "[" + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
    datetime = "-MM-DD[T]HH:mm:ss.SSS";
    suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === void 0) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate(
    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
    function(key) {
      if (key === void 0) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    }
  );
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }
  function localStartOfDate(y, m, d) {
    if (y < 100 && y >= 0) {
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }
  function utcStartOfDate(y, m, d) {
    if (y < 100 && y >= 0) {
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }
  function startOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time = startOfDate(this.year(), 0, 1);
        break;
      case "quarter":
        time = startOfDate(
          this.year(),
          this.month() - this.month() % 3,
          1
        );
        break;
      case "month":
        time = startOfDate(this.year(), this.month(), 1);
        break;
      case "week":
        time = startOfDate(
          this.year(),
          this.month(),
          this.date() - this.weekday()
        );
        break;
      case "isoWeek":
        time = startOfDate(
          this.year(),
          this.month(),
          this.date() - (this.isoWeekday() - 1)
        );
        break;
      case "day":
      case "date":
        time = startOfDate(this.year(), this.month(), this.date());
        break;
      case "hour":
        time = this._d.valueOf();
        time -= mod$1(
          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
          MS_PER_HOUR
        );
        break;
      case "minute":
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;
      case "second":
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function endOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);
    if (units === void 0 || units === "millisecond" || !this.isValid()) {
      return this;
    }
    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case "year":
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        time = startOfDate(
          this.year(),
          this.month() - this.month() % 3 + 3,
          1
        ) - 1;
        break;
      case "month":
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        time = startOfDate(
          this.year(),
          this.month(),
          this.date() - this.weekday() + 7
        ) - 1;
        break;
      case "isoWeek":
        time = startOfDate(
          this.year(),
          this.month(),
          this.date() - (this.isoWeekday() - 1) + 7
        ) - 1;
        break;
      case "day":
      case "date":
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(
          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
          MS_PER_HOUR
        ) - 1;
        break;
      case "minute":
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;
      case "second":
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 6e4;
  }
  function unix() {
    return Math.floor(this.valueOf() / 1e3);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [
      m.year(),
      m.month(),
      m.date(),
      m.hour(),
      m.minute(),
      m.second(),
      m.millisecond()
    ];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  addFormatToken("N", 0, 0, "eraAbbr");
  addFormatToken("NN", 0, 0, "eraAbbr");
  addFormatToken("NNN", 0, 0, "eraAbbr");
  addFormatToken("NNNN", 0, 0, "eraName");
  addFormatToken("NNNNN", 0, 0, "eraNarrow");
  addFormatToken("y", ["y", 1], "yo", "eraYear");
  addFormatToken("y", ["yy", 2], 0, "eraYear");
  addFormatToken("y", ["yyy", 3], 0, "eraYear");
  addFormatToken("y", ["yyyy", 4], 0, "eraYear");
  addRegexToken("N", matchEraAbbr);
  addRegexToken("NN", matchEraAbbr);
  addRegexToken("NNN", matchEraAbbr);
  addRegexToken("NNNN", matchEraName);
  addRegexToken("NNNNN", matchEraNarrow);
  addParseToken(
    ["N", "NN", "NNN", "NNNN", "NNNNN"],
    function(input, array, config, token2) {
      var era = config._locale.erasParse(input, token2, config._strict);
      if (era) {
        getParsingFlags(config).era = era;
      } else {
        getParsingFlags(config).invalidEra = input;
      }
    }
  );
  addRegexToken("y", matchUnsigned);
  addRegexToken("yy", matchUnsigned);
  addRegexToken("yyy", matchUnsigned);
  addRegexToken("yyyy", matchUnsigned);
  addRegexToken("yo", matchEraYearOrdinal);
  addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
  addParseToken(["yo"], function(input, array, config, token2) {
    var match;
    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }
    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });
  function localeEras(m, format2) {
    var i, l, date, eras = this._eras || getLocale("en")._eras;
    for (i = 0, l = eras.length; i < l; ++i) {
      switch (typeof eras[i].since) {
        case "string":
          date = hooks(eras[i].since).startOf("day");
          eras[i].since = date.valueOf();
          break;
      }
      switch (typeof eras[i].until) {
        case "undefined":
          eras[i].until = Infinity;
          break;
        case "string":
          date = hooks(eras[i].until).startOf("day").valueOf();
          eras[i].until = date.valueOf();
          break;
      }
    }
    return eras;
  }
  function localeErasParse(eraName, format2, strict) {
    var i, l, eras = this.eras(), name, abbr, narrow;
    eraName = eraName.toUpperCase();
    for (i = 0, l = eras.length; i < l; ++i) {
      name = eras[i].name.toUpperCase();
      abbr = eras[i].abbr.toUpperCase();
      narrow = eras[i].narrow.toUpperCase();
      if (strict) {
        switch (format2) {
          case "N":
          case "NN":
          case "NNN":
            if (abbr === eraName) {
              return eras[i];
            }
            break;
          case "NNNN":
            if (name === eraName) {
              return eras[i];
            }
            break;
          case "NNNNN":
            if (narrow === eraName) {
              return eras[i];
            }
            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i];
      }
    }
  }
  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? 1 : -1;
    if (year === void 0) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }
  function getEraName() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].name;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].name;
      }
    }
    return "";
  }
  function getEraNarrow() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].narrow;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].narrow;
      }
    }
    return "";
  }
  function getEraAbbr() {
    var i, l, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].abbr;
      }
      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].abbr;
      }
    }
    return "";
  }
  function getEraYear() {
    var i, l, dir, val, eras = this.localeData().eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      dir = eras[i].since <= eras[i].until ? 1 : -1;
      val = this.clone().startOf("day").valueOf();
      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
      }
    }
    return this.year();
  }
  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNameRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNameRegex : this._erasRegex;
  }
  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, "_erasAbbrRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }
  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, "_erasNarrowRegex")) {
      computeErasParse.call(this);
    }
    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }
  function matchEraAbbr(isStrict, locale2) {
    return locale2.erasAbbrRegex(isStrict);
  }
  function matchEraName(isStrict, locale2) {
    return locale2.erasNameRegex(isStrict);
  }
  function matchEraNarrow(isStrict, locale2) {
    return locale2.erasNarrowRegex(isStrict);
  }
  function matchEraYearOrdinal(isStrict, locale2) {
    return locale2._eraYearOrdinalRegex || matchUnsigned;
  }
  function computeErasParse() {
    var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
    for (i = 0, l = eras.length; i < l; ++i) {
      namePieces.push(regexEscape(eras[i].name));
      abbrPieces.push(regexEscape(eras[i].abbr));
      narrowPieces.push(regexEscape(eras[i].narrow));
      mixedPieces.push(regexEscape(eras[i].name));
      mixedPieces.push(regexEscape(eras[i].abbr));
      mixedPieces.push(regexEscape(eras[i].narrow));
    }
    this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
    this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
    this._erasNarrowRegex = new RegExp(
      "^(" + narrowPieces.join("|") + ")",
      "i"
    );
  }
  addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token2, getter) {
    addFormatToken(0, [token2, token2.length], 0, getter);
  }
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");
  addUnitPriority("weekYear", 1);
  addUnitPriority("isoWeekYear", 1);
  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);
  addWeekParseToken(
    ["gggg", "ggggg", "GGGG", "GGGGG"],
    function(input, week, config, token2) {
      week[token2.substr(0, 2)] = toInt(input);
    }
  );
  addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
    week[token2] = hooks.parseTwoDigitYear(input);
  });
  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(
      this,
      input,
      this.week(),
      this.weekday(),
      this.localeData()._week.dow,
      this.localeData()._week.doy
    );
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(
      this,
      input,
      this.isoWeek(),
      this.isoWeekday(),
      1,
      4
    );
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }
  addFormatToken("Q", 0, "Qo", "quarter");
  addUnitAlias("quarter", "Q");
  addUnitPriority("quarter", 7);
  addRegexToken("Q", match1);
  addParseToken("Q", function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken("D", ["DD", 2], "Do", "date");
  addUnitAlias("date", "D");
  addUnitPriority("date", 9);
  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function(isStrict, locale2) {
    return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addUnitAlias("dayOfYear", "DDD");
  addUnitPriority("dayOfYear", 4);
  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round(
      (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
    ) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
  }
  addFormatToken("m", ["mm", 2], 0, "minute");
  addUnitAlias("minute", "m");
  addUnitPriority("minute", 14);
  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addUnitAlias("second", "s");
  addUnitPriority("second", 15);
  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);
  var getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1e3;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6;
  });
  addUnitAlias("millisecond", "ms");
  addUnitPriority("millisecond", 16);
  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);
  var token, getSetMillisecond;
  for (token = "SSSS"; token.length <= 9; token += "S") {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(("0." + input) * 1e3);
  }
  for (token = "S"; token.length <= 9; token += "S") {
    addParseToken(token, parseMs);
  }
  getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  function getZoneAbbr() {
    return this._isUTC ? "UTC" : "";
  }
  function getZoneName() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== "undefined" && Symbol.for != null) {
    proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    };
  }
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate(
    "dates accessor is deprecated. Use date instead.",
    getSetDayOfMonth
  );
  proto.months = deprecate(
    "months accessor is deprecated. Use month instead",
    getSetMonth
  );
  proto.years = deprecate(
    "years accessor is deprecated. Use year instead",
    getSetYear
  );
  proto.zone = deprecate(
    "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
    getSetZone
  );
  proto.isDSTShifted = deprecate(
    "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
    isDaylightSavingTimeShifted
  );
  function createUnix(input) {
    return createLocal(input * 1e3);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  function get$1(format2, index2, field, setter) {
    var locale2 = getLocale(), utc = createUTC().set(setter, index2);
    return locale2[field](utc, format2);
  }
  function listMonthsImpl(format2, index2, field) {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
    if (index2 != null) {
      return get$1(format2, index2, field, "month");
    }
    var i, out = [];
    for (i = 0; i < 12; i++) {
      out[i] = get$1(format2, i, field, "month");
    }
    return out;
  }
  function listWeekdaysImpl(localeSorted, format2, index2, field) {
    if (typeof localeSorted === "boolean") {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
    } else {
      format2 = localeSorted;
      index2 = format2;
      localeSorted = false;
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
    }
    var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
    if (index2 != null) {
      return get$1(format2, (index2 + shift) % 7, field, "day");
    }
    for (i = 0; i < 7; i++) {
      out[i] = get$1(format2, (i + shift) % 7, field, "day");
    }
    return out;
  }
  function listMonths(format2, index2) {
    return listMonthsImpl(format2, index2, "months");
  }
  function listMonthsShort(format2, index2) {
    return listMonthsImpl(format2, index2, "monthsShort");
  }
  function listWeekdays(localeSorted, format2, index2) {
    return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
  }
  function listWeekdaysShort(localeSorted, format2, index2) {
    return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
  }
  function listWeekdaysMin(localeSorted, format2, index2) {
    return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
  }
  getSetGlobalLocale("en", {
    eras: [
      {
        since: "0001-01-01",
        until: Infinity,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
      },
      {
        since: "0000-12-31",
        until: -Infinity,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
      }
    ],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
      return number + output;
    }
  });
  hooks.lang = deprecate(
    "moment.lang is deprecated. Use moment.locale instead.",
    getSetGlobalLocale
  );
  hooks.langData = deprecate(
    "moment.langData is deprecated. Use moment.localeData instead.",
    getLocale
  );
  var mathAbs = Math.abs;
  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
    if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
      milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
      days2 = 0;
      months2 = 0;
    }
    data.milliseconds = milliseconds2 % 1e3;
    seconds2 = absFloor(milliseconds2 / 1e3);
    data.seconds = seconds2 % 60;
    minutes2 = absFloor(seconds2 / 60);
    data.minutes = minutes2 % 60;
    hours2 = absFloor(minutes2 / 60);
    data.hours = hours2 % 24;
    days2 += absFloor(hours2 / 24);
    monthsFromDays = absFloor(daysToMonths(days2));
    months2 += monthsFromDays;
    days2 -= absCeil(monthsToDays(monthsFromDays));
    years2 = absFloor(months2 / 12);
    months2 %= 12;
    data.days = days2;
    data.months = months2;
    data.years = years2;
    return this;
  }
  function daysToMonths(days2) {
    return days2 * 4800 / 146097;
  }
  function monthsToDays(months2) {
    return months2 * 146097 / 4800;
  }
  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days2, months2, milliseconds2 = this._milliseconds;
    units = normalizeUnits(units);
    if (units === "month" || units === "quarter" || units === "year") {
      days2 = this._days + milliseconds2 / 864e5;
      months2 = this._months + daysToMonths(days2);
      switch (units) {
        case "month":
          return months2;
        case "quarter":
          return months2 / 3;
        case "year":
          return months2 / 12;
      }
    } else {
      days2 = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case "week":
          return days2 / 7 + milliseconds2 / 6048e5;
        case "day":
          return days2 + milliseconds2 / 864e5;
        case "hour":
          return days2 * 24 + milliseconds2 / 36e5;
        case "minute":
          return days2 * 1440 + milliseconds2 / 6e4;
        case "second":
          return days2 * 86400 + milliseconds2 / 1e3;
        case "millisecond":
          return Math.floor(days2 * 864e5) + milliseconds2;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
  function clone$1() {
    return createDuration(this);
  }
  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + "s"]() : NaN;
  }
  function makeGetter(name) {
    return function() {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round, thresholds = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month/week
    w: null,
    // weeks to month
    M: 11
    // months to year
  };
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
    return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
    var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
    if (thresholds2.w != null) {
      a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
    }
    a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale2;
    return substituteTimeAgo.apply(null, a);
  }
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === void 0) {
      return round;
    }
    if (typeof roundingFunction === "function") {
      round = roundingFunction;
      return true;
    }
    return false;
  }
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === void 0) {
      return false;
    }
    if (limit === void 0) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === "s") {
      thresholds.ss = limit - 1;
    }
    return true;
  }
  function humanize(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var withSuffix = false, th = thresholds, locale2, output;
    if (typeof argWithSuffix === "object") {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }
    if (typeof argWithSuffix === "boolean") {
      withSuffix = argWithSuffix;
    }
    if (typeof argThresholds === "object") {
      th = Object.assign({}, thresholds, argThresholds);
      if (argThresholds.s != null && argThresholds.ss == null) {
        th.ss = argThresholds.s - 1;
      }
    }
    locale2 = this.localeData();
    output = relativeTime$1(this, !withSuffix, th, locale2);
    if (withSuffix) {
      output = locale2.pastFuture(+this, output);
    }
    return locale2.postformat(output);
  }
  var abs$1 = Math.abs;
  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }
  function toISOString$1() {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
    if (!total) {
      return "P0D";
    }
    minutes2 = absFloor(seconds2 / 60);
    hours2 = absFloor(minutes2 / 60);
    seconds2 %= 60;
    minutes2 %= 60;
    years2 = absFloor(months2 / 12);
    months2 %= 12;
    s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
    totalSign = total < 0 ? "-" : "";
    ymSign = sign(this._months) !== sign(total) ? "-" : "";
    daysSign = sign(this._days) !== sign(total) ? "-" : "";
    hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
    return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
  }
  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate(
    "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
    toISOString$1
  );
  proto$2.lang = lang;
  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");
  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function(input, array, config) {
    config._d = new Date(parseFloat(input) * 1e3);
  });
  addParseToken("x", function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  //! moment.js
  hooks.version = "2.29.3";
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    // <input type="datetime-local" step="0.001" />
    DATE: "YYYY-MM-DD",
    // <input type="date" />
    TIME: "HH:mm",
    // <input type="time" />
    TIME_SECONDS: "HH:mm:ss",
    // <input type="time" step="1" />
    TIME_MS: "HH:mm:ss.SSS",
    // <input type="time" step="0.001" />
    WEEK: "GGGG-[W]WW",
    // <input type="week" />
    MONTH: "YYYY-MM"
    // <input type="month" />
  };
  const moment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: hooks
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(moment);
  /*!
   * Chart.js v2.9.4
   * https://www.chartjs.org
   * (c) 2020 Chart.js Contributors
   * Released under the MIT License
   */
  var hasRequiredChart;
  function requireChart() {
    if (hasRequiredChart)
      return Chart$1.exports;
    hasRequiredChart = 1;
    (function(module2, exports) {
      (function(global2, factory) {
        module2.exports = factory(function() {
          try {
            return require$$0;
          } catch (e) {
          }
        }());
      })(commonjsGlobal, function(moment2) {
        moment2 = moment2 && moment2.hasOwnProperty("default") ? moment2["default"] : moment2;
        function createCommonjsModule(fn, module3) {
          return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
        }
        function getCjsExportFromNamespace(n) {
          return n && n["default"] || n;
        }
        var colorName = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var conversions = createCommonjsModule(function(module3) {
          var reverseKeywords = {};
          for (var key in colorName) {
            if (colorName.hasOwnProperty(key)) {
              reverseKeywords[colorName[key]] = key;
            }
          }
          var convert2 = module3.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          for (var model in convert2) {
            if (convert2.hasOwnProperty(model)) {
              if (!("channels" in convert2[model])) {
                throw new Error("missing channels property: " + model);
              }
              if (!("labels" in convert2[model])) {
                throw new Error("missing channel labels property: " + model);
              }
              if (convert2[model].labels.length !== convert2[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }
              var channels = convert2[model].channels;
              var labels = convert2[model].labels;
              delete convert2[model].channels;
              delete convert2[model].labels;
              Object.defineProperty(convert2[model], "channels", { value: channels });
              Object.defineProperty(convert2[model], "labels", { value: labels });
            }
          }
          convert2.rgb.hsl = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min2 = Math.min(r, g, b);
            var max2 = Math.max(r, g, b);
            var delta = max2 - min2;
            var h;
            var s;
            var l;
            if (max2 === min2) {
              h = 0;
            } else if (r === max2) {
              h = (g - b) / delta;
            } else if (g === max2) {
              h = 2 + (b - r) / delta;
            } else if (b === max2) {
              h = 4 + (r - g) / delta;
            }
            h = Math.min(h * 60, 360);
            if (h < 0) {
              h += 360;
            }
            l = (min2 + max2) / 2;
            if (max2 === min2) {
              s = 0;
            } else if (l <= 0.5) {
              s = delta / (max2 + min2);
            } else {
              s = delta / (2 - max2 - min2);
            }
            return [h, s * 100, l * 100];
          };
          convert2.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h;
            var s;
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v = Math.max(r, g, b);
            var diff2 = v - Math.min(r, g, b);
            var diffc = function(c) {
              return (v - c) / 6 / diff2 + 1 / 2;
            };
            if (diff2 === 0) {
              h = s = 0;
            } else {
              s = diff2 / v;
              rdif = diffc(r);
              gdif = diffc(g);
              bdif = diffc(b);
              if (r === v) {
                h = bdif - gdif;
              } else if (g === v) {
                h = 1 / 3 + rdif - bdif;
              } else if (b === v) {
                h = 2 / 3 + gdif - rdif;
              }
              if (h < 0) {
                h += 1;
              } else if (h > 1) {
                h -= 1;
              }
            }
            return [
              h * 360,
              s * 100,
              v * 100
            ];
          };
          convert2.rgb.hwb = function(rgb) {
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var h = convert2.rgb.hsl(rgb)[0];
            var w = 1 / 255 * Math.min(r, Math.min(g, b));
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
            return [h, w * 100, b * 100];
          };
          convert2.rgb.cmyk = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m;
            var y;
            var k2;
            k2 = Math.min(1 - r, 1 - g, 1 - b);
            c = (1 - r - k2) / (1 - k2) || 0;
            m = (1 - g - k2) / (1 - k2) || 0;
            y = (1 - b - k2) / (1 - k2) || 0;
            return [c * 100, m * 100, y * 100, k2 * 100];
          };
          function comparativeDistance(x, y) {
            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
          }
          convert2.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];
            if (reversed) {
              return reversed;
            }
            var currentClosestDistance = Infinity;
            var currentClosestKeyword;
            for (var keyword2 in colorName) {
              if (colorName.hasOwnProperty(keyword2)) {
                var value = colorName[keyword2];
                var distance = comparativeDistance(rgb, value);
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword2;
                }
              }
            }
            return currentClosestKeyword;
          };
          convert2.keyword.rgb = function(keyword2) {
            return colorName[keyword2];
          };
          convert2.rgb.xyz = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
            return [x * 100, y * 100, z * 100];
          };
          convert2.rgb.lab = function(rgb) {
            var xyz = convert2.rgb.xyz(rgb);
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.hsl.rgb = function(hsl) {
            var h = hsl[0] / 360;
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;
            if (s === 0) {
              val = l * 255;
              return [val, val, val];
            }
            if (l < 0.5) {
              t2 = l * (1 + s);
            } else {
              t2 = l + s - l * s;
            }
            t1 = 2 * l - t2;
            rgb = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
              t3 = h + 1 / 3 * -(i - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb[i] = val * 255;
            }
            return rgb;
          };
          convert2.hsl.hsv = function(hsl) {
            var h = hsl[0];
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var smin = s;
            var lmin = Math.max(l, 0.01);
            var sv;
            var v;
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v = (l + s) / 2;
            sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
            return [h, sv * 100, v * 100];
          };
          convert2.hsv.rgb = function(hsv) {
            var h = hsv[0] / 60;
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var hi = Math.floor(h) % 6;
            var f = h - Math.floor(h);
            var p = 255 * v * (1 - s);
            var q = 255 * v * (1 - s * f);
            var t = 255 * v * (1 - s * (1 - f));
            v *= 255;
            switch (hi) {
              case 0:
                return [v, t, p];
              case 1:
                return [q, v, p];
              case 2:
                return [p, v, t];
              case 3:
                return [p, q, v];
              case 4:
                return [t, p, v];
              case 5:
                return [v, p, q];
            }
          };
          convert2.hsv.hsl = function(hsv) {
            var h = hsv[0];
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var vmin = Math.max(v, 0.01);
            var lmin;
            var sl;
            var l;
            l = (2 - s) * v;
            lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [h, sl * 100, l * 100];
          };
          convert2.hwb.rgb = function(hwb) {
            var h = hwb[0] / 360;
            var wh = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh + bl;
            var i;
            var v;
            var f;
            var n;
            if (ratio > 1) {
              wh /= ratio;
              bl /= ratio;
            }
            i = Math.floor(6 * h);
            v = 1 - bl;
            f = 6 * h - i;
            if ((i & 1) !== 0) {
              f = 1 - f;
            }
            n = wh + f * (v - wh);
            var r;
            var g;
            var b;
            switch (i) {
              default:
              case 6:
              case 0:
                r = v;
                g = n;
                b = wh;
                break;
              case 1:
                r = n;
                g = v;
                b = wh;
                break;
              case 2:
                r = wh;
                g = v;
                b = n;
                break;
              case 3:
                r = wh;
                g = n;
                b = v;
                break;
              case 4:
                r = n;
                g = wh;
                b = v;
                break;
              case 5:
                r = v;
                g = wh;
                b = n;
                break;
            }
            return [r * 255, g * 255, b * 255];
          };
          convert2.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m = cmyk[1] / 100;
            var y = cmyk[2] / 100;
            var k2 = cmyk[3] / 100;
            var r;
            var g;
            var b;
            r = 1 - Math.min(1, c * (1 - k2) + k2);
            g = 1 - Math.min(1, m * (1 - k2) + k2);
            b = 1 - Math.min(1, y * (1 - k2) + k2);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.rgb = function(xyz) {
            var x = xyz[0] / 100;
            var y = xyz[1] / 100;
            var z = xyz[2] / 100;
            var r;
            var g;
            var b;
            r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            b = x * 0.0557 + y * -0.204 + z * 1.057;
            r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
            g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
            b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.lab = function(xyz) {
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.lab.xyz = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var x;
            var y;
            var z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            var y2 = Math.pow(y, 3);
            var x2 = Math.pow(x, 3);
            var z2 = Math.pow(z, 3);
            y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [x, y, z];
          };
          convert2.lab.lch = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var hr;
            var h;
            var c;
            hr = Math.atan2(b, a);
            h = hr * 360 / 2 / Math.PI;
            if (h < 0) {
              h += 360;
            }
            c = Math.sqrt(a * a + b * b);
            return [l, c, h];
          };
          convert2.lch.lab = function(lch) {
            var l = lch[0];
            var c = lch[1];
            var h = lch[2];
            var a;
            var b;
            var hr;
            hr = h / 360 * 2 * Math.PI;
            a = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l, a, b];
          };
          convert2.rgb.ansi16 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
            value = Math.round(value / 50);
            if (value === 0) {
              return 30;
            }
            var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
            if (value === 2) {
              ansi += 60;
            }
            return ansi;
          };
          convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          };
          convert2.rgb.ansi256 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            if (r === g && g === b) {
              if (r < 8) {
                return 16;
              }
              if (r > 248) {
                return 231;
              }
              return Math.round((r - 8) / 247 * 24) + 232;
            }
            var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
          };
          convert2.ansi16.rgb = function(args) {
            var color = args % 10;
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }
              color = color / 10.5 * 255;
              return [color, color, color];
            }
            var mult = (~~(args > 50) + 1) * 0.5;
            var r = (color & 1) * mult * 255;
            var g = (color >> 1 & 1) * mult * 255;
            var b = (color >> 2 & 1) * mult * 255;
            return [r, g, b];
          };
          convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }
            args -= 16;
            var rem;
            var r = Math.floor(args / 36) / 5 * 255;
            var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
            var b = rem % 6 / 5 * 255;
            return [r, g, b];
          };
          convert2.rgb.hex = function(args) {
            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) {
              return [0, 0, 0];
            }
            var colorString2 = match[0];
            if (match[0].length === 3) {
              colorString2 = colorString2.split("").map(function(char) {
                return char + char;
              }).join("");
            }
            var integer = parseInt(colorString2, 16);
            var r = integer >> 16 & 255;
            var g = integer >> 8 & 255;
            var b = integer & 255;
            return [r, g, b];
          };
          convert2.rgb.hcg = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max2 = Math.max(Math.max(r, g), b);
            var min2 = Math.min(Math.min(r, g), b);
            var chroma = max2 - min2;
            var grayscale;
            var hue;
            if (chroma < 1) {
              grayscale = min2 / (1 - chroma);
            } else {
              grayscale = 0;
            }
            if (chroma <= 0) {
              hue = 0;
            } else if (max2 === r) {
              hue = (g - b) / chroma % 6;
            } else if (max2 === g) {
              hue = 2 + (b - r) / chroma;
            } else {
              hue = 4 + (r - g) / chroma + 4;
            }
            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };
          convert2.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var c = 1;
            var f = 0;
            if (l < 0.5) {
              c = 2 * s * l;
            } else {
              c = 2 * s * (1 - l);
            }
            if (c < 1) {
              f = (l - 0.5 * c) / (1 - c);
            }
            return [hsl[0], c * 100, f * 100];
          };
          convert2.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var c = s * v;
            var f = 0;
            if (c < 1) {
              f = (v - c) / (1 - c);
            }
            return [hsv[0], c * 100, f * 100];
          };
          convert2.hcg.rgb = function(hcg) {
            var h = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            if (c === 0) {
              return [g * 255, g * 255, g * 255];
            }
            var pure = [0, 0, 0];
            var hi = h % 1 * 6;
            var v = hi % 1;
            var w = 1 - v;
            var mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;
              case 1:
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;
              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;
              case 3:
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;
              case 4:
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;
              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
            }
            mg = (1 - c) * g;
            return [
              (c * pure[0] + mg) * 255,
              (c * pure[1] + mg) * 255,
              (c * pure[2] + mg) * 255
            ];
          };
          convert2.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            var f = 0;
            if (v > 0) {
              f = c / v;
            }
            return [hcg[0], f * 100, v * 100];
          };
          convert2.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var l = g * (1 - c) + 0.5 * c;
            var s = 0;
            if (l > 0 && l < 0.5) {
              s = c / (2 * l);
            } else if (l >= 0.5 && l < 1) {
              s = c / (2 * (1 - l));
            }
            return [hcg[0], s * 100, l * 100];
          };
          convert2.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            return [hcg[0], (v - c) * 100, (1 - v) * 100];
          };
          convert2.hwb.hcg = function(hwb) {
            var w = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v = 1 - b;
            var c = v - w;
            var g = 0;
            if (c < 1) {
              g = (v - c) / (1 - c);
            }
            return [hwb[0], c * 100, g * 100];
          };
          convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          };
          convert2.rgb.apple = function(rgb) {
            return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
          };
          convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          };
          convert2.gray.hsl = convert2.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };
          convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };
          convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };
          convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };
          convert2.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 255;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [val / 255 * 100];
          };
        });
        conversions.rgb;
        conversions.hsl;
        conversions.hsv;
        conversions.hwb;
        conversions.cmyk;
        conversions.xyz;
        conversions.lab;
        conversions.lch;
        conversions.hex;
        conversions.keyword;
        conversions.ansi16;
        conversions.ansi256;
        conversions.hcg;
        conversions.apple;
        conversions.gray;
        function buildGraph() {
          var graph = {};
          var models2 = Object.keys(conversions);
          for (var len = models2.length, i = 0; i < len; i++) {
            graph[models2[i]] = {
              // http://jsperf.com/1-vs-infinity
              // micro-opt, but this is simple.
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            var current = queue.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i = 0; i < len; i++) {
              var adjacent = adjacents[i];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from2, to2) {
          return function(args) {
            return to2(from2(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path;
          return fn;
        }
        var route = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models2 = Object.keys(graph);
          for (var len = models2.length, i = 0; i < len; i++) {
            var toModel = models2[i];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result = fn(args);
            if (typeof result === "object") {
              for (var len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        var colorConvert = convert;
        var colorName$1 = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var colorString = {
          getRgba,
          getHsla,
          getRgb,
          getHsl,
          getHwb,
          getAlpha,
          hexString,
          rgbString,
          rgbaString,
          percentString,
          percentaString,
          hslString,
          hslaString,
          hwbString,
          keyword
        };
        function getRgba(string) {
          if (!string) {
            return;
          }
          var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
          var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
          if (match) {
            match = match[1];
            hexAlpha = match[3];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i] + match[i], 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(hex)) {
            hexAlpha = match[2];
            match = match[1];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(rgba)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i + 1]);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(per)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(keyword2)) {
            if (match[1] == "transparent") {
              return [0, 0, 0, 0];
            }
            rgb = colorName$1[match[1]];
            if (!rgb) {
              return;
            }
          }
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = scale(rgb[i], 0, 255);
          }
          if (!a && a != 0) {
            a = 1;
          } else {
            a = scale(a, 0, 1);
          }
          rgb[3] = a;
          return rgb;
        }
        function getHsla(string) {
          if (!string) {
            return;
          }
          var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hsl);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, s, l, a];
          }
        }
        function getHwb(string) {
          if (!string) {
            return;
          }
          var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hwb);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, w, b, a];
          }
        }
        function getRgb(string) {
          var rgba = getRgba(string);
          return rgba && rgba.slice(0, 3);
        }
        function getHsl(string) {
          var hsla = getHsla(string);
          return hsla && hsla.slice(0, 3);
        }
        function getAlpha(string) {
          var vals = getRgba(string);
          if (vals) {
            return vals[3];
          } else if (vals = getHsla(string)) {
            return vals[3];
          } else if (vals = getHwb(string)) {
            return vals[3];
          }
        }
        function hexString(rgba, a) {
          var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
          return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
        }
        function rgbString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return rgbaString(rgba, alpha);
          }
          return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
        }
        function rgbaString(rgba, alpha) {
          if (alpha === void 0) {
            alpha = rgba[3] !== void 0 ? rgba[3] : 1;
          }
          return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
        }
        function percentString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return percentaString(rgba, alpha);
          }
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgb(" + r + "%, " + g + "%, " + b + "%)";
        }
        function percentaString(rgba, alpha) {
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
        }
        function hslString(hsla, alpha) {
          if (alpha < 1 || hsla[3] && hsla[3] < 1) {
            return hslaString(hsla, alpha);
          }
          return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
        }
        function hslaString(hsla, alpha) {
          if (alpha === void 0) {
            alpha = hsla[3] !== void 0 ? hsla[3] : 1;
          }
          return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
        }
        function hwbString(hwb, alpha) {
          if (alpha === void 0) {
            alpha = hwb[3] !== void 0 ? hwb[3] : 1;
          }
          return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
        }
        function keyword(rgb) {
          return reverseNames[rgb.slice(0, 3)];
        }
        function scale(num, min2, max2) {
          return Math.min(Math.max(min2, num), max2);
        }
        function hexDouble(num) {
          var str = num.toString(16).toUpperCase();
          return str.length < 2 ? "0" + str : str;
        }
        var reverseNames = {};
        for (var name in colorName$1) {
          reverseNames[colorName$1[name]] = name;
        }
        var Color = function(obj) {
          if (obj instanceof Color) {
            return obj;
          }
          if (!(this instanceof Color)) {
            return new Color(obj);
          }
          this.valid = false;
          this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          };
          var vals;
          if (typeof obj === "string") {
            vals = colorString.getRgba(obj);
            if (vals) {
              this.setValues("rgb", vals);
            } else if (vals = colorString.getHsla(obj)) {
              this.setValues("hsl", vals);
            } else if (vals = colorString.getHwb(obj)) {
              this.setValues("hwb", vals);
            }
          } else if (typeof obj === "object") {
            vals = obj;
            if (vals.r !== void 0 || vals.red !== void 0) {
              this.setValues("rgb", vals);
            } else if (vals.l !== void 0 || vals.lightness !== void 0) {
              this.setValues("hsl", vals);
            } else if (vals.v !== void 0 || vals.value !== void 0) {
              this.setValues("hsv", vals);
            } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
              this.setValues("hwb", vals);
            } else if (vals.c !== void 0 || vals.cyan !== void 0) {
              this.setValues("cmyk", vals);
            }
          }
        };
        Color.prototype = {
          isValid: function() {
            return this.valid;
          },
          rgb: function() {
            return this.setSpace("rgb", arguments);
          },
          hsl: function() {
            return this.setSpace("hsl", arguments);
          },
          hsv: function() {
            return this.setSpace("hsv", arguments);
          },
          hwb: function() {
            return this.setSpace("hwb", arguments);
          },
          cmyk: function() {
            return this.setSpace("cmyk", arguments);
          },
          rgbArray: function() {
            return this.values.rgb;
          },
          hslArray: function() {
            return this.values.hsl;
          },
          hsvArray: function() {
            return this.values.hsv;
          },
          hwbArray: function() {
            var values = this.values;
            if (values.alpha !== 1) {
              return values.hwb.concat([values.alpha]);
            }
            return values.hwb;
          },
          cmykArray: function() {
            return this.values.cmyk;
          },
          rgbaArray: function() {
            var values = this.values;
            return values.rgb.concat([values.alpha]);
          },
          hslaArray: function() {
            var values = this.values;
            return values.hsl.concat([values.alpha]);
          },
          alpha: function(val) {
            if (val === void 0) {
              return this.values.alpha;
            }
            this.setValues("alpha", val);
            return this;
          },
          red: function(val) {
            return this.setChannel("rgb", 0, val);
          },
          green: function(val) {
            return this.setChannel("rgb", 1, val);
          },
          blue: function(val) {
            return this.setChannel("rgb", 2, val);
          },
          hue: function(val) {
            if (val) {
              val %= 360;
              val = val < 0 ? 360 + val : val;
            }
            return this.setChannel("hsl", 0, val);
          },
          saturation: function(val) {
            return this.setChannel("hsl", 1, val);
          },
          lightness: function(val) {
            return this.setChannel("hsl", 2, val);
          },
          saturationv: function(val) {
            return this.setChannel("hsv", 1, val);
          },
          whiteness: function(val) {
            return this.setChannel("hwb", 1, val);
          },
          blackness: function(val) {
            return this.setChannel("hwb", 2, val);
          },
          value: function(val) {
            return this.setChannel("hsv", 2, val);
          },
          cyan: function(val) {
            return this.setChannel("cmyk", 0, val);
          },
          magenta: function(val) {
            return this.setChannel("cmyk", 1, val);
          },
          yellow: function(val) {
            return this.setChannel("cmyk", 2, val);
          },
          black: function(val) {
            return this.setChannel("cmyk", 3, val);
          },
          hexString: function() {
            return colorString.hexString(this.values.rgb);
          },
          rgbString: function() {
            return colorString.rgbString(this.values.rgb, this.values.alpha);
          },
          rgbaString: function() {
            return colorString.rgbaString(this.values.rgb, this.values.alpha);
          },
          percentString: function() {
            return colorString.percentString(this.values.rgb, this.values.alpha);
          },
          hslString: function() {
            return colorString.hslString(this.values.hsl, this.values.alpha);
          },
          hslaString: function() {
            return colorString.hslaString(this.values.hsl, this.values.alpha);
          },
          hwbString: function() {
            return colorString.hwbString(this.values.hwb, this.values.alpha);
          },
          keyword: function() {
            return colorString.keyword(this.values.rgb, this.values.alpha);
          },
          rgbNumber: function() {
            var rgb = this.values.rgb;
            return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
          },
          luminosity: function() {
            var rgb = this.values.rgb;
            var lum = [];
            for (var i = 0; i < rgb.length; i++) {
              var chan = rgb[i] / 255;
              lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
          },
          contrast: function(color2) {
            var lum1 = this.luminosity();
            var lum2 = color2.luminosity();
            if (lum1 > lum2) {
              return (lum1 + 0.05) / (lum2 + 0.05);
            }
            return (lum2 + 0.05) / (lum1 + 0.05);
          },
          level: function(color2) {
            var contrastRatio = this.contrast(color2);
            if (contrastRatio >= 7.1) {
              return "AAA";
            }
            return contrastRatio >= 4.5 ? "AA" : "";
          },
          dark: function() {
            var rgb = this.values.rgb;
            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
            return yiq < 128;
          },
          light: function() {
            return !this.dark();
          },
          negate: function() {
            var rgb = [];
            for (var i = 0; i < 3; i++) {
              rgb[i] = 255 - this.values.rgb[i];
            }
            this.setValues("rgb", rgb);
            return this;
          },
          lighten: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] += hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          darken: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] -= hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          saturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] += hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          desaturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] -= hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          whiten: function(ratio) {
            var hwb = this.values.hwb;
            hwb[1] += hwb[1] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          blacken: function(ratio) {
            var hwb = this.values.hwb;
            hwb[2] += hwb[2] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          greyscale: function() {
            var rgb = this.values.rgb;
            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
            this.setValues("rgb", [val, val, val]);
            return this;
          },
          clearer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha - alpha * ratio);
            return this;
          },
          opaquer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha + alpha * ratio);
            return this;
          },
          rotate: function(degrees) {
            var hsl = this.values.hsl;
            var hue = (hsl[0] + degrees) % 360;
            hsl[0] = hue < 0 ? 360 + hue : hue;
            this.setValues("hsl", hsl);
            return this;
          },
          /**
           * Ported from sass implementation in C
           * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
           */
          mix: function(mixinColor, weight) {
            var color1 = this;
            var color2 = mixinColor;
            var p = weight === void 0 ? 0.5 : weight;
            var w = 2 * p - 1;
            var a = color1.alpha() - color2.alpha();
            var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            var w2 = 1 - w1;
            return this.rgb(
              w1 * color1.red() + w2 * color2.red(),
              w1 * color1.green() + w2 * color2.green(),
              w1 * color1.blue() + w2 * color2.blue()
            ).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
          },
          toJSON: function() {
            return this.rgb();
          },
          clone: function() {
            var result = new Color();
            var source = this.values;
            var target = result.values;
            var value, type;
            for (var prop in source) {
              if (source.hasOwnProperty(prop)) {
                value = source[prop];
                type = {}.toString.call(value);
                if (type === "[object Array]") {
                  target[prop] = value.slice(0);
                } else if (type === "[object Number]") {
                  target[prop] = value;
                } else {
                  console.error("unexpected color value:", value);
                }
              }
            }
            return result;
          }
        };
        Color.prototype.spaces = {
          rgb: ["red", "green", "blue"],
          hsl: ["hue", "saturation", "lightness"],
          hsv: ["hue", "saturation", "value"],
          hwb: ["hue", "whiteness", "blackness"],
          cmyk: ["cyan", "magenta", "yellow", "black"]
        };
        Color.prototype.maxes = {
          rgb: [255, 255, 255],
          hsl: [360, 100, 100],
          hsv: [360, 100, 100],
          hwb: [360, 100, 100],
          cmyk: [100, 100, 100, 100]
        };
        Color.prototype.getValues = function(space) {
          var values = this.values;
          var vals = {};
          for (var i = 0; i < space.length; i++) {
            vals[space.charAt(i)] = values[space][i];
          }
          if (values.alpha !== 1) {
            vals.a = values.alpha;
          }
          return vals;
        };
        Color.prototype.setValues = function(space, vals) {
          var values = this.values;
          var spaces = this.spaces;
          var maxes = this.maxes;
          var alpha = 1;
          var i;
          this.valid = true;
          if (space === "alpha") {
            alpha = vals;
          } else if (vals.length) {
            values[space] = vals.slice(0, space.length);
            alpha = vals[space.length];
          } else if (vals[space.charAt(0)] !== void 0) {
            for (i = 0; i < space.length; i++) {
              values[space][i] = vals[space.charAt(i)];
            }
            alpha = vals.a;
          } else if (vals[spaces[space][0]] !== void 0) {
            var chans = spaces[space];
            for (i = 0; i < space.length; i++) {
              values[space][i] = vals[chans[i]];
            }
            alpha = vals.alpha;
          }
          values.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values.alpha : alpha));
          if (space === "alpha") {
            return false;
          }
          var capped;
          for (i = 0; i < space.length; i++) {
            capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
            values[space][i] = Math.round(capped);
          }
          for (var sname in spaces) {
            if (sname !== space) {
              values[sname] = colorConvert[space][sname](values[space]);
            }
          }
          return true;
        };
        Color.prototype.setSpace = function(space, args) {
          var vals = args[0];
          if (vals === void 0) {
            return this.getValues(space);
          }
          if (typeof vals === "number") {
            vals = Array.prototype.slice.call(args);
          }
          this.setValues(space, vals);
          return this;
        };
        Color.prototype.setChannel = function(space, index2, val) {
          var svalues = this.values[space];
          if (val === void 0) {
            return svalues[index2];
          } else if (val === svalues[index2]) {
            return this;
          }
          svalues[index2] = val;
          this.setValues(space, svalues);
          return this;
        };
        if (typeof window !== "undefined") {
          window.Color = Color;
        }
        var chartjsColor = Color;
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        var helpers = {
          /**
           * An empty function that can be used, for example, for optional callback.
           */
          noop: function() {
          },
          /**
           * Returns a unique id, sequentially generated from a global variable.
           * @returns {number}
           * @function
           */
          uid: function() {
            var id = 0;
            return function() {
              return id++;
            };
          }(),
          /**
           * Returns true if `value` is neither null nor undefined, else returns false.
           * @param {*} value - The value to test.
           * @returns {boolean}
           * @since 2.7.0
           */
          isNullOrUndef: function(value) {
            return value === null || typeof value === "undefined";
          },
          /**
           * Returns true if `value` is an array (including typed arrays), else returns false.
           * @param {*} value - The value to test.
           * @returns {boolean}
           * @function
           */
          isArray: function(value) {
            if (Array.isArray && Array.isArray(value)) {
              return true;
            }
            var type = Object.prototype.toString.call(value);
            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
              return true;
            }
            return false;
          },
          /**
           * Returns true if `value` is an object (excluding null), else returns false.
           * @param {*} value - The value to test.
           * @returns {boolean}
           * @since 2.7.0
           */
          isObject: function(value) {
            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
          },
          /**
           * Returns true if `value` is a finite number, else returns false
           * @param {*} value  - The value to test.
           * @returns {boolean}
           */
          isFinite: function(value) {
            return (typeof value === "number" || value instanceof Number) && isFinite(value);
          },
          /**
           * Returns `value` if defined, else returns `defaultValue`.
           * @param {*} value - The value to return if defined.
           * @param {*} defaultValue - The value to return if `value` is undefined.
           * @returns {*}
           */
          valueOrDefault: function(value, defaultValue) {
            return typeof value === "undefined" ? defaultValue : value;
          },
          /**
           * Returns value at the given `index` in array if defined, else returns `defaultValue`.
           * @param {Array} value - The array to lookup for value at `index`.
           * @param {number} index - The index in `value` to lookup for value.
           * @param {*} defaultValue - The value to return if `value[index]` is undefined.
           * @returns {*}
           */
          valueAtIndexOrDefault: function(value, index2, defaultValue) {
            return helpers.valueOrDefault(helpers.isArray(value) ? value[index2] : value, defaultValue);
          },
          /**
           * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
           * value returned by `fn`. If `fn` is not a function, this method returns undefined.
           * @param {function} fn - The function to call.
           * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
           * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
           * @returns {*}
           */
          callback: function(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") {
              return fn.apply(thisArg, args);
            }
          },
          /**
           * Note(SB) for performance sake, this method should only be used when loopable type
           * is unknown or in none intensive code (not called often and small loopable). Else
           * it's preferable to use a regular for() loop and save extra function calls.
           * @param {object|Array} loopable - The object or array to be iterated.
           * @param {function} fn - The function to call for each item.
           * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
           * @param {boolean} [reverse] - If true, iterates backward on the loopable.
           */
          each: function(loopable, fn, thisArg, reverse) {
            var i, len, keys2;
            if (helpers.isArray(loopable)) {
              len = loopable.length;
              if (reverse) {
                for (i = len - 1; i >= 0; i--) {
                  fn.call(thisArg, loopable[i], i);
                }
              } else {
                for (i = 0; i < len; i++) {
                  fn.call(thisArg, loopable[i], i);
                }
              }
            } else if (helpers.isObject(loopable)) {
              keys2 = Object.keys(loopable);
              len = keys2.length;
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[keys2[i]], keys2[i]);
              }
            }
          },
          /**
           * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
           * @see https://stackoverflow.com/a/14853974
           * @param {Array} a0 - The array to compare
           * @param {Array} a1 - The array to compare
           * @returns {boolean}
           */
          arrayEquals: function(a0, a1) {
            var i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) {
              return false;
            }
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
              v0 = a0[i];
              v1 = a1[i];
              if (v0 instanceof Array && v1 instanceof Array) {
                if (!helpers.arrayEquals(v0, v1)) {
                  return false;
                }
              } else if (v0 !== v1) {
                return false;
              }
            }
            return true;
          },
          /**
           * Returns a deep copy of `source` without keeping references on objects and arrays.
           * @param {*} source - The value to clone.
           * @returns {*}
           */
          clone: function(source) {
            if (helpers.isArray(source)) {
              return source.map(helpers.clone);
            }
            if (helpers.isObject(source)) {
              var target = Object.create(source);
              var keys2 = Object.keys(source);
              var klen = keys2.length;
              var k2 = 0;
              for (; k2 < klen; ++k2) {
                target[keys2[k2]] = helpers.clone(source[keys2[k2]]);
              }
              return target;
            }
            return source;
          },
          /**
           * The default merger when Chart.helpers.merge is called without merger option.
           * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
           * @private
           */
          _merger: function(key, target, source, options2) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.merge(tval, sval, options2);
            } else {
              target[key] = helpers.clone(sval);
            }
          },
          /**
           * Merges source[key] in target[key] only if target[key] is undefined.
           * @private
           */
          _mergerIf: function(key, target, source) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.mergeIf(tval, sval);
            } else if (!target.hasOwnProperty(key)) {
              target[key] = helpers.clone(sval);
            }
          },
          /**
           * Recursively deep copies `source` properties into `target` with the given `options`.
           * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
           * @param {object} target - The target object in which all sources are merged into.
           * @param {object|object[]} source - Object(s) to merge into `target`.
           * @param {object} [options] - Merging options:
           * @param {function} [options.merger] - The merge method (key, target, source, options)
           * @returns {object} The `target` object.
           */
          merge: function(target, source, options2) {
            var sources = helpers.isArray(source) ? source : [source];
            var ilen = sources.length;
            var merge, i, keys2, klen, k2;
            if (!helpers.isObject(target)) {
              return target;
            }
            options2 = options2 || {};
            merge = options2.merger || helpers._merger;
            for (i = 0; i < ilen; ++i) {
              source = sources[i];
              if (!helpers.isObject(source)) {
                continue;
              }
              keys2 = Object.keys(source);
              for (k2 = 0, klen = keys2.length; k2 < klen; ++k2) {
                merge(keys2[k2], target, source, options2);
              }
            }
            return target;
          },
          /**
           * Recursively deep copies `source` properties into `target` *only* if not defined in target.
           * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
           * @param {object} target - The target object in which all sources are merged into.
           * @param {object|object[]} source - Object(s) to merge into `target`.
           * @returns {object} The `target` object.
           */
          mergeIf: function(target, source) {
            return helpers.merge(target, source, { merger: helpers._mergerIf });
          },
          /**
           * Applies the contents of two or more objects together into the first object.
           * @param {object} target - The target object in which all objects are merged into.
           * @param {object} arg1 - Object containing additional properties to merge in target.
           * @param {object} argN - Additional objects containing properties to merge in target.
           * @returns {object} The `target` object.
           */
          extend: Object.assign || function(target) {
            return helpers.merge(target, [].slice.call(arguments, 1), {
              merger: function(key, dst, src2) {
                dst[key] = src2[key];
              }
            });
          },
          /**
           * Basic javascript inheritance based on the model created in Backbone.js
           */
          inherits: function(extensions) {
            var me = this;
            var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
              return me.apply(this, arguments);
            };
            var Surrogate = function() {
              this.constructor = ChartElement;
            };
            Surrogate.prototype = me.prototype;
            ChartElement.prototype = new Surrogate();
            ChartElement.extend = helpers.inherits;
            if (extensions) {
              helpers.extend(ChartElement.prototype, extensions);
            }
            ChartElement.__super__ = me.prototype;
            return ChartElement;
          },
          _deprecated: function(scope, value, previous, current) {
            if (value !== void 0) {
              console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
            }
          }
        };
        var helpers_core = helpers;
        helpers.callCallback = helpers.callback;
        helpers.indexOf = function(array, item, fromIndex) {
          return Array.prototype.indexOf.call(array, item, fromIndex);
        };
        helpers.getValueOrDefault = helpers.valueOrDefault;
        helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
        var effects = {
          linear: function(t) {
            return t;
          },
          easeInQuad: function(t) {
            return t * t;
          },
          easeOutQuad: function(t) {
            return -t * (t - 2);
          },
          easeInOutQuad: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t;
            }
            return -0.5 * (--t * (t - 2) - 1);
          },
          easeInCubic: function(t) {
            return t * t * t;
          },
          easeOutCubic: function(t) {
            return (t = t - 1) * t * t + 1;
          },
          easeInOutCubic: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t + 2);
          },
          easeInQuart: function(t) {
            return t * t * t * t;
          },
          easeOutQuart: function(t) {
            return -((t = t - 1) * t * t * t - 1);
          },
          easeInOutQuart: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t;
            }
            return -0.5 * ((t -= 2) * t * t * t - 2);
          },
          easeInQuint: function(t) {
            return t * t * t * t * t;
          },
          easeOutQuint: function(t) {
            return (t = t - 1) * t * t * t * t + 1;
          },
          easeInOutQuint: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t * t * t + 2);
          },
          easeInSine: function(t) {
            return -Math.cos(t * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t) {
            return Math.sin(t * (Math.PI / 2));
          },
          easeInOutSine: function(t) {
            return -0.5 * (Math.cos(Math.PI * t) - 1);
          },
          easeInExpo: function(t) {
            return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
          },
          easeOutExpo: function(t) {
            return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
          },
          easeInOutExpo: function(t) {
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if ((t /= 0.5) < 1) {
              return 0.5 * Math.pow(2, 10 * (t - 1));
            }
            return 0.5 * (-Math.pow(2, -10 * --t) + 2);
          },
          easeInCirc: function(t) {
            if (t >= 1) {
              return t;
            }
            return -(Math.sqrt(1 - t * t) - 1);
          },
          easeOutCirc: function(t) {
            return Math.sqrt(1 - (t = t - 1) * t);
          },
          easeInOutCirc: function(t) {
            if ((t /= 0.5) < 1) {
              return -0.5 * (Math.sqrt(1 - t * t) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
          },
          easeInElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
          },
          easeOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
          },
          easeInOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if ((t /= 0.5) === 2) {
              return 1;
            }
            if (!p) {
              p = 0.45;
            }
            {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            if (t < 1) {
              return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
          },
          easeInBack: function(t) {
            var s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack: function(t) {
            var s = 1.70158;
            return (t = t - 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack: function(t) {
            var s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: function(t) {
            return 1 - effects.easeOutBounce(1 - t);
          },
          easeOutBounce: function(t) {
            if (t < 1 / 2.75) {
              return 7.5625 * t * t;
            }
            if (t < 2 / 2.75) {
              return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            }
            if (t < 2.5 / 2.75) {
              return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            }
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
          },
          easeInOutBounce: function(t) {
            if (t < 0.5) {
              return effects.easeInBounce(t * 2) * 0.5;
            }
            return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
          }
        };
        var helpers_easing = {
          effects
        };
        helpers_core.easingEffects = effects;
        var PI = Math.PI;
        var RAD_PER_DEG = PI / 180;
        var DOUBLE_PI = PI * 2;
        var HALF_PI = PI / 2;
        var QUARTER_PI = PI / 4;
        var TWO_THIRDS_PI = PI * 2 / 3;
        var exports$1 = {
          /**
           * Clears the entire canvas associated to the given `chart`.
           * @param {Chart} chart - The chart for which to clear the canvas.
           */
          clear: function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
          },
          /**
           * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
           * given size (width, height) and the same `radius` for all corners.
           * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
           * @param {number} x - The x axis of the coordinate for the rectangle starting point.
           * @param {number} y - The y axis of the coordinate for the rectangle starting point.
           * @param {number} width - The rectangle's width.
           * @param {number} height - The rectangle's height.
           * @param {number} radius - The rounded amount (in pixels) for the four corners.
           * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
           */
          roundedRect: function(ctx, x, y, width, height, radius) {
            if (radius) {
              var r = Math.min(radius, height / 2, width / 2);
              var left = x + r;
              var top = y + r;
              var right = x + width - r;
              var bottom = y + height - r;
              ctx.moveTo(x, top);
              if (left < right && top < bottom) {
                ctx.arc(left, top, r, -PI, -HALF_PI);
                ctx.arc(right, top, r, -HALF_PI, 0);
                ctx.arc(right, bottom, r, 0, HALF_PI);
                ctx.arc(left, bottom, r, HALF_PI, PI);
              } else if (left < right) {
                ctx.moveTo(left, y);
                ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
              } else if (top < bottom) {
                ctx.arc(left, top, r, -PI, 0);
                ctx.arc(left, bottom, r, 0, PI);
              } else {
                ctx.arc(left, top, r, -PI, PI);
              }
              ctx.closePath();
              ctx.moveTo(x, y);
            } else {
              ctx.rect(x, y, width, height);
            }
          },
          drawPoint: function(ctx, style, radius, x, y, rotation) {
            var type, xOffset, yOffset, size, cornerRadius;
            var rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
              type = style.toString();
              if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
              }
            }
            if (isNaN(radius) || radius <= 0) {
              return;
            }
            ctx.beginPath();
            switch (style) {
              default:
                ctx.arc(x, y, radius, 0, DOUBLE_PI);
                ctx.closePath();
                break;
              case "triangle":
                ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;
              case "rectRounded":
                cornerRadius = radius * 0.516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
              case "rect":
                if (!rotation) {
                  size = Math.SQRT1_2 * radius;
                  ctx.rect(x - size, y - size, 2 * size, 2 * size);
                  break;
                }
                rad += QUARTER_PI;
              case "rectRot":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + yOffset, y - xOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                ctx.closePath();
                break;
              case "crossRot":
                rad += QUARTER_PI;
              case "cross":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "star":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "line":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;
              case "dash":
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                break;
            }
            ctx.fill();
            ctx.stroke();
          },
          /**
           * Returns true if the point is inside the rectangle
           * @param {object} point - The point to test
           * @param {object} area - The rectangle
           * @returns {boolean}
           * @private
           */
          _isPointInArea: function(point, area) {
            var epsilon = 1e-6;
            return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
          },
          clipArea: function(ctx, area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
            ctx.clip();
          },
          unclipArea: function(ctx) {
            ctx.restore();
          },
          lineTo: function(ctx, previous, target, flip) {
            var stepped = target.steppedLine;
            if (stepped) {
              if (stepped === "middle") {
                var midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                ctx.lineTo(midpoint, flip ? previous.y : target.y);
              } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
                ctx.lineTo(previous.x, target.y);
              } else {
                ctx.lineTo(target.x, previous.y);
              }
              ctx.lineTo(target.x, target.y);
              return;
            }
            if (!target.tension) {
              ctx.lineTo(target.x, target.y);
              return;
            }
            ctx.bezierCurveTo(
              flip ? previous.controlPointPreviousX : previous.controlPointNextX,
              flip ? previous.controlPointPreviousY : previous.controlPointNextY,
              flip ? target.controlPointNextX : target.controlPointPreviousX,
              flip ? target.controlPointNextY : target.controlPointPreviousY,
              target.x,
              target.y
            );
          }
        };
        var helpers_canvas = exports$1;
        helpers_core.clear = exports$1.clear;
        helpers_core.drawRoundedRectangle = function(ctx) {
          ctx.beginPath();
          exports$1.roundedRect.apply(exports$1, arguments);
        };
        var defaults2 = {
          /**
           * @private
           */
          _set: function(scope, values) {
            return helpers_core.merge(this[scope] || (this[scope] = {}), values);
          }
        };
        defaults2._set("global", {
          defaultColor: "rgba(0,0,0,0.1)",
          defaultFontColor: "#666",
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: "normal",
          defaultLineHeight: 1.2,
          showLines: true
        });
        var core_defaults = defaults2;
        var valueOrDefault = helpers_core.valueOrDefault;
        function toFontString(font) {
          if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        var helpers_options = {
          /**
           * Converts the given line height `value` in pixels for a specific font `size`.
           * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
           * @param {number} size - The font size (in pixels) used to resolve relative `value`.
           * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
           * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
           * @since 2.7.0
           */
          toLineHeight: function(value, size) {
            var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
            if (!matches || matches[1] === "normal") {
              return size * 1.2;
            }
            value = +matches[2];
            switch (matches[3]) {
              case "px":
                return value;
              case "%":
                value /= 100;
                break;
            }
            return size * value;
          },
          /**
           * Converts the given value into a padding object with pre-computed width/height.
           * @param {number|object} value - If a number, set the value to all TRBL component,
           *  else, if and object, use defined properties and sets undefined ones to 0.
           * @returns {object} The padding values (top, right, bottom, left, width, height)
           * @since 2.7.0
           */
          toPadding: function(value) {
            var t, r, b, l;
            if (helpers_core.isObject(value)) {
              t = +value.top || 0;
              r = +value.right || 0;
              b = +value.bottom || 0;
              l = +value.left || 0;
            } else {
              t = r = b = l = +value || 0;
            }
            return {
              top: t,
              right: r,
              bottom: b,
              left: l,
              height: t + b,
              width: l + r
            };
          },
          /**
           * Parses font options and returns the font object.
           * @param {object} options - A object that contains font options to be parsed.
           * @return {object} The font object.
           * @todo Support font.* options and renamed to toFont().
           * @private
           */
          _parseFont: function(options2) {
            var globalDefaults = core_defaults.global;
            var size = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
            var font = {
              family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
              lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size),
              size,
              style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
              weight: null,
              string: ""
            };
            font.string = toFontString(font);
            return font;
          },
          /**
           * Evaluates the given `inputs` sequentially and returns the first defined value.
           * @param {Array} inputs - An array of values, falling back to the last value.
           * @param {object} [context] - If defined and the current value is a function, the value
           * is called with `context` as first argument and the result becomes the new input.
           * @param {number} [index] - If defined and the current value is an array, the value
           * at `index` become the new input.
           * @param {object} [info] - object to return information about resolution in
           * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.
           * @since 2.7.0
           */
          resolve: function(inputs, context, index2, info) {
            var cacheable = true;
            var i, ilen, value;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
              value = inputs[i];
              if (value === void 0) {
                continue;
              }
              if (context !== void 0 && typeof value === "function") {
                value = value(context);
                cacheable = false;
              }
              if (index2 !== void 0 && helpers_core.isArray(value)) {
                value = value[index2];
                cacheable = false;
              }
              if (value !== void 0) {
                if (info && !cacheable) {
                  info.cacheable = false;
                }
                return value;
              }
            }
          }
        };
        var exports$2 = {
          /**
           * Returns an array of factors sorted from 1 to sqrt(value)
           * @private
           */
          _factorize: function(value) {
            var result = [];
            var sqrt = Math.sqrt(value);
            var i;
            for (i = 1; i < sqrt; i++) {
              if (value % i === 0) {
                result.push(i);
                result.push(value / i);
              }
            }
            if (sqrt === (sqrt | 0)) {
              result.push(sqrt);
            }
            result.sort(function(a, b) {
              return a - b;
            }).pop();
            return result;
          },
          log10: Math.log10 || function(x) {
            var exponent = Math.log(x) * Math.LOG10E;
            var powerOf10 = Math.round(exponent);
            var isPowerOf10 = x === Math.pow(10, powerOf10);
            return isPowerOf10 ? powerOf10 : exponent;
          }
        };
        var helpers_math = exports$2;
        helpers_core.log10 = exports$2.log10;
        var getRtlAdapter = function(rectX, width) {
          return {
            x: function(x) {
              return rectX + rectX + width - x;
            },
            setWidth: function(w) {
              width = w;
            },
            textAlign: function(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus: function(x, value) {
              return x - value;
            },
            leftForLtr: function(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        var getLtrAdapter = function() {
          return {
            x: function(x) {
              return x;
            },
            setWidth: function(w) {
            },
            textAlign: function(align) {
              return align;
            },
            xPlus: function(x, value) {
              return x + value;
            },
            leftForLtr: function(x, _itemWidth) {
              return x;
            }
          };
        };
        var getAdapter = function(rtl2, rectX, width) {
          return rtl2 ? getRtlAdapter(rectX, width) : getLtrAdapter();
        };
        var overrideTextDirection = function(ctx, direction) {
          var style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        };
        var restoreTextDirection = function(ctx) {
          var original = ctx.prevTextDirection;
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        };
        var helpers_rtl = {
          getRtlAdapter: getAdapter,
          overrideTextDirection,
          restoreTextDirection
        };
        var helpers$1 = helpers_core;
        var easing = helpers_easing;
        var canvas = helpers_canvas;
        var options = helpers_options;
        var math = helpers_math;
        var rtl = helpers_rtl;
        helpers$1.easing = easing;
        helpers$1.canvas = canvas;
        helpers$1.options = options;
        helpers$1.math = math;
        helpers$1.rtl = rtl;
        function interpolate(start, view, model, ease) {
          var keys2 = Object.keys(model);
          var i, ilen, key, actual, origin, target, type, c0, c1;
          for (i = 0, ilen = keys2.length; i < ilen; ++i) {
            key = keys2[i];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start.hasOwnProperty(key)) {
              start[key] = actual;
            }
            origin = start[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = chartjsColor(origin);
                if (c0.valid) {
                  c1 = chartjsColor(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        var Element = function(configuration) {
          helpers$1.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers$1.extend(Element.prototype, {
          _type: void 0,
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me = this;
            if (!me._view) {
              me._view = helpers$1.extend({}, me._model);
            }
            me._start = {};
            return me;
          },
          transition: function(ease) {
            var me = this;
            var model = me._model;
            var start = me._start;
            var view = me._view;
            if (!model || ease === 1) {
              me._view = helpers$1.extend({}, model);
              me._start = null;
              return me;
            }
            if (!view) {
              view = me._view = {};
            }
            if (!start) {
              start = me._start = {};
            }
            interpolate(start, view, model, ease);
            return me;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
          }
        });
        Element.extend = helpers$1.inherits;
        var core_element = Element;
        var exports$3 = core_element.extend({
          chart: null,
          // the animation associated chart instance
          currentStep: 0,
          // the current animation step
          numSteps: 60,
          // default number of steps
          easing: "",
          // the easing to use for this animation
          render: null,
          // render function used by the animation service
          onAnimationProgress: null,
          // user specified callback to fire on each step of the animation
          onAnimationComplete: null
          // user specified callback to fire when the animation finishes
        });
        var core_animation = exports$3;
        Object.defineProperty(exports$3.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(exports$3.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value) {
            this.chart = value;
          }
        });
        core_defaults._set("global", {
          animation: {
            duration: 1e3,
            easing: "easeOutQuart",
            onProgress: helpers$1.noop,
            onComplete: helpers$1.noop
          }
        });
        var core_animations = {
          animations: [],
          request: null,
          /**
           * @param {Chart} chart - The chart to animate.
           * @param {Chart.Animation} animation - The animation that we will animate.
           * @param {number} duration - The animation duration in ms.
           * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
           */
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i, ilen;
            animation.chart = chart;
            animation.startTime = Date.now();
            animation.duration = duration;
            if (!lazy) {
              chart.animating = true;
            }
            for (i = 0, ilen = animations.length; i < ilen; ++i) {
              if (animations[i].chart === chart) {
                animations[i] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index2 = helpers$1.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index2 !== -1) {
              this.animations.splice(index2, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me = this;
            if (me.request === null) {
              me.request = helpers$1.requestAnimFrame.call(window, function() {
                me.request = null;
                me.startDigest();
              });
            }
          },
          /**
           * @private
           */
          startDigest: function() {
            var me = this;
            me.advance();
            if (me.animations.length > 0) {
              me.requestAnimationFrame();
            }
          },
          /**
           * @private
           */
          advance: function() {
            var animations = this.animations;
            var animation, chart, numSteps, nextStep;
            var i = 0;
            while (i < animations.length) {
              animation = animations[i];
              chart = animation.chart;
              numSteps = animation.numSteps;
              nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
              animation.currentStep = Math.min(nextStep, numSteps);
              helpers$1.callback(animation.render, [chart, animation], chart);
              helpers$1.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= numSteps) {
                helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i, 1);
              } else {
                ++i;
              }
            }
          }
        };
        var resolve = helpers$1.options.resolve;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers$1.each(array._chartjs.listeners, function(object) {
                  if (typeof object[method] === "function") {
                    object[method].apply(object, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index2 = listeners.indexOf(listener);
          if (index2 !== -1) {
            listeners.splice(index2, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        var DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers$1.extend(DatasetController.prototype, {
          /**
           * Element type used to generate a meta dataset (e.g. Chart.element.Line).
           * @type {Chart.core.element}
           */
          datasetElementType: null,
          /**
           * Element type used to generate a meta data (e.g. Chart.element.Point).
           * @type {Chart.core.element}
           */
          dataElementType: null,
          /**
           * Dataset element option keys to be resolved in _resolveDatasetElementOptions.
           * A derived controller may override this to resolve controller-specific options.
           * The keys defined here are for backward compatibility for legend styles.
           * @private
           */
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth"
          ],
          /**
           * Data element option keys to be resolved in _resolveDataElementOptions.
           * A derived controller may override this to resolve controller-specific options.
           * The keys defined here are for backward compatibility for legend styles.
           * @private
           */
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "pointStyle"
          ],
          initialize: function(chart, datasetIndex) {
            var me = this;
            me.chart = chart;
            me.index = datasetIndex;
            me.linkScales();
            me.addElements();
            me._type = me.getMeta().type;
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me = this;
            var meta = me.getMeta();
            var chart = me.chart;
            var scales2 = chart.scales;
            var dataset = me.getDataset();
            var scalesOpts = chart.options.scales;
            if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
              meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
            }
            if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
              meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          /**
           * @private
           */
          _getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          /**
           * @private
           */
          _getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          /**
           * @private
           */
          _getValueScale: function() {
            return this.getScaleForId(this._getValueScaleId());
          },
          /**
           * @private
           */
          _getIndexScale: function() {
            return this.getScaleForId(this._getIndexScaleId());
          },
          reset: function() {
            this._update(true);
          },
          /**
           * @private
           */
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me = this;
            var type = me.datasetElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index
            });
          },
          createMetaData: function(index2) {
            var me = this;
            var type = me.dataElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index,
              _index: index2
            });
          },
          addElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data || [];
            var metaData = meta.data;
            var i, ilen;
            for (i = 0, ilen = data.length; i < ilen; ++i) {
              metaData[i] = metaData[i] || me.createMetaData(i);
            }
            meta.dataset = meta.dataset || me.createMetaDataset();
          },
          addElementAndReset: function(index2) {
            var element = this.createMetaData(index2);
            this.getMeta().data.splice(index2, 0, element);
            this.updateElement(element, index2, true);
          },
          buildOrUpdateElements: function() {
            var me = this;
            var dataset = me.getDataset();
            var data = dataset.data || (dataset.data = []);
            if (me._data !== data) {
              if (me._data) {
                unlistenArrayEvents(me._data, me);
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, me);
              }
              me._data = data;
            }
            me.resyncElements();
          },
          /**
           * Returns the merged user-supplied and default dataset-level options
           * @private
           */
          _configure: function() {
            var me = this;
            me._config = helpers$1.merge(/* @__PURE__ */ Object.create(null), [
              me.chart.options.datasets[me._type],
              me.getDataset()
            ], {
              merger: function(key, target, source) {
                if (key !== "_meta" && key !== "data") {
                  helpers$1._merger(key, target, source);
                }
              }
            });
          },
          _update: function(reset) {
            var me = this;
            me._configure();
            me._cachedDataOpts = null;
            me.update(reset);
          },
          update: helpers$1.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            for (; i < ilen; ++i) {
              elements2[i].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i < ilen; ++i) {
              elements2[i].draw();
            }
          },
          /**
           * Returns a set of predefined style properties that should be used to represent the dataset
           * or the data if the index is specified
           * @param {number} index - data index
           * @return {IStyleInterface} style object
           */
          getStyle: function(index2) {
            var me = this;
            var meta = me.getMeta();
            var dataset = meta.dataset;
            var style;
            me._configure();
            if (dataset && index2 === void 0) {
              style = me._resolveDatasetElementOptions(dataset || {});
            } else {
              index2 = index2 || 0;
              style = me._resolveDataElementOptions(meta.data[index2] || {}, index2);
            }
            if (style.fill === false || style.fill === null) {
              style.backgroundColor = style.borderColor;
            }
            return style;
          },
          /**
           * @private
           */
          _resolveDatasetElementOptions: function(element, hover) {
            var me = this;
            var chart = me.chart;
            var datasetOpts = me._config;
            var custom = element.custom || {};
            var options2 = chart.options.elements[me.datasetElementType.prototype._type] || {};
            var elementOptions = me._datasetElementOptions;
            var values = {};
            var i, ilen, key, readKey;
            var context = {
              chart,
              dataset: me.getDataset(),
              datasetIndex: me.index,
              hover
            };
            for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
              key = elementOptions[i];
              readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
              values[key] = resolve([
                custom[readKey],
                datasetOpts[readKey],
                options2[readKey]
              ], context);
            }
            return values;
          },
          /**
           * @private
           */
          _resolveDataElementOptions: function(element, index2) {
            var me = this;
            var custom = element && element.custom;
            var cached = me._cachedDataOpts;
            if (cached && !custom) {
              return cached;
            }
            var chart = me.chart;
            var datasetOpts = me._config;
            var options2 = chart.options.elements[me.dataElementType.prototype._type] || {};
            var elementOptions = me._dataElementOptions;
            var values = {};
            var context = {
              chart,
              dataIndex: index2,
              dataset: me.getDataset(),
              datasetIndex: me.index
            };
            var info = { cacheable: !custom };
            var keys2, i, ilen, key;
            custom = custom || {};
            if (helpers$1.isArray(elementOptions)) {
              for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                key = elementOptions[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[key],
                  options2[key]
                ], context, index2, info);
              }
            } else {
              keys2 = Object.keys(elementOptions);
              for (i = 0, ilen = keys2.length; i < ilen; ++i) {
                key = keys2[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[elementOptions[key]],
                  datasetOpts[key],
                  options2[key]
                ], context, index2, info);
              }
            }
            if (info.cacheable) {
              me._cachedDataOpts = Object.freeze(values);
            }
            return values;
          },
          removeHoverStyle: function(element) {
            helpers$1.merge(element._model, element.$previousStyle || {});
            delete element.$previousStyle;
          },
          setHoverStyle: function(element) {
            var dataset = this.chart.data.datasets[element._datasetIndex];
            var index2 = element._index;
            var custom = element.custom || {};
            var model = element._model;
            var getHoverColor = helpers$1.getHoverColor;
            element.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index2);
            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index2);
            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index2);
          },
          /**
           * @private
           */
          _removeDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            if (element) {
              this.removeHoverStyle(element);
            }
          },
          /**
           * @private
           */
          _setDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            var prev = {};
            var i, ilen, key, keys2, hoverOptions, model;
            if (!element) {
              return;
            }
            model = element._model;
            hoverOptions = this._resolveDatasetElementOptions(element, true);
            keys2 = Object.keys(hoverOptions);
            for (i = 0, ilen = keys2.length; i < ilen; ++i) {
              key = keys2[i];
              prev[key] = model[key];
              model[key] = hoverOptions[key];
            }
            element.$previousStyle = prev;
          },
          /**
           * @private
           */
          resyncElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data = me.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me.insertElements(numMeta, numData - numMeta);
            }
          },
          /**
           * @private
           */
          insertElements: function(start, count) {
            for (var i = 0; i < count; ++i) {
              this.addElementAndReset(start + i);
            }
          },
          /**
           * @private
           */
          onDataPush: function() {
            var count = arguments.length;
            this.insertElements(this.getDataset().data.length - count, count);
          },
          /**
           * @private
           */
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          /**
           * @private
           */
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          /**
           * @private
           */
          onDataSplice: function(start, count) {
            this.getMeta().data.splice(start, count);
            this.insertElements(start, arguments.length - 2);
          },
          /**
           * @private
           */
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        DatasetController.extend = helpers$1.inherits;
        var core_datasetController = DatasetController;
        var TAU = Math.PI * 2;
        core_defaults._set("global", {
          elements: {
            arc: {
              backgroundColor: core_defaults.global.defaultColor,
              borderColor: "#fff",
              borderWidth: 2,
              borderAlign: "center"
            }
          }
        });
        function clipArc(ctx, arc) {
          var startAngle = arc.startAngle;
          var endAngle = arc.endAngle;
          var pixelMargin = arc.pixelMargin;
          var angleMargin = pixelMargin / arc.outerRadius;
          var x = arc.x;
          var y = arc.y;
          ctx.beginPath();
          ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (arc.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / arc.innerRadius;
            ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
        }
        function drawFullCircleBorders(ctx, vm, arc, inner) {
          var endAngle = arc.endAngle;
          var i;
          if (inner) {
            arc.endAngle = arc.startAngle + TAU;
            clipArc(ctx, arc);
            arc.endAngle = endAngle;
            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
              arc.endAngle += TAU;
              arc.fullCircles--;
            }
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, vm, arc) {
          var inner = vm.borderAlign === "inner";
          if (inner) {
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = "round";
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = "bevel";
          }
          if (arc.fullCircles) {
            drawFullCircleBorders(ctx, vm, arc, inner);
          }
          if (inner) {
            clipArc(ctx, arc);
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          ctx.stroke();
        }
        var element_arc = core_element.extend({
          _type: "arc",
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
              var angle = pointRelativePosition.angle;
              var distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += TAU;
              }
              while (angle > endAngle) {
                angle -= TAU;
              }
              while (angle < startAngle) {
                angle += TAU;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle;
              var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
            var arc = {
              x: vm.x,
              y: vm.y,
              innerRadius: vm.innerRadius,
              outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
              pixelMargin,
              startAngle: vm.startAngle,
              endAngle: vm.endAngle,
              fullCircles: Math.floor(vm.circumference / TAU)
            };
            var i;
            ctx.save();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            if (arc.fullCircles) {
              arc.endAngle = arc.startAngle + TAU;
              ctx.beginPath();
              ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
              ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
              ctx.closePath();
              for (i = 0; i < arc.fullCircles; ++i) {
                ctx.fill();
              }
              arc.endAngle = arc.startAngle + vm.circumference % TAU;
            }
            ctx.beginPath();
            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth) {
              drawBorder(ctx, vm, arc);
            }
            ctx.restore();
          }
        });
        var valueOrDefault$1 = helpers$1.valueOrDefault;
        var defaultColor = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            line: {
              tension: 0.4,
              backgroundColor: defaultColor,
              borderWidth: 3,
              borderColor: defaultColor,
              borderCapStyle: "butt",
              borderDash: [],
              borderDashOffset: 0,
              borderJoinStyle: "miter",
              capBezierPoints: true,
              fill: true
              // do we fill in the area between the line and its base axis
            }
          }
        });
        var element_line = core_element.extend({
          _type: "line",
          draw: function() {
            var me = this;
            var vm = me._view;
            var ctx = me._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me._children.slice();
            var globalDefaults = core_defaults.global;
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var closePath = me._loop;
            var index2, previous, currentVM;
            if (!points.length) {
              return;
            }
            if (me._loop) {
              for (index2 = 0; index2 < points.length; ++index2) {
                previous = helpers$1.previousItem(points, index2);
                if (!points[index2]._view.skip && previous._view.skip) {
                  points = points.slice(index2).concat(points.slice(0, index2));
                  closePath = spanGaps;
                  break;
                }
              }
              if (closePath) {
                points.push(points[0]);
              }
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            currentVM = points[0]._view;
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = 0;
            }
            for (index2 = 1; index2 < points.length; ++index2) {
              currentVM = points[index2]._view;
              previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index2) : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index2 - 1 && !spanGaps || lastDrawnIndex === -1) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                }
                lastDrawnIndex = index2;
              }
            }
            if (closePath) {
              ctx.closePath();
            }
            ctx.stroke();
            ctx.restore();
          }
        });
        var valueOrDefault$2 = helpers$1.valueOrDefault;
        var defaultColor$1 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            point: {
              radius: 3,
              pointStyle: "circle",
              backgroundColor: defaultColor$1,
              borderColor: defaultColor$1,
              borderWidth: 1,
              // Hover
              hitRadius: 1,
              hoverRadius: 4,
              hoverBorderWidth: 1
            }
          }
        });
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
        }
        var element_point = core_element.extend({
          _type: "point",
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var rotation = vm.rotation;
            var radius = vm.radius;
            var x = vm.x;
            var y = vm.y;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            if (vm.skip) {
              return;
            }
            if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
              ctx.strokeStyle = vm.borderColor || defaultColor2;
              ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
              ctx.fillStyle = vm.backgroundColor || defaultColor2;
              helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
            }
          }
        });
        var defaultColor$2 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            rectangle: {
              backgroundColor: defaultColor$2,
              borderColor: defaultColor$2,
              borderSkipped: "bottom",
              borderWidth: 0
            }
          }
        });
        function isVertical(vm) {
          return vm && vm.width !== void 0;
        }
        function getBarBounds(vm) {
          var x1, x2, y1, y2, half;
          if (isVertical(vm)) {
            half = vm.width / 2;
            x1 = vm.x - half;
            x2 = vm.x + half;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            half = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - half;
            y2 = vm.y + half;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function parseBorderSkipped(vm) {
          var edge = vm.borderSkipped;
          var res = {};
          if (!edge) {
            return res;
          }
          if (vm.horizontal) {
            if (vm.base > vm.x) {
              edge = swap(edge, "left", "right");
            }
          } else if (vm.base < vm.y) {
            edge = swap(edge, "bottom", "top");
          }
          res[edge] = true;
          return res;
        }
        function parseBorderWidth(vm, maxW, maxH) {
          var value = vm.borderWidth;
          var skip2 = parseBorderSkipped(vm);
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = +value.top || 0;
            r = +value.right || 0;
            b = +value.bottom || 0;
            l = +value.left || 0;
          } else {
            t = r = b = l = +value || 0;
          }
          return {
            t: skip2.top || t < 0 ? 0 : t > maxH ? maxH : t,
            r: skip2.right || r < 0 ? 0 : r > maxW ? maxW : r,
            b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
            l: skip2.left || l < 0 ? 0 : l > maxW ? maxW : l
          };
        }
        function boundingRects(vm) {
          var bounds = getBarBounds(vm);
          var width = bounds.right - bounds.left;
          var height = bounds.bottom - bounds.top;
          var border = parseBorderWidth(vm, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b
            }
          };
        }
        function inRange(vm, x, y) {
          var skipX = x === null;
          var skipY = y === null;
          var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
          return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
        }
        var element_rectangle = core_element.extend({
          _type: "rectangle",
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var rects = boundingRects(vm);
            var outer = rects.outer;
            var inner = rects.inner;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
            if (outer.w === inner.w && outer.h === inner.h) {
              return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(outer.x, outer.y, outer.w, outer.h);
            ctx.clip();
            ctx.fillStyle = vm.borderColor;
            ctx.rect(inner.x, inner.y, inner.w, inner.h);
            ctx.fill("evenodd");
            ctx.restore();
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            return inRange(this._view, mouseX, mouseY);
          },
          inLabelRange: function(mouseX, mouseY) {
            var vm = this._view;
            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
          },
          inXRange: function(mouseX) {
            return inRange(this._view, mouseX, null);
          },
          inYRange: function(mouseY) {
            return inRange(this._view, null, mouseY);
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x, y;
            if (isVertical(vm)) {
              x = vm.x;
              y = (vm.y + vm.base) / 2;
            } else {
              x = (vm.x + vm.base) / 2;
              y = vm.y;
            }
            return { x, y };
          },
          getArea: function() {
            var vm = this._view;
            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
        var elements = {};
        var Arc = element_arc;
        var Line = element_line;
        var Point = element_point;
        var Rectangle = element_rectangle;
        elements.Arc = Arc;
        elements.Line = Line;
        elements.Point = Point;
        elements.Rectangle = Rectangle;
        var deprecated = helpers$1._deprecated;
        var valueOrDefault$3 = helpers$1.valueOrDefault;
        core_defaults._set("bar", {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        });
        core_defaults._set("global", {
          datasets: {
            bar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        function computeMinSampleSize(scale2, pixels) {
          var min2 = scale2._length;
          var prev, curr, i, ilen;
          for (i = 1, ilen = pixels.length; i < ilen; ++i) {
            min2 = Math.min(min2, Math.abs(pixels[i] - pixels[i - 1]));
          }
          for (i = 0, ilen = scale2.getTicks().length; i < ilen; ++i) {
            curr = scale2.getPixelForTick(i);
            min2 = i > 0 ? Math.min(min2, Math.abs(curr - prev)) : min2;
            prev = curr;
          }
          return min2;
        }
        function computeFitCategoryTraits(index2, ruler, options2) {
          var thickness = options2.barThickness;
          var count = ruler.stackCount;
          var curr = ruler.pixels[index2];
          var min2 = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
          var size, ratio;
          if (helpers$1.isNullOrUndef(thickness)) {
            size = min2 * options2.categoryPercentage;
            ratio = options2.barPercentage;
          } else {
            size = thickness * count;
            ratio = 1;
          }
          return {
            chunk: size / count,
            ratio,
            start: curr - size / 2
          };
        }
        function computeFlexCategoryTraits(index2, ruler, options2) {
          var pixels = ruler.pixels;
          var curr = pixels[index2];
          var prev = index2 > 0 ? pixels[index2 - 1] : null;
          var next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
          var percent = options2.categoryPercentage;
          var start, size;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / ruler.stackCount,
            ratio: options2.barPercentage,
            start
          };
        }
        var controller_bar = core_datasetController.extend({
          dataElementType: elements.Rectangle,
          /**
           * @private
           */
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderSkipped",
            "borderWidth",
            "barPercentage",
            "barThickness",
            "categoryPercentage",
            "maxBarThickness",
            "minBarLength"
          ],
          initialize: function() {
            var me = this;
            var meta, scaleOpts;
            core_datasetController.prototype.initialize.apply(me, arguments);
            meta = me.getMeta();
            meta.stack = me.getDataset().stack;
            meta.bar = true;
            scaleOpts = me._getIndexScale().options;
            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
            deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
          },
          update: function(reset) {
            var me = this;
            var rects = me.getMeta().data;
            var i, ilen;
            me._ruler = me.getRuler();
            for (i = 0, ilen = rects.length; i < ilen; ++i) {
              me.updateElement(rects[i], i, reset);
            }
          },
          updateElement: function(rectangle, index2, reset) {
            var me = this;
            var meta = me.getMeta();
            var dataset = me.getDataset();
            var options2 = me._resolveDataElementOptions(rectangle, index2);
            rectangle._xScale = me.getScaleForId(meta.xAxisID);
            rectangle._yScale = me.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me.index;
            rectangle._index = index2;
            rectangle._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderSkipped: options2.borderSkipped,
              borderWidth: options2.borderWidth,
              datasetLabel: dataset.label,
              label: me.chart.data.labels[index2]
            };
            if (helpers$1.isArray(dataset.data[index2])) {
              rectangle._model.borderSkipped = null;
            }
            me._updateElementGeometry(rectangle, index2, reset, options2);
            rectangle.pivot();
          },
          /**
           * @private
           */
          _updateElementGeometry: function(rectangle, index2, reset, options2) {
            var me = this;
            var model = rectangle._model;
            var vscale = me._getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me._ruler || me.getRuler();
            var vpixels = me.calculateBarValuePixels(me.index, index2, options2);
            var ipixels = me.calculateBarIndexPixels(me.index, index2, ruler, options2);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          /**
           * Returns the stacks based on groups and bar visibility.
           * @param {number} [last] - The dataset index
           * @returns {string[]} The list of stack IDs
           * @private
           */
          _getStacks: function(last) {
            var me = this;
            var scale2 = me._getIndexScale();
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var stacked = scale2.options.stacked;
            var ilen = metasets.length;
            var stacks = [];
            var i, meta;
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            return stacks;
          },
          /**
           * Returns the effective number of stacks based on groups and bar visibility.
           * @private
           */
          getStackCount: function() {
            return this._getStacks().length;
          },
          /**
           * Returns the stack index for the given dataset based on groups and bar visibility.
           * @param {number} [datasetIndex] - The dataset index
           * @param {string} [name] - The stack name to find
           * @returns {number} The stack index
           * @private
           */
          getStackIndex: function(datasetIndex, name2) {
            var stacks = this._getStacks(datasetIndex);
            var index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
            return index2 === -1 ? stacks.length - 1 : index2;
          },
          /**
           * @private
           */
          getRuler: function() {
            var me = this;
            var scale2 = me._getIndexScale();
            var pixels = [];
            var i, ilen;
            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
              pixels.push(scale2.getPixelForValue(null, i, me.index));
            }
            return {
              pixels,
              start: scale2._startPixel,
              end: scale2._endPixel,
              stackCount: me.getStackCount(),
              scale: scale2
            };
          },
          /**
           * Note: pixel values are not clamped to the scale area.
           * @private
           */
          calculateBarValuePixels: function(datasetIndex, index2, options2) {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var isHorizontal = scale2.isHorizontal();
            var datasets = chart.data.datasets;
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var value = scale2._parseValue(datasets[datasetIndex].data[index2]);
            var minBarLength = options2.minBarLength;
            var stacked = scale2.options.stacked;
            var stack = me.getMeta().stack;
            var start = value.start === void 0 ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
            var length = value.start === void 0 ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
            var ilen = metasets.length;
            var i, imeta, ivalue, base, head, size, stackLength;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i = 0; i < ilen; ++i) {
                imeta = metasets[i];
                if (imeta.index === datasetIndex) {
                  break;
                }
                if (imeta.stack === stack) {
                  stackLength = scale2._parseValue(datasets[imeta.index].data[index2]);
                  ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                  if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {
                    start += ivalue;
                  }
                }
              }
            }
            base = scale2.getPixelForValue(start);
            head = scale2.getPixelForValue(start + length);
            size = head - base;
            if (minBarLength !== void 0 && Math.abs(size) < minBarLength) {
              size = minBarLength;
              if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                head = base - minBarLength;
              } else {
                head = base + minBarLength;
              }
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          },
          /**
           * @private
           */
          calculateBarIndexPixels: function(datasetIndex, index2, ruler, options2) {
            var me = this;
            var range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2) : computeFitCategoryTraits(index2, ruler, options2);
            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
            var center = range.start + range.chunk * stackIndex + range.chunk / 2;
            var size = Math.min(
              valueOrDefault$3(options2.maxBarThickness, Infinity),
              range.chunk * range.ratio
            );
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var rects = me.getMeta().data;
            var dataset = me.getDataset();
            var ilen = rects.length;
            var i = 0;
            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i < ilen; ++i) {
              var val = scale2._parseValue(dataset.data[i]);
              if (!isNaN(val.min) && !isNaN(val.max)) {
                rects[i].draw();
              }
            }
            helpers$1.canvas.unclipArea(chart.ctx);
          },
          /**
           * @private
           */
          _resolveDataElementOptions: function() {
            var me = this;
            var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
            var indexOpts = me._getIndexScale().options;
            var valueOpts = me._getValueScale().options;
            values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
            values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
            values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
            values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
            values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
            return values;
          }
        });
        var valueOrDefault$4 = helpers$1.valueOrDefault;
        var resolve$1 = helpers$1.options.resolve;
        core_defaults._set("bubble", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              // bubble should probably use a linear scale by default
              position: "bottom",
              id: "x-axis-0"
              // need an ID so datasets can reference the scale
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                var datasetLabel = data.datasets[item.datasetIndex].label || "";
                var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        });
        var controller_bubble = core_datasetController.extend({
          /**
           * @protected
           */
          dataElementType: elements.Point,
          /**
           * @private
           */
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth",
            "hoverRadius",
            "hitRadius",
            "pointStyle",
            "rotation"
          ],
          /**
           * @protected
           */
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var points = meta.data;
            helpers$1.each(points, function(point, index2) {
              me.updateElement(point, index2, reset);
            });
          },
          /**
           * @protected
           */
          updateElement: function(point, index2, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var xScale = me.getScaleForId(meta.xAxisID);
            var yScale = me.getScaleForId(meta.yAxisID);
            var options2 = me._resolveDataElementOptions(point, index2);
            var data = me.getDataset().data[index2];
            var dsIndex = me.index;
            var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index2, dsIndex);
            var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index2, dsIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = dsIndex;
            point._index = index2;
            point._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              hitRadius: options2.hitRadius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              radius: reset ? 0 : options2.radius,
              skip: custom.skip || isNaN(x) || isNaN(y),
              x,
              y
            };
            point.pivot();
          },
          /**
           * @protected
           */
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = options2.radius + options2.hoverRadius;
          },
          /**
           * @private
           */
          _resolveDataElementOptions: function(point, index2) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var custom = point.custom || {};
            var data = dataset.data[index2] || {};
            var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
            var context = {
              chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me.index
            };
            if (me._cachedDataOpts === values) {
              values = helpers$1.extend({}, values);
            }
            values.radius = resolve$1([
              custom.radius,
              data.r,
              me._config.radius,
              chart.options.elements.point.radius
            ], context, index2);
            return values;
          }
        });
        var valueOrDefault$5 = helpers$1.valueOrDefault;
        var PI$1 = Math.PI;
        var DOUBLE_PI$1 = PI$1 * 2;
        var HALF_PI$1 = PI$1 / 2;
        core_defaults._set("doughnut", {
          animation: {
            // Boolean - Whether we animate the rotation of the Doughnut
            animateRotate: true,
            // Boolean - Whether we animate scaling the Doughnut from the centre
            animateScale: false
          },
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      // Extra data used for toggling the correct item
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                if (meta.data[index2]) {
                  meta.data[index2].hidden = !meta.data[index2].hidden;
                }
              }
              chart.update();
            }
          },
          // The percentage of the chart that we cut out of the middle.
          cutoutPercentage: 50,
          // The rotation of the chart, where the first data arc begins.
          rotation: -HALF_PI$1,
          // The total circumference of the chart.
          circumference: DOUBLE_PI$1,
          // Need to override these to give a nice default
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var dataLabel = data.labels[tooltipItem.index];
                var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers$1.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        });
        var controller_doughnut = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          /**
           * @private
           */
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var ratioX = 1;
            var ratioY = 1;
            var offsetX = 0;
            var offsetY = 0;
            var meta = me.getMeta();
            var arcs = meta.data;
            var cutout = opts.cutoutPercentage / 100 || 0;
            var circumference = opts.circumference;
            var chartWeight = me._getRingWeight(me.index);
            var maxWidth, maxHeight, i, ilen;
            if (circumference < DOUBLE_PI$1) {
              var startAngle = opts.rotation % DOUBLE_PI$1;
              startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
              var endAngle = startAngle + circumference;
              var startX = Math.cos(startAngle);
              var startY = Math.sin(startAngle);
              var endX = Math.cos(endAngle);
              var endY = Math.sin(endAngle);
              var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
              var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
              var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
              var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
              var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
              var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
              var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
              var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
              ratioX = (maxX - minX) / 2;
              ratioY = (maxY - minY) / 2;
              offsetX = -(maxX + minX) / 2;
              offsetY = -(maxY + minY) / 2;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
            }
            chart.borderWidth = me.getMaxBorderWidth();
            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
            chart.offsetX = offsetX * chart.outerRadius;
            chart.offsetY = offsetY * chart.outerRadius;
            meta.total = me.calculateTotal();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              me.updateElement(arcs[i], i, reset);
            }
          },
          updateElement: function(arc, index2, reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var animationOpts = opts.animation;
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var startAngle = opts.rotation;
            var endAngle = opts.rotation;
            var dataset = me.getDataset();
            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index2]) * (opts.circumference / DOUBLE_PI$1);
            var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
            var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              // Utility
              _datasetIndex: me.index,
              _index: index2,
              // Desired view properties
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: helpers$1.valueAtIndexOrDefault(dataset.label, index2, chart.data.labels[index2])
              }
            });
            var model = arc._model;
            if (!reset || !animationOpts.animateRotate) {
              if (index2 === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me.getMeta().data[index2 - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value;
            helpers$1.each(meta.data, function(element, index2) {
              value = dataset.data[index2];
              if (!isNaN(value) && !element.hidden) {
                total += Math.abs(value);
              }
            });
            return total;
          },
          calculateCircumference: function(value) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value)) {
              return DOUBLE_PI$1 * (Math.abs(value) / total);
            }
            return 0;
          },
          // gets the max border or hover width to properly scale pie charts
          getMaxBorderWidth: function(arcs) {
            var me = this;
            var max2 = 0;
            var chart = me.chart;
            var i, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  if (i !== me.index) {
                    controller = meta.controller;
                  }
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arc = arcs[i];
              if (controller) {
                controller._configure();
                options2 = controller._resolveDataElementOptions(arc, i);
              } else {
                options2 = arc._options;
              }
              if (options2.borderAlign !== "inner") {
                borderWidth = options2.borderWidth;
                hoverWidth = options2.hoverBorderWidth;
                max2 = borderWidth > max2 ? borderWidth : max2;
                max2 = hoverWidth > max2 ? hoverWidth : max2;
              }
            }
            return max2;
          },
          /**
           * @protected
           */
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
          },
          /**
           * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
           * @private
           */
          _getRingWeightOffset: function(datasetIndex) {
            var ringWeightOffset = 0;
            for (var i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          },
          /**
           * @private
           */
          _getRingWeight: function(dataSetIndex) {
            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
          },
          /**
           * Returns the sum of all visibile data set weights.  This value can be 0.
           * @private
           */
          _getVisibleDatasetWeightTotal: function() {
            return this._getRingWeightOffset(this.chart.data.datasets.length);
          }
        });
        core_defaults._set("horizontalBar", {
          hover: {
            mode: "index",
            axis: "y"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              type: "category",
              position: "left",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            mode: "index",
            axis: "y"
          }
        });
        core_defaults._set("global", {
          datasets: {
            horizontalBar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        var controller_horizontalBar = controller_bar.extend({
          /**
           * @private
           */
          _getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          /**
           * @private
           */
          _getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
        var valueOrDefault$6 = helpers$1.valueOrDefault;
        var resolve$2 = helpers$1.options.resolve;
        var isPointInArea = helpers$1.canvas._isPointInArea;
        core_defaults._set("line", {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        });
        function scaleClip(scale2, halfBorderWidth) {
          var tickOpts = scale2 && scale2.options.ticks || {};
          var reverse = tickOpts.reverse;
          var min2 = tickOpts.min === void 0 ? halfBorderWidth : 0;
          var max2 = tickOpts.max === void 0 ? halfBorderWidth : 0;
          return {
            start: reverse ? max2 : min2,
            end: reverse ? min2 : max2
          };
        }
        function defaultClip(xScale, yScale, borderWidth) {
          var halfBorderWidth = borderWidth / 2;
          var x = scaleClip(xScale, halfBorderWidth);
          var y = scaleClip(yScale, halfBorderWidth);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l
          };
        }
        var controller_line = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          /**
           * @private
           */
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth",
            "cubicInterpolationMode",
            "fill"
          ],
          /**
           * @private
           */
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options2 = me.chart.options;
            var config = me._config;
            var showLine = me._showLine = valueOrDefault$6(config.showLine, options2.showLines);
            var i, ilen;
            me._xScale = me.getScaleForId(meta.xAxisID);
            me._yScale = me.getScaleForId(meta.yAxisID);
            if (showLine) {
              if (config.tension !== void 0 && config.lineTension === void 0) {
                config.lineTension = config.tension;
              }
              line._scale = me._yScale;
              line._datasetIndex = me.index;
              line._children = points;
              line._model = me._resolveDatasetElementOptions(line);
              line.pivot();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me.updateBezierControlPoints();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var datasetIndex = me.index;
            var value = dataset.data[index2];
            var xScale = me._xScale;
            var yScale = me._yScale;
            var lineModel = meta.dataset._model;
            var x, y;
            var options2 = me._resolveDataElementOptions(point, index2);
            x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index2, datasetIndex);
            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index2, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = datasetIndex;
            point._index = index2;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              // Appearance
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
              steppedLine: lineModel ? lineModel.steppedLine : false,
              // Tooltip
              hitRadius: options2.hitRadius
            };
          },
          /**
           * @private
           */
          _resolveDatasetElementOptions: function(element) {
            var me = this;
            var config = me._config;
            var custom = element.custom || {};
            var options2 = me.chart.options;
            var lineOptions = options2.elements.line;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
            values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
            values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
            return values;
          },
          calculatePointY: function(value, index2, datasetIndex) {
            var me = this;
            var chart = me.chart;
            var yScale = me._yScale;
            var sumPos = 0;
            var sumNeg = 0;
            var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
            if (yScale.options.stacked) {
              rightValue = +yScale.getRightValue(value);
              metasets = chart._getSortedVisibleDatasetMetas();
              ilen = metasets.length;
              for (i = 0; i < ilen; ++i) {
                dsMeta = metasets[i];
                if (dsMeta.index === datasetIndex) {
                  break;
                }
                ds = chart.data.datasets[dsMeta.index];
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                  stackedRightValue = +yScale.getRightValue(ds.data[index2]);
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value);
          },
          updateBezierControlPoints: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var lineModel = meta.dataset._model;
            var area = chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (lineModel.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            if (lineModel.cubicInterpolationMode === "monotone") {
              helpers$1.splineCurveMonotone(points);
            } else {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                controlPoints = helpers$1.splineCurve(
                  helpers$1.previousItem(points, i)._model,
                  model,
                  helpers$1.nextItem(points, i)._model,
                  lineModel.tension
                );
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (chart.options.elements.line.capBezierPoints) {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                if (isPointInArea(model, area)) {
                  if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                  }
                  if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                  }
                }
              }
            }
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var points = meta.data || [];
            var area = chart.chartArea;
            var canvas2 = chart.canvas;
            var i = 0;
            var ilen = points.length;
            var clip;
            if (me._showLine) {
              clip = meta.dataset._model.clip;
              helpers$1.canvas.clipArea(chart.ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? canvas2.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? canvas2.height : area.bottom + clip.bottom
              });
              meta.dataset.draw();
              helpers$1.canvas.unclipArea(chart.ctx);
            }
            for (; i < ilen; ++i) {
              points[i].draw(area);
            }
          },
          /**
           * @protected
           */
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
          }
        });
        var resolve$3 = helpers$1.options.resolve;
        core_defaults._set("polarArea", {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          // Boolean - Whether to animate the rotation of the chart
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      // Extra data used for toggling the correct item
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                meta.data[index2].hidden = !meta.data[index2].hidden;
              }
              chart.update();
            }
          },
          // Need to override these to give a nice default
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                return data.labels[item.index] + ": " + item.yLabel;
              }
            }
          }
        });
        var controller_polarArea = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          /**
           * @private
           */
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          /**
           * @private
           */
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          /**
           * @private
           */
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            var start = me.chart.options.startAngle || 0;
            var starts = me._starts = [];
            var angles = me._angles = [];
            var arcs = meta.data;
            var i, ilen, angle;
            me._updateRadius();
            meta.count = me.countVisibleElements();
            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
              starts[i] = start;
              angle = me._computeAngle(i);
              angles[i] = angle;
              start += angle;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
              me.updateElement(arcs[i], i, reset);
            }
          },
          /**
           * @private
           */
          _updateRadius: function() {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max(minSize / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
            me.innerRadius = me.outerRadius - chart.radiusLength;
          },
          updateElement: function(arc, index2, reset) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale2 = chart.scale;
            var labels = chart.data.labels;
            var centerX = scale2.xCenter;
            var centerY = scale2.yCenter;
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var startAngle = me._starts[index2];
            var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index2]);
            var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              // Utility
              _datasetIndex: me.index,
              _index: index2,
              _scale: scale2,
              // Desired view properties
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: helpers$1.valueAtIndexOrDefault(labels, index2, labels[index2])
              }
            });
            arc.pivot();
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers$1.each(meta.data, function(element, index2) {
              if (!isNaN(dataset.data[index2]) && !element.hidden) {
                count++;
              }
            });
            return count;
          },
          /**
           * @protected
           */
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            var valueOrDefault2 = helpers$1.valueOrDefault;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
          },
          /**
           * @private
           */
          _computeAngle: function(index2) {
            var me = this;
            var count = this.getMeta().count;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            if (isNaN(dataset.data[index2]) || meta.data[index2].hidden) {
              return 0;
            }
            var context = {
              chart: me.chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me.index
            };
            return resolve$3([
              me.chart.options.elements.arc.angle,
              2 * Math.PI / count
            ], context, index2);
          }
        });
        core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
        core_defaults._set("pie", {
          cutoutPercentage: 0
        });
        var controller_pie = controller_doughnut;
        var valueOrDefault$7 = helpers$1.valueOrDefault;
        core_defaults._set("radar", {
          spanGaps: false,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              fill: "start",
              tension: 0
              // no bezier in radar
            }
          }
        });
        var controller_radar = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          linkScales: helpers$1.noop,
          /**
           * @private
           */
          _datasetElementOptions: [
            "backgroundColor",
            "borderWidth",
            "borderColor",
            "borderCapStyle",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "fill"
          ],
          /**
           * @private
           */
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          /**
           * @private
           */
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          /**
           * @private
           */
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var scale2 = me.chart.scale;
            var config = me._config;
            var i, ilen;
            if (config.tension !== void 0 && config.lineTension === void 0) {
              config.lineTension = config.tension;
            }
            line._scale = scale2;
            line._datasetIndex = me.index;
            line._children = points;
            line._loop = true;
            line._model = me._resolveDatasetElementOptions(line);
            line.pivot();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            me.updateBezierControlPoints();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me = this;
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var scale2 = me.chart.scale;
            var pointPosition = scale2.getPointPositionForValue(index2, dataset.data[index2]);
            var options2 = me._resolveDataElementOptions(point, index2);
            var lineModel = me.getMeta().dataset._model;
            var x = reset ? scale2.xCenter : pointPosition.x;
            var y = reset ? scale2.yCenter : pointPosition.y;
            point._scale = scale2;
            point._options = options2;
            point._datasetIndex = me.index;
            point._index = index2;
            point._model = {
              x,
              // value not used in dataset scale, but we want a consistent API between scales
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              // Appearance
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
              // Tooltip
              hitRadius: options2.hitRadius
            };
          },
          /**
           * @private
           */
          _resolveDatasetElementOptions: function() {
            var me = this;
            var config = me._config;
            var options2 = me.chart.options;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
            return values;
          },
          updateBezierControlPoints: function() {
            var me = this;
            var meta = me.getMeta();
            var area = me.chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              controlPoints = helpers$1.splineCurve(
                helpers$1.previousItem(points, i, true)._model,
                model,
                helpers$1.nextItem(points, i, true)._model,
                model.tension
              );
              model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
              model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
              model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
          }
        });
        core_defaults._set("scatter", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              id: "x-axis-1",
              // need an ID so datasets can reference the scale
              type: "linear",
              // scatter should not use a category axis
              position: "bottom"
            }],
            yAxes: [{
              id: "y-axis-1",
              type: "linear",
              position: "left"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item) {
                return "(" + item.xLabel + ", " + item.yLabel + ")";
              }
            }
          }
        });
        core_defaults._set("global", {
          datasets: {
            scatter: {
              showLine: false
            }
          }
        });
        var controller_scatter = controller_line;
        var controllers = {
          bar: controller_bar,
          bubble: controller_bubble,
          doughnut: controller_doughnut,
          horizontalBar: controller_horizontalBar,
          line: controller_line,
          polarArea: controller_polarArea,
          pie: controller_pie,
          radar: controller_radar,
          scatter: controller_scatter
        };
        function getRelativePosition(e, chart) {
          if (e.native) {
            return {
              x: e.x,
              y: e.y
            };
          }
          return helpers$1.getRelativePosition(e, chart);
        }
        function parseVisibleItems(chart, handler) {
          var metasets = chart._getSortedVisibleDatasetMetas();
          var metadata, i, j, ilen, jlen, element;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            metadata = metasets[i].data;
            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
              element = metadata[j];
              if (!element._view.skip) {
                handler(element);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements2 = [];
          parseVisibleItems(chart, function(element) {
            if (element.inRange(position.x, position.y)) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          parseVisibleItems(chart, function(element) {
            if (intersect && !element.inRange(position.x, position.y)) {
              return;
            }
            var center = element.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element);
            }
          });
          return nearestItems;
        }
        function getDistanceMetricForAxis(axis) {
          var useX = axis.indexOf("x") !== -1;
          var useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function indexMode(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "x";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements2 = [];
          if (!items.length) {
            return [];
          }
          chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
            var element = meta.data[items[0]._index];
            if (element && !element._view.skip) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        var core_interaction = {
          // Helper function for different modes
          modes: {
            single: function(chart, e) {
              var position = getRelativePosition(e, chart);
              var elements2 = [];
              parseVisibleItems(chart, function(element) {
                if (element.inRange(position.x, position.y)) {
                  elements2.push(element);
                  return elements2;
                }
              });
              return elements2.slice(0, 1);
            },
            /**
             * @function Chart.Interaction.modes.label
             * @deprecated since version 2.4.0
             * @todo remove at version 3
             * @private
             */
            label: indexMode,
            /**
             * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
             * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
             * @function Chart.Interaction.modes.index
             * @since v2.4.0
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @param {IInteractionOptions} options - options to use during interaction
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            index: indexMode,
            /**
             * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
             * If the options.intersect is false, we find the nearest item and return the items in that dataset
             * @function Chart.Interaction.modes.dataset
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @param {IInteractionOptions} options - options to use during interaction
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            dataset: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
              if (items.length > 0) {
                items = chart.getDatasetMeta(items[0]._datasetIndex).data;
              }
              return items;
            },
            /**
             * @function Chart.Interaction.modes.x-axis
             * @deprecated since version 2.4.0. Use index mode and intersect == true
             * @todo remove at version 3
             * @private
             */
            "x-axis": function(chart, e) {
              return indexMode(chart, e, { intersect: false });
            },
            /**
             * Point mode returns all elements that hit test based on the event position
             * of the event
             * @function Chart.Interaction.modes.intersect
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            point: function(chart, e) {
              var position = getRelativePosition(e, chart);
              return getIntersectItems(chart, position);
            },
            /**
             * nearest mode returns the element closest to the point
             * @function Chart.Interaction.modes.intersect
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @param {IInteractionOptions} options - options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            nearest: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              return getNearestItems(chart, position, options2.intersect, distanceMetric);
            },
            /**
             * x mode returns the elements that hit-test at the current x coordinate
             * @function Chart.Interaction.modes.x
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @param {IInteractionOptions} options - options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            x: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inXRange(position.x)) {
                  items.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            },
            /**
             * y mode returns the elements that hit-test at the current y coordinate
             * @function Chart.Interaction.modes.y
             * @param {Chart} chart - the chart we are returning items from
             * @param {Event} e - the event we are find things at
             * @param {IInteractionOptions} options - options to use
             * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
             */
            y: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inYRange(position.y)) {
                  items.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            }
          }
        };
        var extend2 = helpers$1.extend;
        function filterByPosition(array, position) {
          return helpers$1.where(array, function(v) {
            return v.pos === position;
          });
        }
        function sortByWeight(array, reverse) {
          return array.sort(function(a, b) {
            var v0 = reverse ? b : a;
            var v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          var layoutBoxes = [];
          var i, ilen, box;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            layoutBoxes.push({
              index: i,
              box,
              pos: box.position,
              horizontal: box.isHorizontal(),
              weight: box.weight
            });
          }
          return layoutBoxes;
        }
        function setLayoutDims(layouts, params) {
          var i, ilen, layout;
          for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
            layout.height = layout.horizontal && params.hBoxMaxHeight;
          }
        }
        function buildLayoutBoxes(boxes) {
          var layoutBoxes = wrapBoxes(boxes);
          var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          return {
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(bottom),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right),
            horizontal: top.concat(bottom)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateDims(chartArea, params, layout) {
          var box = layout.box;
          var maxPadding = chartArea.maxPadding;
          var newWidth, newHeight;
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
          }
          newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
          newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
          if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
          }
        }
        function handleMaxPadding(chartArea) {
          var maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          var maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions.forEach(function(pos) {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params) {
          var refitBoxes = [];
          var i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(
              layout.width || chartArea.w,
              layout.height || chartArea.h,
              getMargins(layout.horizontal, chartArea)
            );
            if (updateDims(chartArea, params, layout)) {
              changed = true;
              if (refitBoxes.length) {
                refit = true;
              }
            }
            if (!box.fullWidth) {
              refitBoxes.push(layout);
            }
          }
          return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
        }
        function placeBoxes(boxes, chartArea, params) {
          var userPadding = params.padding;
          var x = chartArea.x;
          var y = chartArea.y;
          var i, ilen, layout, box;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            if (layout.horizontal) {
              box.left = box.fullWidth ? userPadding.left : chartArea.left;
              box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
              box.top = y;
              box.bottom = y + box.height;
              box.width = box.right - box.left;
              y = box.bottom;
            } else {
              box.left = x;
              box.right = x + box.width;
              box.top = chartArea.top;
              box.bottom = chartArea.top + chartArea.h;
              box.height = box.bottom - box.top;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        core_defaults._set("global", {
          layout: {
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        });
        var core_layouts = {
          defaults: {},
          /**
           * Register a box to a chart.
           * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
           * @param {Chart} chart - the chart to use
           * @param {ILayoutItem} item - the item to add to be layed out
           */
          addBox: function(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullWidth = item.fullWidth || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw: function() {
                  item.draw.apply(item, arguments);
                }
              }];
            };
            chart.boxes.push(item);
          },
          /**
           * Remove a layoutItem from a chart
           * @param {Chart} chart - the chart to remove the box from
           * @param {ILayoutItem} layoutItem - the item to remove from the layout
           */
          removeBox: function(chart, layoutItem) {
            var index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index2 !== -1) {
              chart.boxes.splice(index2, 1);
            }
          },
          /**
           * Sets (or updates) options on the given `item`.
           * @param {Chart} chart - the chart in which the item lives (or will be added to)
           * @param {ILayoutItem} item - the item to configure with the given options
           * @param {object} options - the new item options.
           */
          configure: function(chart, item, options2) {
            var props = ["fullWidth", "position", "weight"];
            var ilen = props.length;
            var i = 0;
            var prop;
            for (; i < ilen; ++i) {
              prop = props[i];
              if (options2.hasOwnProperty(prop)) {
                item[prop] = options2[prop];
              }
            }
          },
          /**
           * Fits boxes of the given chart into the given size by having each box measure itself
           * then running a fitting algorithm
           * @param {Chart} chart - the chart
           * @param {number} width - the width to fit into
           * @param {number} height - the height to fit into
           */
          update: function(chart, width, height) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout || {};
            var padding = helpers$1.options.toPadding(layoutOptions.padding);
            var availableWidth = width - padding.width;
            var availableHeight = height - padding.height;
            var boxes = buildLayoutBoxes(chart.boxes);
            var verticalBoxes = boxes.vertical;
            var horizontalBoxes = boxes.horizontal;
            var params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
              hBoxMaxHeight: availableHeight / 2
            });
            var chartArea = extend2({
              maxPadding: extend2({}, padding),
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(verticalBoxes, chartArea, params);
            if (fitBoxes(horizontalBoxes, chartArea, params)) {
              fitBoxes(verticalBoxes, chartArea, params);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h
            };
            helpers$1.each(boxes.chartArea, function(layout) {
              var box = layout.box;
              extend2(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h);
            });
          }
        };
        var platform_basic = {
          acquireContext: function(item) {
            if (item && item.canvas) {
              item = item.canvas;
            }
            return item && item.getContext("2d") || null;
          }
        };
        var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
        var platform_dom$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": platform_dom
        });
        var stylesheet = getCjsExportFromNamespace(platform_dom$1);
        var EXPANDO_KEY = "$chartjs";
        var CSS_PREFIX = "chartjs-";
        var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
        var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
        var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
        var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
        var EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element, property) {
          var value = helpers$1.getStyle(element, property);
          var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas2, config) {
          var style = canvas2.style;
          var renderHeight = canvas2.getAttribute("height");
          var renderWidth = canvas2.getAttribute("width");
          canvas2[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas2, "width");
            if (displayWidth !== void 0) {
              canvas2.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas2.style.height === "") {
              canvas2.height = canvas2.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas2, "height");
              if (displayWidth !== void 0) {
                canvas2.height = displayHeight;
              }
            }
          }
          return canvas2;
        }
        var supportsEventListenerOptions = function() {
          var supports = false;
          try {
            var options2 = Object.defineProperty({}, "passive", {
              // eslint-disable-next-line getter-return
              get: function() {
                supports = true;
              }
            });
            window.addEventListener("e", null, options2);
          } catch (e) {
          }
          return supports;
        }();
        var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(node, type, listener) {
          node.removeEventListener(type, listener, eventListenerOptions);
        }
        function createEvent(type, chart, x, y, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = EVENT_TYPES[event.type] || event.type;
          var pos = helpers$1.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function throttled(fn, thisArg) {
          var ticking = false;
          var args = [];
          return function() {
            args = Array.prototype.slice.call(arguments);
            thisArg = thisArg || this;
            if (!ticking) {
              ticking = true;
              helpers$1.requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function createDiv(cls) {
          var el = document.createElement("div");
          el.className = cls || "";
          return el;
        }
        function createResizer(handler) {
          var maxSize = 1e6;
          var resizer = createDiv(CSS_SIZE_MONITOR);
          var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
          var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
          expand.appendChild(createDiv());
          shrink.appendChild(createDiv());
          resizer.appendChild(expand);
          resizer.appendChild(shrink);
          resizer._reset = function() {
            expand.scrollLeft = maxSize;
            expand.scrollTop = maxSize;
            shrink.scrollLeft = maxSize;
            shrink.scrollTop = maxSize;
          };
          var onScroll = function() {
            resizer._reset();
            handler();
          };
          addListener(expand, "scroll", onScroll.bind(expand, "expand"));
          addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
          return resizer;
        }
        function watchForRender(node, handler) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var proxy = expando.renderProxy = function(e) {
            if (e.animationName === CSS_RENDER_ANIMATION) {
              handler();
            }
          };
          helpers$1.each(ANIMATION_START_EVENTS, function(type) {
            addListener(node, type, proxy);
          });
          expando.reflow = !!node.offsetParent;
          node.classList.add(CSS_RENDER_MONITOR);
        }
        function unwatchForRender(node) {
          var expando = node[EXPANDO_KEY] || {};
          var proxy = expando.renderProxy;
          if (proxy) {
            helpers$1.each(ANIMATION_START_EVENTS, function(type) {
              removeListener(node, type, proxy);
            });
            delete expando.renderProxy;
          }
          node.classList.remove(CSS_RENDER_MONITOR);
        }
        function addResizeListener(node, listener, chart) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var resizer = expando.resizer = createResizer(throttled(function() {
            if (expando.resizer) {
              var container = chart.options.maintainAspectRatio && node.parentNode;
              var w = container ? container.clientWidth : 0;
              listener(createEvent("resize", chart));
              if (container && container.clientWidth < w && chart.canvas) {
                listener(createEvent("resize", chart));
              }
            }
          }));
          watchForRender(node, function() {
            if (expando.resizer) {
              var container = node.parentNode;
              if (container && container !== resizer.parentNode) {
                container.insertBefore(resizer, container.firstChild);
              }
              resizer._reset();
            }
          });
        }
        function removeResizeListener(node) {
          var expando = node[EXPANDO_KEY] || {};
          var resizer = expando.resizer;
          delete expando.resizer;
          unwatchForRender(node);
          if (resizer && resizer.parentNode) {
            resizer.parentNode.removeChild(resizer);
          }
        }
        function injectCSS(rootNode, css) {
          var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
          if (!expando.containsStyles) {
            expando.containsStyles = true;
            css = "/* Chart.js */\n" + css;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.appendChild(document.createTextNode(css));
            rootNode.appendChild(style);
          }
        }
        var platform_dom$2 = {
          /**
           * When `true`, prevents the automatic injection of the stylesheet required to
           * correctly detect when the chart is added to the DOM and then resized. This
           * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
           * to be manually imported to make this library compatible with any CSP.
           * See https://github.com/chartjs/Chart.js/issues/5208
           */
          disableCSSInjection: false,
          /**
           * This property holds whether this platform is enabled for the current environment.
           * Currently used by platform.js to select the proper implementation.
           * @private
           */
          _enabled: typeof window !== "undefined" && typeof document !== "undefined",
          /**
           * Initializes resources that depend on platform options.
           * @param {HTMLCanvasElement} canvas - The Canvas element.
           * @private
           */
          _ensureLoaded: function(canvas2) {
            if (!this.disableCSSInjection) {
              var root = canvas2.getRootNode ? canvas2.getRootNode() : document;
              var targetNode = root.host ? root : document.head;
              injectCSS(targetNode, stylesheet);
            }
          },
          acquireContext: function(item, config) {
            if (typeof item === "string") {
              item = document.getElementById(item);
            } else if (item.length) {
              item = item[0];
            }
            if (item && item.canvas) {
              item = item.canvas;
            }
            var context = item && item.getContext && item.getContext("2d");
            if (context && context.canvas === item) {
              this._ensureLoaded(item);
              initCanvas(item, config);
              return context;
            }
            return null;
          },
          releaseContext: function(context) {
            var canvas2 = context.canvas;
            if (!canvas2[EXPANDO_KEY]) {
              return;
            }
            var initial = canvas2[EXPANDO_KEY].initial;
            ["height", "width"].forEach(function(prop) {
              var value = initial[prop];
              if (helpers$1.isNullOrUndef(value)) {
                canvas2.removeAttribute(prop);
              } else {
                canvas2.setAttribute(prop, value);
              }
            });
            helpers$1.each(initial.style || {}, function(value, key) {
              canvas2.style[key] = value;
            });
            canvas2.width = canvas2.width;
            delete canvas2[EXPANDO_KEY];
          },
          addEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas2, listener, chart);
              return;
            }
            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
            var proxies = expando.proxies || (expando.proxies = {});
            var proxy = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            addListener(canvas2, type, proxy);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas2);
              return;
            }
            var expando = listener[EXPANDO_KEY] || {};
            var proxies = expando.proxies || {};
            var proxy = proxies[chart.id + "_" + type];
            if (!proxy) {
              return;
            }
            removeListener(canvas2, type, proxy);
          }
        };
        helpers$1.addEvent = addListener;
        helpers$1.removeEvent = removeListener;
        var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
        var platform = helpers$1.extend({
          /**
           * @since 2.7.0
           */
          initialize: function() {
          },
          /**
           * Called at chart construction time, returns a context2d instance implementing
           * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
           * @param {*} item - The native item from which to acquire context (platform specific)
           * @param {object} options - The chart options
           * @returns {CanvasRenderingContext2D} context2d instance
           */
          acquireContext: function() {
          },
          /**
           * Called at chart destruction time, releases any resources associated to the context
           * previously returned by the acquireContext() method.
           * @param {CanvasRenderingContext2D} context - The context2d instance
           * @returns {boolean} true if the method succeeded, else false
           */
          releaseContext: function() {
          },
          /**
           * Registers the specified listener on the given chart.
           * @param {Chart} chart - Chart from which to listen for event
           * @param {string} type - The ({@link IEvent}) type to listen for
           * @param {function} listener - Receives a notification (an object that implements
           * the {@link IEvent} interface) when an event of the specified type occurs.
           */
          addEventListener: function() {
          },
          /**
           * Removes the specified listener previously registered with addEventListener.
           * @param {Chart} chart - Chart from which to remove the listener
           * @param {string} type - The ({@link IEvent}) type to remove
           * @param {function} listener - The listener function to remove from the event target.
           */
          removeEventListener: function() {
          }
        }, implementation);
        core_defaults._set("global", {
          plugins: {}
        });
        var core_plugins = {
          /**
           * Globally registered plugins.
           * @private
           */
          _plugins: [],
          /**
           * This identifier is used to invalidate the descriptors cache attached to each chart
           * when a global plugin is registered or unregistered. In this case, the cache ID is
           * incremented and descriptors are regenerated during following API calls.
           * @private
           */
          _cacheId: 0,
          /**
           * Registers the given plugin(s) if not already registered.
           * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
           */
          register: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              if (p.indexOf(plugin) === -1) {
                p.push(plugin);
              }
            });
            this._cacheId++;
          },
          /**
           * Unregisters the given plugin(s) only if registered.
           * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
           */
          unregister: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              var idx = p.indexOf(plugin);
              if (idx !== -1) {
                p.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          /**
           * Remove all registered plugins.
           * @since 2.1.5
           */
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          /**
           * Returns the number of registered plugins?
           * @returns {number}
           * @since 2.1.5
           */
          count: function() {
            return this._plugins.length;
          },
          /**
           * Returns all registered plugin instances.
           * @returns {IPlugin[]} array of plugin objects.
           * @since 2.1.5
           */
          getAll: function() {
            return this._plugins;
          },
          /**
           * Calls enabled plugins for `chart` on the specified hook and with the given args.
           * This method immediately returns as soon as a plugin explicitly returns false. The
           * returned value can be used, for instance, to interrupt the current action.
           * @param {Chart} chart - The chart instance for which plugins should be called.
           * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
           * @param {Array} [args] - Extra arguments to apply to the hook call.
           * @returns {boolean} false if any of the plugins return false, else returns true.
           */
          notify: function(chart, hook, args) {
            var descriptors = this.descriptors(chart);
            var ilen = descriptors.length;
            var i, descriptor, plugin, params, method;
            for (i = 0; i < ilen; ++i) {
              descriptor = descriptors[i];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params = [chart].concat(args || []);
                params.push(descriptor.options);
                if (method.apply(plugin, params) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          /**
           * Returns descriptors of enabled plugins for the given chart.
           * @returns {object[]} [{ plugin, options }]
           * @private
           */
          descriptors: function(chart) {
            var cache = chart.$plugins || (chart.$plugins = {});
            if (cache.id === this._cacheId) {
              return cache.descriptors;
            }
            var plugins2 = [];
            var descriptors = [];
            var config = chart && chart.config || {};
            var options2 = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins2.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id = plugin.id;
              var opts = options2[id];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers$1.clone(core_defaults.global.plugins[id]);
              }
              plugins2.push(plugin);
              descriptors.push({
                plugin,
                options: opts || {}
              });
            });
            cache.descriptors = descriptors;
            cache.id = this._cacheId;
            return descriptors;
          },
          /**
           * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
           * but in some cases, this reference can be changed by the user when updating options.
           * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
           * @private
           */
          _invalidate: function(chart) {
            delete chart.$plugins;
          }
        };
        var core_scaleService = {
          // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
          // use the new chart options to grab the correct scale
          constructors: {},
          // Use a registration function so that we can move to an ES6 map when we no longer need to support
          // old browsers
          // Scale config defaults
          defaults: {},
          registerScaleType: function(type, scaleConstructor, scaleDefaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers$1.clone(scaleDefaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(/* @__PURE__ */ Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var me = this;
            if (me.defaults.hasOwnProperty(type)) {
              me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers$1.each(chart.scales, function(scale2) {
              scale2.fullWidth = scale2.options.fullWidth;
              scale2.position = scale2.options.position;
              scale2.weight = scale2.options.weight;
              core_layouts.addBox(chart, scale2);
            });
          }
        };
        var valueOrDefault$8 = helpers$1.valueOrDefault;
        var getRtlHelper = helpers$1.rtl.getRtlAdapter;
        core_defaults._set("global", {
          tooltips: {
            enabled: true,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: true,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: true,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
              // Args are: (tooltipItems, data)
              beforeTitle: helpers$1.noop,
              title: function(tooltipItems, data) {
                var title2 = "";
                var labels = data.labels;
                var labelCount = labels ? labels.length : 0;
                if (tooltipItems.length > 0) {
                  var item = tooltipItems[0];
                  if (item.label) {
                    title2 = item.label;
                  } else if (item.xLabel) {
                    title2 = item.xLabel;
                  } else if (labelCount > 0 && item.index < labelCount) {
                    title2 = labels[item.index];
                  }
                }
                return title2;
              },
              afterTitle: helpers$1.noop,
              // Args are: (tooltipItems, data)
              beforeBody: helpers$1.noop,
              // Args are: (tooltipItem, data)
              beforeLabel: helpers$1.noop,
              label: function(tooltipItem, data) {
                var label = data.datasets[tooltipItem.datasetIndex].label || "";
                if (label) {
                  label += ": ";
                }
                if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                  label += tooltipItem.value;
                } else {
                  label += tooltipItem.yLabel;
                }
                return label;
              },
              labelColor: function(tooltipItem, chart) {
                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                var activeElement = meta.data[tooltipItem.index];
                var view = activeElement._view;
                return {
                  borderColor: view.borderColor,
                  backgroundColor: view.backgroundColor
                };
              },
              labelTextColor: function() {
                return this._options.bodyFontColor;
              },
              afterLabel: helpers$1.noop,
              // Args are: (tooltipItems, data)
              afterBody: helpers$1.noop,
              // Args are: (tooltipItems, data)
              beforeFooter: helpers$1.noop,
              footer: helpers$1.noop,
              afterFooter: helpers$1.noop
            }
          }
        });
        var positioners = {
          /**
           * Average mode places the tooltip at the average position of the elements shown
           * @function Chart.Tooltip.positioners.average
           * @param elements {ChartElement[]} the elements being displayed in the tooltip
           * @returns {object} tooltip position
           */
          average: function(elements2) {
            if (!elements2.length) {
              return false;
            }
            var i, len;
            var x = 0;
            var y = 0;
            var count = 0;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          /**
           * Gets the tooltip position nearest of the item nearest to the event position
           * @function Chart.Tooltip.positioners.nearest
           * @param elements {Chart.Element[]} the tooltip elements
           * @param eventPosition {object} the position of the event in canvas coordinates
           * @returns {object} the tooltip position
           */
          nearest: function(elements2, eventPosition) {
            var x = eventPosition.x;
            var y = eventPosition.y;
            var minDistance = Number.POSITIVE_INFINITY;
            var i, len, nearestElement;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers$1.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(element) {
          var xScale = element._xScale;
          var yScale = element._yScale || element._scale;
          var index2 = element._index;
          var datasetIndex = element._datasetIndex;
          var controller = element._chart.getDatasetMeta(datasetIndex).controller;
          var indexScale = controller._getIndexScale();
          var valueScale = controller._getValueScale();
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index2, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index2, datasetIndex) : "",
            label: indexScale ? "" + indexScale.getLabelForIndex(index2, datasetIndex) : "",
            value: valueScale ? "" + valueScale.getLabelForIndex(index2, datasetIndex) : "",
            index: index2,
            datasetIndex,
            x: element._model.x,
            y: element._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = core_defaults.global;
          return {
            // Positioning
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            // Drawing direction and text direction
            rtl: tooltipOpts.rtl,
            textDirection: tooltipOpts.textDirection,
            // Body
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            // Title
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            // Footer
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            // Appearance
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height = model.yPadding * 2;
          var width = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize;
          var bodyFontSize = model.bodyFontSize;
          var footerFontSize = model.footerFontSize;
          height += titleLineCount * titleFontSize;
          height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height += titleLineCount ? model.titleMarginBottom : 0;
          height += combinedBodyLength * bodyFontSize;
          height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height += footerLineCount ? model.footerMarginTop : 0;
          height += footerLineCount * footerFontSize;
          height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers$1.each(model.title, maxLineWidth);
          ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers$1.each(body, function(bodyItem) {
            helpers$1.each(bodyItem.before, maxLineWidth);
            helpers$1.each(bodyItem.lines, maxLineWidth);
            helpers$1.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers$1.each(model.footer, maxLineWidth);
          width += 2 * model.xPadding;
          return {
            width,
            height
          };
        }
        function determineAlignment(tooltip, size) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size.height) {
            yAlign = "bottom";
          }
          var lf, rf;
          var olf, orf;
          var yf;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf = function(x) {
              return x <= midX;
            };
            rf = function(x) {
              return x > midX;
            };
          } else {
            lf = function(x) {
              return x <= size.width / 2;
            };
            rf = function(x) {
              return x >= chart.width - size.width / 2;
            };
          }
          olf = function(x) {
            return x + size.width + model.caretSize + model.caretPadding > chart.width;
          };
          orf = function(x) {
            return x - size.width - model.caretSize - model.caretPadding < 0;
          };
          yf = function(y) {
            return y <= midY ? "top" : "bottom";
          };
          if (lf(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          } else if (rf(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size, alignment, chart) {
          var x = vm.x;
          var y = vm.y;
          var caretSize = vm.caretSize;
          var caretPadding = vm.caretPadding;
          var cornerRadius = vm.cornerRadius;
          var xAlign = alignment.xAlign;
          var yAlign = alignment.yAlign;
          var paddingAndSize = caretSize + caretPadding;
          var radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x -= size.width;
          } else if (xAlign === "center") {
            x -= size.width / 2;
            if (x + size.width > chart.width) {
              x = chart.width - size.width;
            }
            if (x < 0) {
              x = 0;
            }
          }
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= size.height + paddingAndSize;
          } else {
            y -= size.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= radiusAndPadding;
          } else if (xAlign === "right") {
            x += radiusAndPadding;
          }
          return {
            x,
            y
          };
        }
        function getAlignedX(vm, align) {
          return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        var exports$4 = core_element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
            this._lastActive = [];
          },
          // Get the title
          // Args are: (tooltipItem, data)
          getTitle: function() {
            var me = this;
            var opts = me._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
            var title2 = callbacks.title.apply(me, arguments);
            var afterTitle = callbacks.afterTitle.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title2));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          },
          // Args are: (tooltipItem, data)
          getBeforeBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
          },
          // Args are: (tooltipItem, data)
          getBody: function(tooltipItems, data) {
            var me = this;
            var callbacks = me._options.callbacks;
            var bodyItems = [];
            helpers$1.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
              pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          // Args are: (tooltipItem, data)
          getAfterBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
          },
          // Get the footer and beforeFooter and afterFooter lines
          // Args are: (tooltipItem, data)
          getFooter: function() {
            var me = this;
            var callbacks = me._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
            var footer = callbacks.footer.apply(me, arguments);
            var afterFooter = callbacks.afterFooter.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          },
          update: function(changed) {
            var me = this;
            var opts = me._options;
            var existingModel = me._model;
            var model = me._model = getBaseModel(opts);
            var active = me._active;
            var data = me._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              var labelTextColors = [];
              tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
              var tooltipItems = [];
              for (i = 0, len = active.length; i < len; ++i) {
                tooltipItems.push(createTooltipItem(active[i]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a) {
                  return opts.filter(a, data);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a, b) {
                  return opts.itemSort(a, b, data);
                });
              }
              helpers$1.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
              });
              model.title = me.getTitle(tooltipItems, data);
              model.beforeBody = me.getBeforeBody(tooltipItems, data);
              model.body = me.getBody(tooltipItems, data);
              model.afterBody = me.getAfterBody(tooltipItems, data);
              model.footer = me.getFooter(tooltipItems, data);
              model.x = tooltipPosition.x;
              model.y = tooltipPosition.y;
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.labelTextColors = labelTextColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me, model);
            }
            return me;
          },
          drawCaret: function(tooltipPoint, size) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size, vm) {
            var x1, x2, x3, y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var ptX = tooltipPoint.x;
            var ptY = tooltipPoint.y;
            var width = size.width;
            var height = size.height;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = vm.caretX;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx) {
            var title2 = vm.title;
            var length = title2.length;
            var titleFontSize, titleSpacing, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._titleAlign);
              ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
              ctx.textBaseline = "middle";
              titleFontSize = vm.titleFontSize;
              titleSpacing = vm.titleSpacing;
              ctx.fillStyle = vm.titleFontColor;
              ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(title2[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                pt.y += titleFontSize + titleSpacing;
                if (i + 1 === length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
            var fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
              pt.y += bodyFontSize + bodySpacing;
            };
            var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlignForCalculation);
            ctx.fillStyle = vm.bodyFontColor;
            helpers$1.each(vm.beforeBody, fillLineOfText);
            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = vm.labelTextColors[i];
              labelColors = vm.labelColors[i];
              ctx.fillStyle = textColor;
              helpers$1.each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                if (drawColorBoxes) {
                  var rtlColorX = rtlHelper.x(colorX);
                  ctx.fillStyle = vm.legendColorBackground;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = labelColors.borderColor;
                  ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = labelColors.backgroundColor;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(lines[j]);
              }
              helpers$1.each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            helpers$1.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx) {
            var footer = vm.footer;
            var length = footer.length;
            var footerFontSize, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._footerAlign);
              pt.y += vm.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
              ctx.textBaseline = "middle";
              footerFontSize = vm.footerFontSize;
              ctx.fillStyle = vm.footerFontColor;
              ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                pt.y += footerFontSize + vm.footerSpacing;
              }
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize) {
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x = pt.x;
            var y = pt.y;
            var width = tooltipSize.width;
            var height = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, vm, ctx, tooltipSize);
              pt.y += vm.yPadding;
              helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
              this.drawTitle(pt, vm, ctx);
              this.drawBody(pt, vm, ctx);
              this.drawFooter(pt, vm, ctx);
              helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
              ctx.restore();
            }
          },
          /**
           * Handle an event
           * @private
           * @param {IEvent} event - The event to handle
           * @returns {boolean} true if the tooltip changed
           */
          handleEvent: function(e) {
            var me = this;
            var options2 = me._options;
            var changed = false;
            me._lastActive = me._lastActive || [];
            if (e.type === "mouseout") {
              me._active = [];
            } else {
              me._active = me._chart.getElementsAtEventForMode(e, options2.mode, options2);
              if (options2.reverse) {
                me._active.reverse();
              }
            }
            changed = !helpers$1.arrayEquals(me._active, me._lastActive);
            if (changed) {
              me._lastActive = me._active;
              if (options2.enabled || options2.custom) {
                me._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                me.update(true);
                me.pivot();
              }
            }
            return changed;
          }
        });
        var positioners_1 = positioners;
        var core_tooltip = exports$4;
        core_tooltip.positioners = positioners_1;
        var valueOrDefault$9 = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          elements: {},
          events: [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ],
          hover: {
            onHover: null,
            mode: "nearest",
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          maintainAspectRatio: true,
          responsive: true,
          responsiveAnimationDuration: 0
        });
        function mergeScaleConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              if (key === "xAxes" || key === "yAxes") {
                var slen = source[key].length;
                var i, type, scale2;
                if (!target[key]) {
                  target[key] = [];
                }
                for (i = 0; i < slen; ++i) {
                  scale2 = source[key][i];
                  type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
                  if (i >= target[key].length) {
                    target[key].push({});
                  }
                  if (!target[key][i].type || scale2.type && scale2.type !== target[key][i].type) {
                    helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale2]);
                  } else {
                    helpers$1.merge(target[key][i], scale2);
                  }
                }
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function mergeConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              var tval = target[key] || /* @__PURE__ */ Object.create(null);
              var sval = source[key];
              if (key === "scales") {
                target[key] = mergeScaleConfig(tval, sval);
              } else if (key === "scale") {
                target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function initConfig(config) {
          config = config || /* @__PURE__ */ Object.create(null);
          var data = config.data = config.data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          config.options = mergeConfig(
            core_defaults.global,
            core_defaults[config.type],
            config.options || {}
          );
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          helpers$1.each(chart.scales, function(scale2) {
            core_layouts.removeBox(chart, scale2);
          });
          newOptions = mergeConfig(
            core_defaults.global,
            core_defaults[chart.config.type],
            newOptions
          );
          chart.options = chart.config.options = newOptions;
          chart.ensureScalesHaveIDs();
          chart.buildOrUpdateScales();
          chart.tooltip._options = newOptions.tooltips;
          chart.tooltip.initialize();
        }
        function nextAvailableScaleId(axesOpts, prefix, index2) {
          var id;
          var hasId = function(obj) {
            return obj.id === id;
          };
          do {
            id = prefix + index2++;
          } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
          return id;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        var Chart2 = function(item, config) {
          this.construct(item, config);
          return this;
        };
        helpers$1.extend(
          Chart2.prototype,
          /** @lends Chart */
          {
            /**
             * @private
             */
            construct: function(item, config) {
              var me = this;
              config = initConfig(config);
              var context = platform.acquireContext(item, config);
              var canvas2 = context && context.canvas;
              var height = canvas2 && canvas2.height;
              var width = canvas2 && canvas2.width;
              me.id = helpers$1.uid();
              me.ctx = context;
              me.canvas = canvas2;
              me.config = config;
              me.width = width;
              me.height = height;
              me.aspectRatio = height ? width / height : null;
              me.options = config.options;
              me._bufferedRender = false;
              me._layers = [];
              me.chart = me;
              me.controller = me;
              Chart2.instances[me.id] = me;
              Object.defineProperty(me, "data", {
                get: function() {
                  return me.config.data;
                },
                set: function(value) {
                  me.config.data = value;
                }
              });
              if (!context || !canvas2) {
                console.error("Failed to create chart: can't acquire context from the given item");
                return;
              }
              me.initialize();
              me.update();
            },
            /**
             * @private
             */
            initialize: function() {
              var me = this;
              core_plugins.notify(me, "beforeInit");
              helpers$1.retinaScale(me, me.options.devicePixelRatio);
              me.bindEvents();
              if (me.options.responsive) {
                me.resize(true);
              }
              me.initToolTip();
              core_plugins.notify(me, "afterInit");
              return me;
            },
            clear: function() {
              helpers$1.canvas.clear(this);
              return this;
            },
            stop: function() {
              core_animations.cancelAnimation(this);
              return this;
            },
            resize: function(silent) {
              var me = this;
              var options2 = me.options;
              var canvas2 = me.canvas;
              var aspectRatio = options2.maintainAspectRatio && me.aspectRatio || null;
              var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas2)));
              var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas2)));
              if (me.width === newWidth && me.height === newHeight) {
                return;
              }
              canvas2.width = me.width = newWidth;
              canvas2.height = me.height = newHeight;
              canvas2.style.width = newWidth + "px";
              canvas2.style.height = newHeight + "px";
              helpers$1.retinaScale(me, options2.devicePixelRatio);
              if (!silent) {
                var newSize = { width: newWidth, height: newHeight };
                core_plugins.notify(me, "resize", [newSize]);
                if (options2.onResize) {
                  options2.onResize(me, newSize);
                }
                me.stop();
                me.update({
                  duration: options2.responsiveAnimationDuration
                });
              }
            },
            ensureScalesHaveIDs: function() {
              var options2 = this.options;
              var scalesOptions = options2.scales || {};
              var scaleOptions = options2.scale;
              helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index2) {
                if (!xAxisOptions.id) {
                  xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index2);
                }
              });
              helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index2) {
                if (!yAxisOptions.id) {
                  yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index2);
                }
              });
              if (scaleOptions) {
                scaleOptions.id = scaleOptions.id || "scale";
              }
            },
            /**
             * Builds a map of scale ID to scale object for future lookup.
             */
            buildOrUpdateScales: function() {
              var me = this;
              var options2 = me.options;
              var scales2 = me.scales || {};
              var items = [];
              var updated = Object.keys(scales2).reduce(function(obj, id) {
                obj[id] = false;
                return obj;
              }, {});
              if (options2.scales) {
                items = items.concat(
                  (options2.scales.xAxes || []).map(function(xAxisOptions) {
                    return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
                  }),
                  (options2.scales.yAxes || []).map(function(yAxisOptions) {
                    return { options: yAxisOptions, dtype: "linear", dposition: "left" };
                  })
                );
              }
              if (options2.scale) {
                items.push({
                  options: options2.scale,
                  dtype: "radialLinear",
                  isDefault: true,
                  dposition: "chartArea"
                });
              }
              helpers$1.each(items, function(item) {
                var scaleOptions = item.options;
                var id = scaleOptions.id;
                var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
                if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                  scaleOptions.position = item.dposition;
                }
                updated[id] = true;
                var scale2 = null;
                if (id in scales2 && scales2[id].type === scaleType) {
                  scale2 = scales2[id];
                  scale2.options = scaleOptions;
                  scale2.ctx = me.ctx;
                  scale2.chart = me;
                } else {
                  var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                  if (!scaleClass) {
                    return;
                  }
                  scale2 = new scaleClass({
                    id,
                    type: scaleType,
                    options: scaleOptions,
                    ctx: me.ctx,
                    chart: me
                  });
                  scales2[scale2.id] = scale2;
                }
                scale2.mergeTicksOptions();
                if (item.isDefault) {
                  me.scale = scale2;
                }
              });
              helpers$1.each(updated, function(hasUpdated, id) {
                if (!hasUpdated) {
                  delete scales2[id];
                }
              });
              me.scales = scales2;
              core_scaleService.addScalesToLayout(this);
            },
            buildOrUpdateControllers: function() {
              var me = this;
              var newControllers = [];
              var datasets = me.data.datasets;
              var i, ilen;
              for (i = 0, ilen = datasets.length; i < ilen; i++) {
                var dataset = datasets[i];
                var meta = me.getDatasetMeta(i);
                var type = dataset.type || me.config.type;
                if (meta.type && meta.type !== type) {
                  me.destroyDatasetMeta(i);
                  meta = me.getDatasetMeta(i);
                }
                meta.type = type;
                meta.order = dataset.order || 0;
                meta.index = i;
                if (meta.controller) {
                  meta.controller.updateIndex(i);
                  meta.controller.linkScales();
                } else {
                  var ControllerClass = controllers[meta.type];
                  if (ControllerClass === void 0) {
                    throw new Error('"' + meta.type + '" is not a chart type.');
                  }
                  meta.controller = new ControllerClass(me, i);
                  newControllers.push(meta.controller);
                }
              }
              return newControllers;
            },
            /**
             * Reset the elements of all datasets
             * @private
             */
            resetElements: function() {
              var me = this;
              helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
                me.getDatasetMeta(datasetIndex).controller.reset();
              }, me);
            },
            /**
            * Resets the chart back to it's state before the initial animation
            */
            reset: function() {
              this.resetElements();
              this.tooltip.initialize();
            },
            update: function(config) {
              var me = this;
              var i, ilen;
              if (!config || typeof config !== "object") {
                config = {
                  duration: config,
                  lazy: arguments[1]
                };
              }
              updateConfig(me);
              core_plugins._invalidate(me);
              if (core_plugins.notify(me, "beforeUpdate") === false) {
                return;
              }
              me.tooltip._data = me.data;
              var newControllers = me.buildOrUpdateControllers();
              for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
                me.getDatasetMeta(i).controller.buildOrUpdateElements();
              }
              me.updateLayout();
              if (me.options.animation && me.options.animation.duration) {
                helpers$1.each(newControllers, function(controller) {
                  controller.reset();
                });
              }
              me.updateDatasets();
              me.tooltip.initialize();
              me.lastActive = [];
              core_plugins.notify(me, "afterUpdate");
              me._layers.sort(compare2Level("z", "_idx"));
              if (me._bufferedRender) {
                me._bufferedRequest = {
                  duration: config.duration,
                  easing: config.easing,
                  lazy: config.lazy
                };
              } else {
                me.render(config);
              }
            },
            /**
             * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
             * hook, in which case, plugins will not be called on `afterLayout`.
             * @private
             */
            updateLayout: function() {
              var me = this;
              if (core_plugins.notify(me, "beforeLayout") === false) {
                return;
              }
              core_layouts.update(this, this.width, this.height);
              me._layers = [];
              helpers$1.each(me.boxes, function(box) {
                if (box._configure) {
                  box._configure();
                }
                me._layers.push.apply(me._layers, box._layers());
              }, me);
              me._layers.forEach(function(item, index2) {
                item._idx = index2;
              });
              core_plugins.notify(me, "afterScaleUpdate");
              core_plugins.notify(me, "afterLayout");
            },
            /**
             * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
             * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
             * @private
             */
            updateDatasets: function() {
              var me = this;
              if (core_plugins.notify(me, "beforeDatasetsUpdate") === false) {
                return;
              }
              for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                me.updateDataset(i);
              }
              core_plugins.notify(me, "afterDatasetsUpdate");
            },
            /**
             * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
             * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
             * @private
             */
            updateDataset: function(index2) {
              var me = this;
              var meta = me.getDatasetMeta(index2);
              var args = {
                meta,
                index: index2
              };
              if (core_plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
                return;
              }
              meta.controller._update();
              core_plugins.notify(me, "afterDatasetUpdate", [args]);
            },
            render: function(config) {
              var me = this;
              if (!config || typeof config !== "object") {
                config = {
                  duration: config,
                  lazy: arguments[1]
                };
              }
              var animationOptions = me.options.animation;
              var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
              var lazy = config.lazy;
              if (core_plugins.notify(me, "beforeRender") === false) {
                return;
              }
              var onComplete = function(animation2) {
                core_plugins.notify(me, "afterRender");
                helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me);
              };
              if (animationOptions && duration) {
                var animation = new core_animation({
                  numSteps: duration / 16.66,
                  // 60 fps
                  easing: config.easing || animationOptions.easing,
                  render: function(chart, animationObject) {
                    var easingFunction = helpers$1.easing.effects[animationObject.easing];
                    var currentStep = animationObject.currentStep;
                    var stepDecimal = currentStep / animationObject.numSteps;
                    chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                  },
                  onAnimationProgress: animationOptions.onProgress,
                  onAnimationComplete: onComplete
                });
                core_animations.addAnimation(me, animation, duration, lazy);
              } else {
                me.draw();
                onComplete(new core_animation({ numSteps: 0, chart: me }));
              }
              return me;
            },
            draw: function(easingValue) {
              var me = this;
              var i, layers;
              me.clear();
              if (helpers$1.isNullOrUndef(easingValue)) {
                easingValue = 1;
              }
              me.transition(easingValue);
              if (me.width <= 0 || me.height <= 0) {
                return;
              }
              if (core_plugins.notify(me, "beforeDraw", [easingValue]) === false) {
                return;
              }
              layers = me._layers;
              for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
                layers[i].draw(me.chartArea);
              }
              me.drawDatasets(easingValue);
              for (; i < layers.length; ++i) {
                layers[i].draw(me.chartArea);
              }
              me._drawTooltip(easingValue);
              core_plugins.notify(me, "afterDraw", [easingValue]);
            },
            /**
             * @private
             */
            transition: function(easingValue) {
              var me = this;
              for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
                if (me.isDatasetVisible(i)) {
                  me.getDatasetMeta(i).controller.transition(easingValue);
                }
              }
              me.tooltip.transition(easingValue);
            },
            /**
             * @private
             */
            _getSortedDatasetMetas: function(filterVisible) {
              var me = this;
              var datasets = me.data.datasets || [];
              var result = [];
              var i, ilen;
              for (i = 0, ilen = datasets.length; i < ilen; ++i) {
                if (!filterVisible || me.isDatasetVisible(i)) {
                  result.push(me.getDatasetMeta(i));
                }
              }
              result.sort(compare2Level("order", "index"));
              return result;
            },
            /**
             * @private
             */
            _getSortedVisibleDatasetMetas: function() {
              return this._getSortedDatasetMetas(true);
            },
            /**
             * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
             * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
             * @private
             */
            drawDatasets: function(easingValue) {
              var me = this;
              var metasets, i;
              if (core_plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
                return;
              }
              metasets = me._getSortedVisibleDatasetMetas();
              for (i = metasets.length - 1; i >= 0; --i) {
                me.drawDataset(metasets[i], easingValue);
              }
              core_plugins.notify(me, "afterDatasetsDraw", [easingValue]);
            },
            /**
             * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
             * hook, in which case, plugins will not be called on `afterDatasetDraw`.
             * @private
             */
            drawDataset: function(meta, easingValue) {
              var me = this;
              var args = {
                meta,
                index: meta.index,
                easingValue
              };
              if (core_plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
                return;
              }
              meta.controller.draw(easingValue);
              core_plugins.notify(me, "afterDatasetDraw", [args]);
            },
            /**
             * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
             * hook, in which case, plugins will not be called on `afterTooltipDraw`.
             * @private
             */
            _drawTooltip: function(easingValue) {
              var me = this;
              var tooltip = me.tooltip;
              var args = {
                tooltip,
                easingValue
              };
              if (core_plugins.notify(me, "beforeTooltipDraw", [args]) === false) {
                return;
              }
              tooltip.draw();
              core_plugins.notify(me, "afterTooltipDraw", [args]);
            },
            /**
             * Get the single element that was clicked on
             * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
             */
            getElementAtEvent: function(e) {
              return core_interaction.modes.single(this, e);
            },
            getElementsAtEvent: function(e) {
              return core_interaction.modes.label(this, e, { intersect: true });
            },
            getElementsAtXAxis: function(e) {
              return core_interaction.modes["x-axis"](this, e, { intersect: true });
            },
            getElementsAtEventForMode: function(e, mode, options2) {
              var method = core_interaction.modes[mode];
              if (typeof method === "function") {
                return method(this, e, options2);
              }
              return [];
            },
            getDatasetAtEvent: function(e) {
              return core_interaction.modes.dataset(this, e, { intersect: true });
            },
            getDatasetMeta: function(datasetIndex) {
              var me = this;
              var dataset = me.data.datasets[datasetIndex];
              if (!dataset._meta) {
                dataset._meta = {};
              }
              var meta = dataset._meta[me.id];
              if (!meta) {
                meta = dataset._meta[me.id] = {
                  type: null,
                  data: [],
                  dataset: null,
                  controller: null,
                  hidden: null,
                  // See isDatasetVisible() comment
                  xAxisID: null,
                  yAxisID: null,
                  order: dataset.order || 0,
                  index: datasetIndex
                };
              }
              return meta;
            },
            getVisibleDatasetCount: function() {
              var count = 0;
              for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                if (this.isDatasetVisible(i)) {
                  count++;
                }
              }
              return count;
            },
            isDatasetVisible: function(datasetIndex) {
              var meta = this.getDatasetMeta(datasetIndex);
              return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
            },
            generateLegend: function() {
              return this.options.legendCallback(this);
            },
            /**
             * @private
             */
            destroyDatasetMeta: function(datasetIndex) {
              var id = this.id;
              var dataset = this.data.datasets[datasetIndex];
              var meta = dataset._meta && dataset._meta[id];
              if (meta) {
                meta.controller.destroy();
                delete dataset._meta[id];
              }
            },
            destroy: function() {
              var me = this;
              var canvas2 = me.canvas;
              var i, ilen;
              me.stop();
              for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                me.destroyDatasetMeta(i);
              }
              if (canvas2) {
                me.unbindEvents();
                helpers$1.canvas.clear(me);
                platform.releaseContext(me.ctx);
                me.canvas = null;
                me.ctx = null;
              }
              core_plugins.notify(me, "destroy");
              delete Chart2.instances[me.id];
            },
            toBase64Image: function() {
              return this.canvas.toDataURL.apply(this.canvas, arguments);
            },
            initToolTip: function() {
              var me = this;
              me.tooltip = new core_tooltip({
                _chart: me,
                _chartInstance: me,
                // deprecated, backward compatibility
                _data: me.data,
                _options: me.options.tooltips
              }, me);
            },
            /**
             * @private
             */
            bindEvents: function() {
              var me = this;
              var listeners = me._listeners = {};
              var listener = function() {
                me.eventHandler.apply(me, arguments);
              };
              helpers$1.each(me.options.events, function(type) {
                platform.addEventListener(me, type, listener);
                listeners[type] = listener;
              });
              if (me.options.responsive) {
                listener = function() {
                  me.resize();
                };
                platform.addEventListener(me, "resize", listener);
                listeners.resize = listener;
              }
            },
            /**
             * @private
             */
            unbindEvents: function() {
              var me = this;
              var listeners = me._listeners;
              if (!listeners) {
                return;
              }
              delete me._listeners;
              helpers$1.each(listeners, function(listener, type) {
                platform.removeEventListener(me, type, listener);
              });
            },
            updateHoverStyle: function(elements2, mode, enabled) {
              var prefix = enabled ? "set" : "remove";
              var element, i, ilen;
              for (i = 0, ilen = elements2.length; i < ilen; ++i) {
                element = elements2[i];
                if (element) {
                  this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
                }
              }
              if (mode === "dataset") {
                this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
              }
            },
            /**
             * @private
             */
            eventHandler: function(e) {
              var me = this;
              var tooltip = me.tooltip;
              if (core_plugins.notify(me, "beforeEvent", [e]) === false) {
                return;
              }
              me._bufferedRender = true;
              me._bufferedRequest = null;
              var changed = me.handleEvent(e);
              if (tooltip) {
                changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
              }
              core_plugins.notify(me, "afterEvent", [e]);
              var bufferedRequest = me._bufferedRequest;
              if (bufferedRequest) {
                me.render(bufferedRequest);
              } else if (changed && !me.animating) {
                me.stop();
                me.render({
                  duration: me.options.hover.animationDuration,
                  lazy: true
                });
              }
              me._bufferedRender = false;
              me._bufferedRequest = null;
              return me;
            },
            /**
             * Handle an event
             * @private
             * @param {IEvent} event the event to handle
             * @return {boolean} true if the chart needs to re-render
             */
            handleEvent: function(e) {
              var me = this;
              var options2 = me.options || {};
              var hoverOptions = options2.hover;
              var changed = false;
              me.lastActive = me.lastActive || [];
              if (e.type === "mouseout") {
                me.active = [];
              } else {
                me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
              }
              helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me.active], me);
              if (e.type === "mouseup" || e.type === "click") {
                if (options2.onClick) {
                  options2.onClick.call(me, e.native, me.active);
                }
              }
              if (me.lastActive.length) {
                me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
              }
              if (me.active.length && hoverOptions.mode) {
                me.updateHoverStyle(me.active, hoverOptions.mode, true);
              }
              changed = !helpers$1.arrayEquals(me.active, me.lastActive);
              me.lastActive = me.active;
              return changed;
            }
          }
        );
        Chart2.instances = {};
        var core_controller = Chart2;
        Chart2.Controller = Chart2;
        Chart2.types = {};
        helpers$1.configMerge = mergeConfig;
        helpers$1.scaleMerge = mergeScaleConfig;
        var core_helpers = function() {
          helpers$1.where = function(collection, filterCallback) {
            if (helpers$1.isArray(collection) && Array.prototype.filter) {
              return collection.filter(filterCallback);
            }
            var filtered = [];
            helpers$1.each(collection, function(item) {
              if (filterCallback(item)) {
                filtered.push(item);
              }
            });
            return filtered;
          };
          helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
            return array.findIndex(callback, scope);
          } : function(array, callback, scope) {
            scope = scope === void 0 ? array : scope;
            for (var i = 0, ilen = array.length; i < ilen; ++i) {
              if (callback.call(scope, array[i], i, array)) {
                return i;
              }
            }
            return -1;
          };
          helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = -1;
            }
            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = arrayToSearch.length;
            }
            for (var i = startIndex - 1; i >= 0; i--) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.isNumber = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
          };
          helpers$1.almostEquals = function(x, y, epsilon) {
            return Math.abs(x - y) < epsilon;
          };
          helpers$1.almostWhole = function(x, epsilon) {
            var rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
          };
          helpers$1.max = function(array) {
            return array.reduce(function(max2, value) {
              if (!isNaN(value)) {
                return Math.max(max2, value);
              }
              return max2;
            }, Number.NEGATIVE_INFINITY);
          };
          helpers$1.min = function(array) {
            return array.reduce(function(min2, value) {
              if (!isNaN(value)) {
                return Math.min(min2, value);
              }
              return min2;
            }, Number.POSITIVE_INFINITY);
          };
          helpers$1.sign = Math.sign ? function(x) {
            return Math.sign(x);
          } : function(x) {
            x = +x;
            if (x === 0 || isNaN(x)) {
              return x;
            }
            return x > 0 ? 1 : -1;
          };
          helpers$1.toRadians = function(degrees) {
            return degrees * (Math.PI / 180);
          };
          helpers$1.toDegrees = function(radians) {
            return radians * (180 / Math.PI);
          };
          helpers$1._decimalPlaces = function(x) {
            if (!helpers$1.isFinite(x)) {
              return;
            }
            var e = 1;
            var p = 0;
            while (Math.round(x * e) / e !== x) {
              e *= 10;
              p++;
            }
            return p;
          };
          helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x;
            var distanceFromYCenter = anglePoint.y - centrePoint.y;
            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -0.5 * Math.PI) {
              angle += 2 * Math.PI;
            }
            return {
              angle,
              distance: radialDistanceFromCenter
            };
          };
          helpers$1.distanceBetweenPoints = function(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
          };
          helpers$1.aliasPixel = function(pixelWidth) {
            return pixelWidth % 2 === 0 ? 0 : 0.5;
          };
          helpers$1._alignPixel = function(chart, pixel, width) {
            var devicePixelRatio = chart.currentDevicePixelRatio;
            var halfWidth = width / 2;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
          };
          helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
            var previous = firstPoint.skip ? middlePoint : firstPoint;
            var current = middlePoint;
            var next = afterPoint.skip ? middlePoint : afterPoint;
            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
            var s01 = d01 / (d01 + d12);
            var s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            var fa = t * s01;
            var fb = t * s12;
            return {
              previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y)
              },
              next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y)
              }
            };
          };
          helpers$1.EPSILON = Number.EPSILON || 1e-14;
          helpers$1.splineCurveMonotone = function(points) {
            var pointsWithTangents = (points || []).map(function(point) {
              return {
                model: point._model,
                deltaK: 0,
                mK: 0
              };
            });
            var pointsLen = pointsWithTangents.length;
            var i, pointBefore, pointCurrent, pointAfter;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointAfter && !pointAfter.model.skip) {
                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
              }
              if (!pointBefore || pointBefore.model.skip) {
                pointCurrent.mK = pointCurrent.deltaK;
              } else if (!pointAfter || pointAfter.model.skip) {
                pointCurrent.mK = pointBefore.deltaK;
              } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                pointCurrent.mK = 0;
              } else {
                pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
              }
            }
            var alphaK, betaK, tauK, squaredMagnitude;
            for (i = 0; i < pointsLen - 1; ++i) {
              pointCurrent = pointsWithTangents[i];
              pointAfter = pointsWithTangents[i + 1];
              if (pointCurrent.model.skip || pointAfter.model.skip) {
                continue;
              }
              if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                pointCurrent.mK = pointAfter.mK = 0;
                continue;
              }
              alphaK = pointCurrent.mK / pointCurrent.deltaK;
              betaK = pointAfter.mK / pointCurrent.deltaK;
              squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
              if (squaredMagnitude <= 9) {
                continue;
              }
              tauK = 3 / Math.sqrt(squaredMagnitude);
              pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
              pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
            }
            var deltaX;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointBefore && !pointBefore.model.skip) {
                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
              }
              if (pointAfter && !pointAfter.model.skip) {
                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
              }
            }
          };
          helpers$1.nextItem = function(collection, index2, loop) {
            if (loop) {
              return index2 >= collection.length - 1 ? collection[0] : collection[index2 + 1];
            }
            return index2 >= collection.length - 1 ? collection[collection.length - 1] : collection[index2 + 1];
          };
          helpers$1.previousItem = function(collection, index2, loop) {
            if (loop) {
              return index2 <= 0 ? collection[collection.length - 1] : collection[index2 - 1];
            }
            return index2 <= 0 ? collection[0] : collection[index2 - 1];
          };
          helpers$1.niceNum = function(range, round2) {
            var exponent = Math.floor(helpers$1.log10(range));
            var fraction = range / Math.pow(10, exponent);
            var niceFraction;
            if (round2) {
              if (fraction < 1.5) {
                niceFraction = 1;
              } else if (fraction < 3) {
                niceFraction = 2;
              } else if (fraction < 7) {
                niceFraction = 5;
              } else {
                niceFraction = 10;
              }
            } else if (fraction <= 1) {
              niceFraction = 1;
            } else if (fraction <= 2) {
              niceFraction = 2;
            } else if (fraction <= 5) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
            return niceFraction * Math.pow(10, exponent);
          };
          helpers$1.requestAnimFrame = function() {
            if (typeof window === "undefined") {
              return function(callback) {
                callback();
              };
            }
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
              return window.setTimeout(callback, 1e3 / 60);
            };
          }();
          helpers$1.getRelativePosition = function(evt, chart) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt;
            var canvas2 = evt.target || evt.srcElement;
            var boundingRect = canvas2.getBoundingClientRect();
            var touches = e.touches;
            if (touches && touches.length > 0) {
              mouseX = touches[0].clientX;
              mouseY = touches[0].clientY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var paddingLeft = parseFloat(helpers$1.getStyle(canvas2, "padding-left"));
            var paddingTop = parseFloat(helpers$1.getStyle(canvas2, "padding-top"));
            var paddingRight = parseFloat(helpers$1.getStyle(canvas2, "padding-right"));
            var paddingBottom = parseFloat(helpers$1.getStyle(canvas2, "padding-bottom"));
            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas2.width / chart.currentDevicePixelRatio);
            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas2.height / chart.currentDevicePixelRatio);
            return {
              x: mouseX,
              y: mouseY
            };
          };
          function parseMaxStyle(styleValue, node, parentProperty) {
            var valueInPixels;
            if (typeof styleValue === "string") {
              valueInPixels = parseInt(styleValue, 10);
              if (styleValue.indexOf("%") !== -1) {
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
              }
            } else {
              valueInPixels = styleValue;
            }
            return valueInPixels;
          }
          function isConstrainedValue(value) {
            return value !== void 0 && value !== null && value !== "none";
          }
          function getConstraintDimension(domNode, maxStyle, percentageProperty) {
            var view = document.defaultView;
            var parentNode = helpers$1._getParentNode(domNode);
            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
            var hasCNode = isConstrainedValue(constrainedNode);
            var hasCContainer = isConstrainedValue(constrainedContainer);
            var infinity = Number.POSITIVE_INFINITY;
            if (hasCNode || hasCContainer) {
              return Math.min(
                hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
                hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity
              );
            }
            return "none";
          }
          helpers$1.getConstraintWidth = function(domNode) {
            return getConstraintDimension(domNode, "max-width", "clientWidth");
          };
          helpers$1.getConstraintHeight = function(domNode) {
            return getConstraintDimension(domNode, "max-height", "clientHeight");
          };
          helpers$1._calculatePadding = function(container, padding, parentDimension) {
            padding = helpers$1.getStyle(container, padding);
            return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
          };
          helpers$1._getParentNode = function(domNode) {
            var parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") {
              parent = parent.host;
            }
            return parent;
          };
          helpers$1.getMaximumWidth = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientWidth;
            }
            var clientWidth = container.clientWidth;
            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
            var w = clientWidth - paddingLeft - paddingRight;
            var cw = helpers$1.getConstraintWidth(domNode);
            return isNaN(cw) ? w : Math.min(w, cw);
          };
          helpers$1.getMaximumHeight = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientHeight;
            }
            var clientHeight = container.clientHeight;
            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
            var h = clientHeight - paddingTop - paddingBottom;
            var ch = helpers$1.getConstraintHeight(domNode);
            return isNaN(ch) ? h : Math.min(h, ch);
          };
          helpers$1.getStyle = function(el, property) {
            return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
          };
          helpers$1.retinaScale = function(chart, forceRatio) {
            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
            if (pixelRatio === 1) {
              return;
            }
            var canvas2 = chart.canvas;
            var height = chart.height;
            var width = chart.width;
            canvas2.height = height * pixelRatio;
            canvas2.width = width * pixelRatio;
            chart.ctx.scale(pixelRatio, pixelRatio);
            if (!canvas2.style.height && !canvas2.style.width) {
              canvas2.style.height = height + "px";
              canvas2.style.width = width + "px";
            }
          };
          helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
          };
          helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
            cache = cache || {};
            var data = cache.data = cache.data || {};
            var gc = cache.garbageCollect = cache.garbageCollect || [];
            if (cache.font !== font) {
              data = cache.data = {};
              gc = cache.garbageCollect = [];
              cache.font = font;
            }
            ctx.font = font;
            var longest = 0;
            var ilen = arrayOfThings.length;
            var i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
              thing = arrayOfThings[i];
              if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
                longest = helpers$1.measureText(ctx, data, gc, longest, thing);
              } else if (helpers$1.isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                  nestedThing = thing[j];
                  if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                    longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                  }
                }
              }
            }
            var gcLen = gc.length / 2;
            if (gcLen > arrayOfThings.length) {
              for (i = 0; i < gcLen; i++) {
                delete data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
            return longest;
          };
          helpers$1.measureText = function(ctx, data, gc, longest, string) {
            var textWidth = data[string];
            if (!textWidth) {
              textWidth = data[string] = ctx.measureText(string).width;
              gc.push(string);
            }
            if (textWidth > longest) {
              longest = textWidth;
            }
            return longest;
          };
          helpers$1.numberOfLabelLines = function(arrayOfThings) {
            var numberOfLines = 1;
            helpers$1.each(arrayOfThings, function(thing) {
              if (helpers$1.isArray(thing)) {
                if (thing.length > numberOfLines) {
                  numberOfLines = thing.length;
                }
              }
            });
            return numberOfLines;
          };
          helpers$1.color = !chartjsColor ? function(value) {
            console.error("Color.js not found!");
            return value;
          } : function(value) {
            if (value instanceof CanvasGradient) {
              value = core_defaults.global.defaultColor;
            }
            return chartjsColor(value);
          };
          helpers$1.getHoverColor = function(colorValue) {
            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
          };
        };
        function abstract() {
          throw new Error(
            "This method is not implemented: either no adapter can be found or an incomplete integration was provided."
          );
        }
        function DateAdapter(options2) {
          this.options = options2 || {};
        }
        helpers$1.extend(
          DateAdapter.prototype,
          /** @lends DateAdapter */
          {
            /**
             * Returns a map of time formats for the supported formatting units defined
             * in Unit as well as 'datetime' representing a detailed date/time string.
             * @returns {{string: string}}
             */
            formats: abstract,
            /**
             * Parses the given `value` and return the associated timestamp.
             * @param {any} value - the value to parse (usually comes from the data)
             * @param {string} [format] - the expected data format
             * @returns {(number|null)}
             * @function
             */
            parse: abstract,
            /**
             * Returns the formatted date in the specified `format` for a given `timestamp`.
             * @param {number} timestamp - the timestamp to format
             * @param {string} format - the date/time token
             * @return {string}
             * @function
             */
            format: abstract,
            /**
             * Adds the specified `amount` of `unit` to the given `timestamp`.
             * @param {number} timestamp - the input timestamp
             * @param {number} amount - the amount to add
             * @param {Unit} unit - the unit as string
             * @return {number}
             * @function
             */
            add: abstract,
            /**
             * Returns the number of `unit` between the given timestamps.
             * @param {number} max - the input timestamp (reference)
             * @param {number} min - the timestamp to substract
             * @param {Unit} unit - the unit as string
             * @return {number}
             * @function
             */
            diff: abstract,
            /**
             * Returns start of `unit` for the given `timestamp`.
             * @param {number} timestamp - the input timestamp
             * @param {Unit} unit - the unit as string
             * @param {number} [weekday] - the ISO day of the week with 1 being Monday
             * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
             * @function
             */
            startOf: abstract,
            /**
             * Returns end of `unit` for the given `timestamp`.
             * @param {number} timestamp - the input timestamp
             * @param {Unit} unit - the unit as string
             * @function
             */
            endOf: abstract,
            // DEPRECATIONS
            /**
             * Provided for backward compatibility for scale.getValueForPixel(),
             * this method should be overridden only by the moment adapter.
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             * @private
             */
            _create: function(value) {
              return value;
            }
          }
        );
        DateAdapter.override = function(members) {
          helpers$1.extend(DateAdapter.prototype, members);
        };
        var _date = DateAdapter;
        var core_adapters = {
          _date
        };
        var core_ticks = {
          /**
           * Namespace to hold formatters for different types of ticks
           * @namespace Chart.Ticks.formatters
           */
          formatters: {
            /**
             * Formatter for value labels
             * @method Chart.Ticks.formatters.values
             * @param value the value to display
             * @return {string|string[]} the label to display
             */
            values: function(value) {
              return helpers$1.isArray(value) ? value : "" + value;
            },
            /**
             * Formatter for linear numeric ticks
             * @method Chart.Ticks.formatters.linear
             * @param tickValue {number} the value to be formatted
             * @param index {number} the position of the tickValue parameter in the ticks array
             * @param ticks {number[]} the list of ticks being converted
             * @return {string} string representation of the tickValue parameter
             */
            linear: function(tickValue, index2, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers$1.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                if (maxTick < 1e-4) {
                  var logTick = helpers$1.log10(Math.abs(tickValue));
                  var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                  numExponential = Math.max(Math.min(numExponential, 20), 0);
                  tickString = tickValue.toExponential(numExponential);
                } else {
                  var numDecimal = -1 * Math.floor(logDelta);
                  numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                  tickString = tickValue.toFixed(numDecimal);
                }
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index2, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index2 === 0 || index2 === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
        var isArray2 = helpers$1.isArray;
        var isNullOrUndef = helpers$1.isNullOrUndef;
        var valueOrDefault$a = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
        core_defaults._set("scale", {
          display: true,
          position: "left",
          offset: false,
          // grid line settings
          gridLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          // scale label
          scaleLabel: {
            // display property
            display: false,
            // actual label
            labelString: "",
            // top/bottom padding
            padding: {
              top: 4,
              bottom: 4
            }
          },
          // label settings
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
            callback: core_ticks.formatters.values,
            minor: {},
            major: {}
          }
        });
        function sample(arr, numItems) {
          var result = [];
          var increment = arr.length / numItems;
          var i = 0;
          var len = arr.length;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale2, index2, offsetGridLines) {
          var length = scale2.getTicks().length;
          var validIndex = Math.min(index2, length - 1);
          var lineValue = scale2.getPixelForTick(validIndex);
          var start = scale2._startPixel;
          var end = scale2._endPixel;
          var epsilon = 1e-6;
          var offset2;
          if (offsetGridLines) {
            if (length === 1) {
              offset2 = Math.max(lineValue - start, end - lineValue);
            } else if (index2 === 0) {
              offset2 = (scale2.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset2 = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index2 ? offset2 : -offset2;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          helpers$1.each(caches, function(cache) {
            var gc = cache.gc;
            var gcLen = gc.length / 2;
            var i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function computeLabelSizes(ctx, tickFonts, ticks, caches) {
          var length = ticks.length;
          var widths = [];
          var heights = [];
          var offsets = [];
          var widestLabelSize = 0;
          var highestLabelSize = 0;
          var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray2(label)) {
              width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray2(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
                  width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            offsets.push(lineHeight / 2);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          widest = widths.indexOf(widestLabelSize);
          highest = heights.indexOf(highestLabelSize);
          function valueAt(idx) {
            return {
              width: widths[idx] || 0,
              height: heights[idx] || 0,
              offset: offsets[idx] || 0
            };
          }
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest)
          };
        }
        function getTickMarkLength(options2) {
          return options2.drawTicks ? options2.tickMarkLength : 0;
        }
        function getScaleLabelHeight(options2) {
          var font, padding;
          if (!options2.display) {
            return 0;
          }
          font = helpers$1.options._parseFont(options2);
          padding = helpers$1.options.toPadding(options2.padding);
          return font.lineHeight + padding.height;
        }
        function parseFontOptions(options2, nestedOpts) {
          return helpers$1.extend(helpers$1.options._parseFont({
            fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
            fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
            fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
            lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
          }), {
            color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
          });
        }
        function parseTickFontOptions(options2) {
          var minor = parseFontOptions(options2, options2.minor);
          var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
          return { minor, major };
        }
        function nonSkipped(ticksToFilter) {
          var filtered = [];
          var item, index2, len;
          for (index2 = 0, len = ticksToFilter.length; index2 < len; ++index2) {
            item = ticksToFilter[index2];
            if (typeof item._index !== "undefined") {
              filtered.push(item);
            }
          }
          return filtered;
        }
        function getEvenSpacing(arr) {
          var len = arr.length;
          var i, diff2;
          if (len < 2) {
            return false;
          }
          for (diff2 = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff2) {
              return false;
            }
          }
          return diff2;
        }
        function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
          var evenMajorSpacing = getEvenSpacing(majorIndices);
          var spacing = (ticks.length - 1) / ticksLimit;
          var factors, factor, i, ilen;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          factors = helpers$1.math._factorize(evenMajorSpacing);
          for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
            factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          var result = [];
          var i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, majorIndices, spacing) {
          var count = 0;
          var next = majorIndices[0];
          var i, tick;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = majorIndices[count * spacing];
            } else {
              delete tick.label;
            }
          }
        }
        function skip(ticks, spacing, majorStart, majorEnd) {
          var start = valueOrDefault$a(majorStart, 0);
          var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
          var count = 0;
          var length, i, tick, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = Math.round(start + count * spacing);
            } else {
              delete tick.label;
            }
          }
        }
        var Scale = core_element.extend({
          zeroLineIndex: 0,
          /**
           * Get the padding needed for the scale
           * @method getPadding
           * @private
           * @returns {Padding} the necessary padding
           */
          getPadding: function() {
            var me = this;
            return {
              left: me.paddingLeft || 0,
              top: me.paddingTop || 0,
              right: me.paddingRight || 0,
              bottom: me.paddingBottom || 0
            };
          },
          /**
           * Returns the scale tick objects ({label, major})
           * @since 2.7
           */
          getTicks: function() {
            return this._ticks;
          },
          /**
          * @private
          */
          _getLabels: function() {
            var data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          },
          // These methods are ordered by lifecyle. Utilities then follow.
          // Any function defined here is inherited by all scale types.
          // Any function can be extended by the scale type
          /**
           * Provided for backward compatibility, not available anymore
           * @function Chart.Scale.mergeTicksOptions
           * @deprecated since version 2.8.0
           * @todo remove at version 3
           */
          mergeTicksOptions: function() {
          },
          beforeUpdate: function() {
            helpers$1.callback(this.options.beforeUpdate, [this]);
          },
          /**
           * @param {number} maxWidth - the max width in pixels
           * @param {number} maxHeight - the max height in pixels
           * @param {object} margins - the space between the edge of the other scales and edge of the chart
           *   This space comes from two sources:
           *     - padding - space that's required to show the labels at the edges of the scale
           *     - thickness of scales or legends in another orientation
           */
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            var tickOpts = me.options.ticks;
            var sampleSize = tickOpts.sampleSize;
            var i, ilen, labels, ticks, samplingEnabled;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = helpers$1.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me._ticks = null;
            me.ticks = null;
            me._labelSizes = null;
            me._maxLabelLines = 0;
            me.longestLabelWidth = 0;
            me.longestTextCache = me.longestTextCache || {};
            me._gridLineItems = null;
            me._labelItems = null;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me.beforeBuildTicks();
            ticks = me.buildTicks() || [];
            ticks = me.afterBuildTicks(ticks) || ticks;
            if ((!ticks || !ticks.length) && me.ticks) {
              ticks = [];
              for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
                ticks.push({
                  value: me.ticks[i],
                  major: false
                });
              }
            }
            me._ticks = ticks;
            samplingEnabled = sampleSize < ticks.length;
            labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
            me._configure();
            me.beforeCalculateTickRotation();
            me.calculateTickRotation();
            me.afterCalculateTickRotation();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me._autoSkip(ticks) : ticks;
            if (samplingEnabled) {
              labels = me._convertTicksToLabels(me._ticksToDraw);
            }
            me.ticks = labels;
            me.afterUpdate();
            return me.minSize;
          },
          /**
           * @private
           */
          _configure: function() {
            var me = this;
            var reversePixels = me.options.ticks.reverse;
            var startPixel, endPixel;
            if (me.isHorizontal()) {
              startPixel = me.left;
              endPixel = me.right;
            } else {
              startPixel = me.top;
              endPixel = me.bottom;
              reversePixels = !reversePixels;
            }
            me._startPixel = startPixel;
            me._endPixel = endPixel;
            me._reversePixels = reversePixels;
            me._length = endPixel - startPixel;
          },
          afterUpdate: function() {
            helpers$1.callback(this.options.afterUpdate, [this]);
          },
          //
          beforeSetDimensions: function() {
            helpers$1.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers$1.callback(this.options.afterSetDimensions, [this]);
          },
          // Data limits
          beforeDataLimits: function() {
            helpers$1.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers$1.noop,
          afterDataLimits: function() {
            helpers$1.callback(this.options.afterDataLimits, [this]);
          },
          //
          beforeBuildTicks: function() {
            helpers$1.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers$1.noop,
          afterBuildTicks: function(ticks) {
            var me = this;
            if (isArray2(ticks) && ticks.length) {
              return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
            }
            me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
            return ticks;
          },
          beforeTickToLabelConversion: function() {
            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
          },
          afterTickToLabelConversion: function() {
            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
          },
          //
          beforeCalculateTickRotation: function() {
            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me = this;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var numTicks = me.getTicks().length;
            var minRotation = tickOpts.minRotation || 0;
            var maxRotation = tickOpts.maxRotation;
            var labelRotation = minRotation;
            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
            if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
              me.labelRotation = minRotation;
              return;
            }
            labelSizes = me._getLabelSizes();
            maxLabelWidth = labelSizes.widest.width;
            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
            maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
            tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
              maxHeight = me.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = helpers$1.toDegrees(Math.min(
                Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),
                Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)
              ));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            me.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
          },
          //
          beforeFit: function() {
            helpers$1.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me = this;
            var minSize = me.minSize = {
              width: 0,
              height: 0
            };
            var chart = me.chart;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = me._isVisible();
            var isBottom = opts.position === "bottom";
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
            } else if (display) {
              minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (!isHorizontal) {
              minSize.height = me.maxHeight;
            } else if (display) {
              minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (tickOpts.display && display) {
              var tickFonts = parseTickFontOptions(tickOpts);
              var labelSizes = me._getLabelSizes();
              var firstLabelSize = labelSizes.first;
              var lastLabelSize = labelSizes.last;
              var widestLabelSize = labelSizes.widest;
              var highestLabelSize = labelSizes.highest;
              var lineSpace = tickFonts.minor.lineHeight * 0.4;
              var tickPadding = tickOpts.padding;
              if (isHorizontal) {
                var isRotated = me.labelRotation !== 0;
                var angleRadians = helpers$1.toRadians(me.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
                var offsetLeft = me.getPixelForTick(0) - me.left;
                var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                var paddingLeft, paddingRight;
                if (isRotated) {
                  paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                  paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                } else {
                  paddingLeft = firstLabelSize.width / 2;
                  paddingRight = lastLabelSize.width / 2;
                }
                me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
                me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
              } else {
                var labelWidth = tickOpts.mirror ? 0 : (
                  // use lineSpace for consistency with horizontal axis
                  // tickPadding is not implemented for horizontal
                  widestLabelSize.width + tickPadding + lineSpace
                );
                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
                me.paddingTop = firstLabelSize.height / 2;
                me.paddingBottom = lastLabelSize.height / 2;
              }
            }
            me.handleMargins();
            if (isHorizontal) {
              me.width = me._length = chart.width - me.margins.left - me.margins.right;
              me.height = minSize.height;
            } else {
              me.width = minSize.width;
              me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
            }
          },
          /**
           * Handle margins and padding interactions
           * @private
           */
          handleMargins: function() {
            var me = this;
            if (me.margins) {
              me.margins.left = Math.max(me.paddingLeft, me.margins.left);
              me.margins.top = Math.max(me.paddingTop, me.margins.top);
              me.margins.right = Math.max(me.paddingRight, me.margins.right);
              me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
            }
          },
          afterFit: function() {
            helpers$1.callback(this.options.afterFit, [this]);
          },
          // Shared Methods
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
          getRightValue: function(rawValue) {
            if (isNullOrUndef(rawValue)) {
              return NaN;
            }
            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
              return NaN;
            }
            if (rawValue) {
              if (this.isHorizontal()) {
                if (rawValue.x !== void 0) {
                  return this.getRightValue(rawValue.x);
                }
              } else if (rawValue.y !== void 0) {
                return this.getRightValue(rawValue.y);
              }
            }
            return rawValue;
          },
          _convertTicksToLabels: function(ticks) {
            var me = this;
            var labels, i, ilen;
            me.ticks = ticks.map(function(tick) {
              return tick.value;
            });
            me.beforeTickToLabelConversion();
            labels = me.convertTicksToLabels(ticks) || me.ticks;
            me.afterTickToLabelConversion();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              ticks[i].label = labels[i];
            }
            return labels;
          },
          /**
           * @private
           */
          _getLabelSizes: function() {
            var me = this;
            var labelSizes = me._labelSizes;
            if (!labelSizes) {
              me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
              me.longestLabelWidth = labelSizes.widest.width;
            }
            return labelSizes;
          },
          /**
           * @private
           */
          _parseValue: function(value) {
            var start, end, min2, max2;
            if (isArray2(value)) {
              start = +this.getRightValue(value[0]);
              end = +this.getRightValue(value[1]);
              min2 = Math.min(start, end);
              max2 = Math.max(start, end);
            } else {
              value = +this.getRightValue(value);
              start = void 0;
              end = value;
              min2 = value;
              max2 = value;
            }
            return {
              min: min2,
              max: max2,
              start,
              end
            };
          },
          /**
          * @private
          */
          _getScaleLabel: function(rawValue) {
            var v = this._parseValue(rawValue);
            if (v.start !== void 0) {
              return "[" + v.start + ", " + v.end + "]";
            }
            return +this.getRightValue(rawValue);
          },
          /**
           * Used to get the value to display in the tooltip for the data at the given index
           * @param index
           * @param datasetIndex
           */
          getLabelForIndex: helpers$1.noop,
          /**
           * Returns the location of the given data point. Value can either be an index or a numerical value
           * The coordinate (0, 0) is at the upper-left corner of the canvas
           * @param value
           * @param index
           * @param datasetIndex
           */
          getPixelForValue: helpers$1.noop,
          /**
           * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
           * The coordinate (0, 0) is at the upper-left corner of the canvas
           * @param pixel
           */
          getValueForPixel: helpers$1.noop,
          /**
           * Returns the location of the tick at the given index
           * The coordinate (0, 0) is at the upper-left corner of the canvas
           */
          getPixelForTick: function(index2) {
            var me = this;
            var offset2 = me.options.offset;
            var numTicks = me._ticks.length;
            var tickWidth = 1 / Math.max(numTicks - (offset2 ? 0 : 1), 1);
            return index2 < 0 || index2 > numTicks - 1 ? null : me.getPixelForDecimal(index2 * tickWidth + (offset2 ? tickWidth / 2 : 0));
          },
          /**
           * Utility for getting the pixel location of a percentage of scale
           * The coordinate (0, 0) is at the upper-left corner of the canvas
           */
          getPixelForDecimal: function(decimal) {
            var me = this;
            if (me._reversePixels) {
              decimal = 1 - decimal;
            }
            return me._startPixel + decimal * me._length;
          },
          getDecimalForPixel: function(pixel) {
            var decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          },
          /**
           * Returns the pixel for the minimum chart value
           * The coordinate (0, 0) is at the upper-left corner of the canvas
           */
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me = this;
            var min2 = me.min;
            var max2 = me.max;
            return me.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
          },
          /**
           * Returns a subset of ticks to be plotted to avoid overlapping labels.
           * @private
           */
          _autoSkip: function(ticks) {
            var me = this;
            var tickOpts = me.options.ticks;
            var axisLength = me._length;
            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            var numMajorIndices = majorIndices.length;
            var first = majorIndices[0];
            var last = majorIndices[numMajorIndices - 1];
            var i, ilen, spacing, avgMajorSpacing;
            if (numMajorIndices > ticksLimit) {
              skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
              return nonSkipped(ticks);
            }
            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
            if (numMajorIndices > 0) {
              for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
              }
              avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
              skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
              skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
              return nonSkipped(ticks);
            }
            skip(ticks, spacing);
            return nonSkipped(ticks);
          },
          /**
           * @private
           */
          _tickSize: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            var rot = helpers$1.toRadians(me.labelRotation);
            var cos = Math.abs(Math.cos(rot));
            var sin = Math.abs(Math.sin(rot));
            var labelSizes = me._getLabelSizes();
            var padding = optionTicks.autoSkipPadding || 0;
            var w = labelSizes ? labelSizes.widest.width + padding : 0;
            var h = labelSizes ? labelSizes.highest.height + padding : 0;
            return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          },
          /**
           * @private
           */
          _isVisible: function() {
            var me = this;
            var chart = me.chart;
            var display = me.options.display;
            var i, ilen, meta;
            if (display !== "auto") {
              return !!display;
            }
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                  return true;
                }
              }
            }
            return false;
          },
          /**
           * @private
           */
          _computeGridLineItems: function(chartArea) {
            var me = this;
            var chart = me.chart;
            var options2 = me.options;
            var gridLines = options2.gridLines;
            var position = options2.position;
            var offsetGridLines = gridLines.offsetGridLines;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
            var tl = getTickMarkLength(gridLines);
            var items = [];
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var axisHalfWidth = axisWidth / 2;
            var alignPixel = helpers$1._alignPixel;
            var alignBorderValue = function(pixel) {
              return alignPixel(chart, pixel, axisWidth);
            };
            var borderValue, i, tick, lineValue, alignedLineValue;
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
            if (position === "top") {
              borderValue = alignBorderValue(me.bottom);
              ty1 = me.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(me.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = me.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(me.right);
              tx1 = me.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else {
              borderValue = alignBorderValue(me.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = me.left + tl;
            }
            for (i = 0; i < ticksLength; ++i) {
              tick = ticks[i] || {};
              if (isNullOrUndef(tick.label) && i < ticks.length) {
                continue;
              }
              if (i === me.zeroLineIndex && options2.offset === offsetGridLines) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash || [];
                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
              } else {
                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                borderDash = gridLines.borderDash || [];
                borderDashOffset = gridLines.borderDashOffset || 0;
              }
              lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset
              });
            }
            items.ticksLength = ticksLength;
            items.borderValue = borderValue;
            return items;
          },
          /**
           * @private
           */
          _computeLabelItems: function() {
            var me = this;
            var options2 = me.options;
            var optionTicks = options2.ticks;
            var position = options2.position;
            var isMirrored = optionTicks.mirror;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var fonts = parseTickFontOptions(optionTicks);
            var tickPadding = optionTicks.padding;
            var tl = getTickMarkLength(options2.gridLines);
            var rotation = -helpers$1.toRadians(me.labelRotation);
            var items = [];
            var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            if (position === "top") {
              y = me.bottom - tl - tickPadding;
              textAlign = !rotation ? "center" : "left";
            } else if (position === "bottom") {
              y = me.top + tl + tickPadding;
              textAlign = !rotation ? "center" : "right";
            } else if (position === "left") {
              x = me.right - (isMirrored ? 0 : tl) - tickPadding;
              textAlign = isMirrored ? "left" : "right";
            } else {
              x = me.left + (isMirrored ? 0 : tl) + tickPadding;
              textAlign = isMirrored ? "right" : "left";
            }
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              if (isNullOrUndef(label)) {
                continue;
              }
              pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
              font = tick.major ? fonts.major : fonts.minor;
              lineHeight = font.lineHeight;
              lineCount = isArray2(label) ? label.length : 1;
              if (isHorizontal) {
                x = pixel;
                textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              items.push({
                x,
                y,
                rotation,
                label,
                font,
                textOffset,
                textAlign
              });
            }
            return items;
          },
          /**
           * @private
           */
          _drawGrid: function(chartArea) {
            var me = this;
            var gridLines = me.options.gridLines;
            if (!gridLines.display) {
              return;
            }
            var ctx = me.ctx;
            var chart = me.chart;
            var alignPixel = helpers$1._alignPixel;
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
            var width, color, i, ilen, item;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              width = item.width;
              color = item.color;
              if (width && color) {
                ctx.save();
                ctx.lineWidth = width;
                ctx.strokeStyle = color;
                if (ctx.setLineDash) {
                  ctx.setLineDash(item.borderDash);
                  ctx.lineDashOffset = item.borderDashOffset;
                }
                ctx.beginPath();
                if (gridLines.drawTicks) {
                  ctx.moveTo(item.tx1, item.ty1);
                  ctx.lineTo(item.tx2, item.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  ctx.moveTo(item.x1, item.y1);
                  ctx.lineTo(item.x2, item.y2);
                }
                ctx.stroke();
                ctx.restore();
              }
            }
            if (axisWidth) {
              var firstLineWidth = axisWidth;
              var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
              var borderValue = items.borderValue;
              var x1, x2, y1, y2;
              if (me.isHorizontal()) {
                x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
              } else {
                y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
              }
              ctx.lineWidth = axisWidth;
              ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          },
          /**
           * @private
           */
          _drawLabels: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            var ctx = me.ctx;
            var items = me._labelItems || (me._labelItems = me._computeLabelItems());
            var i, j, ilen, jlen, item, tickFont, label, y;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              tickFont = item.font;
              ctx.save();
              ctx.translate(item.x, item.y);
              ctx.rotate(item.rotation);
              ctx.font = tickFont.string;
              ctx.fillStyle = tickFont.color;
              ctx.textBaseline = "middle";
              ctx.textAlign = item.textAlign;
              label = item.label;
              y = item.textOffset;
              if (isArray2(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  ctx.fillText("" + label[j], 0, y);
                  y += tickFont.lineHeight;
                }
              } else {
                ctx.fillText(label, 0, y);
              }
              ctx.restore();
            }
          },
          /**
           * @private
           */
          _drawTitle: function() {
            var me = this;
            var ctx = me.ctx;
            var options2 = me.options;
            var scaleLabel = options2.scaleLabel;
            if (!scaleLabel.display) {
              return;
            }
            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
            var halfLineHeight = scaleLabelFont.lineHeight / 2;
            var position = options2.position;
            var rotation = 0;
            var scaleLabelX, scaleLabelY;
            if (me.isHorizontal()) {
              scaleLabelX = me.left + me.width / 2;
              scaleLabelY = position === "bottom" ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === "left";
              scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me.top + me.height / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }
            ctx.save();
            ctx.translate(scaleLabelX, scaleLabelY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = scaleLabelFontColor;
            ctx.font = scaleLabelFont.string;
            ctx.fillText(scaleLabel.labelString, 0, 0);
            ctx.restore();
          },
          draw: function(chartArea) {
            var me = this;
            if (!me._isVisible()) {
              return;
            }
            me._drawGrid(chartArea);
            me._drawTitle();
            me._drawLabels();
          },
          /**
           * @private
           */
          _layers: function() {
            var me = this;
            var opts = me.options;
            var tz = opts.ticks && opts.ticks.z || 0;
            var gz = opts.gridLines && opts.gridLines.z || 0;
            if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
              return [{
                z: tz,
                draw: function() {
                  me.draw.apply(me, arguments);
                }
              }];
            }
            return [{
              z: gz,
              draw: function() {
                me._drawGrid.apply(me, arguments);
                me._drawTitle.apply(me, arguments);
              }
            }, {
              z: tz,
              draw: function() {
                me._drawLabels.apply(me, arguments);
              }
            }];
          },
          /**
           * @private
           */
          _getMatchingVisibleMetas: function(type) {
            var me = this;
            var isHorizontal = me.isHorizontal();
            return me.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
              return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
            });
          }
        });
        Scale.prototype._draw = Scale.prototype.draw;
        var core_scale = Scale;
        var isNullOrUndef$1 = helpers$1.isNullOrUndef;
        var defaultConfig = {
          position: "bottom"
        };
        var scale_category = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var labels = me._getLabels();
            var ticksOpts = me.options.ticks;
            var min2 = ticksOpts.min;
            var max2 = ticksOpts.max;
            var minIndex = 0;
            var maxIndex = labels.length - 1;
            var findIndex;
            if (min2 !== void 0) {
              findIndex = labels.indexOf(min2);
              if (findIndex >= 0) {
                minIndex = findIndex;
              }
            }
            if (max2 !== void 0) {
              findIndex = labels.indexOf(max2);
              if (findIndex >= 0) {
                maxIndex = findIndex;
              }
            }
            me.minIndex = minIndex;
            me.maxIndex = maxIndex;
            me.min = labels[minIndex];
            me.max = labels[maxIndex];
          },
          buildTicks: function() {
            var me = this;
            var labels = me._getLabels();
            var minIndex = me.minIndex;
            var maxIndex = me.maxIndex;
            me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me = this;
            var chart = me.chart;
            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
              return me.getRightValue(chart.data.datasets[datasetIndex].data[index2]);
            }
            return me._getLabels()[index2];
          },
          _configure: function() {
            var me = this;
            var offset2 = me.options.offset;
            var ticks = me.ticks;
            core_scale.prototype._configure.call(me);
            if (!me.isHorizontal()) {
              me._reversePixels = !me._reversePixels;
            }
            if (!ticks) {
              return;
            }
            me._startValue = me.minIndex - (offset2 ? 0.5 : 0);
            me._valueRange = Math.max(ticks.length - (offset2 ? 0 : 1), 1);
          },
          // Used to get data value locations.  Value can either be an index or a numerical value
          getPixelForValue: function(value, index2, datasetIndex) {
            var me = this;
            var valueCategory, labels, idx;
            if (!isNullOrUndef$1(index2) && !isNullOrUndef$1(datasetIndex)) {
              value = me.chart.data.datasets[datasetIndex].data[index2];
            }
            if (!isNullOrUndef$1(value)) {
              valueCategory = me.isHorizontal() ? value.x : value.y;
            }
            if (valueCategory !== void 0 || value !== void 0 && isNaN(index2)) {
              labels = me._getLabels();
              value = helpers$1.valueOrDefault(valueCategory, value);
              idx = labels.indexOf(value);
              index2 = idx !== -1 ? idx : index2;
              if (isNaN(index2)) {
                index2 = value;
              }
            }
            return me.getPixelForDecimal((index2 - me._startValue) / me._valueRange);
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticks;
            return index2 < 0 || index2 > ticks.length - 1 ? null : this.getPixelForValue(ticks[index2], index2 + this.minIndex);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
            return Math.min(Math.max(value, 0), me.ticks.length - 1);
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        var _defaults = defaultConfig;
        scale_category._defaults = _defaults;
        var noop = helpers$1.noop;
        var isNullOrUndef$2 = helpers$1.isNullOrUndef;
        function generateTicks(generationOptions, dataRange) {
          var ticks = [];
          var MIN_SPACING = 1e-14;
          var stepSize = generationOptions.stepSize;
          var unit = stepSize || 1;
          var maxNumSpaces = generationOptions.maxTicks - 1;
          var min2 = generationOptions.min;
          var max2 = generationOptions.max;
          var precision = generationOptions.precision;
          var rmin = dataRange.min;
          var rmax = dataRange.max;
          var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
          var factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && isNullOrUndef$2(min2) && isNullOrUndef$2(max2)) {
            return [rmin, rmax];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxNumSpaces) {
            spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
          }
          if (stepSize || isNullOrUndef$2(precision)) {
            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
          } else {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
          if (stepSize) {
            if (!isNullOrUndef$2(min2) && helpers$1.almostWhole(min2 / spacing, spacing / 1e3)) {
              niceMin = min2;
            }
            if (!isNullOrUndef$2(max2) && helpers$1.almostWhole(max2 / spacing, spacing / 1e3)) {
              niceMax = max2;
            }
          }
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          ticks.push(isNullOrUndef$2(min2) ? niceMin : min2);
          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
          }
          ticks.push(isNullOrUndef$2(max2) ? niceMax : max2);
          return ticks;
        }
        var scale_linearbase = core_scale.extend({
          getRightValue: function(value) {
            if (typeof value === "string") {
              return +value;
            }
            return core_scale.prototype.getRightValue.call(this, value);
          },
          handleTickRangeOptions: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers$1.sign(me.min);
              var maxSign = helpers$1.sign(me.max);
              if (minSign < 0 && maxSign < 0) {
                me.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me.min = 0;
              }
            }
            var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
            var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
            if (tickOpts.min !== void 0) {
              me.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me.min === null) {
                me.min = tickOpts.suggestedMin;
              } else {
                me.min = Math.min(me.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me.max === null) {
                me.max = tickOpts.suggestedMax;
              } else {
                me.max = Math.max(me.max, tickOpts.suggestedMax);
              }
            }
            if (setMin !== setMax) {
              if (me.min >= me.max) {
                if (setMin) {
                  me.max = me.min + 1;
                } else {
                  me.min = me.max - 1;
                }
              }
            }
            if (me.min === me.max) {
              me.max++;
              if (!tickOpts.beginAtZero) {
                me.min--;
              }
            }
          },
          getTickLimit: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var stepSize = tickOpts.stepSize;
            var maxTicksLimit = tickOpts.maxTicksLimit;
            var maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
            } else {
              maxTicks = me._computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          },
          _computeTickLimit: function() {
            return Number.POSITIVE_INFINITY;
          },
          handleDirectionalChanges: noop,
          buildTicks: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var maxTicks = me.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              precision: tickOpts.precision,
              stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
            me.handleDirectionalChanges();
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
          },
          convertTicksToLabels: function() {
            var me = this;
            me.ticksAsNumbers = me.ticks.slice();
            me.zeroLineIndex = me.ticks.indexOf(0);
            core_scale.prototype.convertTicksToLabels.call(me);
          },
          _configure: function() {
            var me = this;
            var ticks = me.getTicks();
            var start = me.min;
            var end = me.max;
            var offset2;
            core_scale.prototype._configure.call(me);
            if (me.options.offset && ticks.length) {
              offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset2;
              end += offset2;
            }
            me._startValue = start;
            me._endValue = end;
            me._valueRange = end - start;
          }
        });
        var defaultConfig$1 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.linear
          }
        };
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;
        function getOrCreateStack(stacks, stacked, meta) {
          var key = [
            meta.type,
            // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            stacked === void 0 && meta.stack === void 0 ? meta.index : "",
            meta.stack
          ].join(".");
          if (stacks[key] === void 0) {
            stacks[key] = {
              pos: [],
              neg: []
            };
          }
          return stacks[key];
        }
        function stackData(scale2, stacks, meta, data) {
          var opts = scale2.options;
          var stacked = opts.stacked;
          var stack = getOrCreateStack(stacks, stacked, meta);
          var pos = stack.pos;
          var neg = stack.neg;
          var ilen = data.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            pos[i] = pos[i] || 0;
            neg[i] = neg[i] || 0;
            if (opts.relativePoints) {
              pos[i] = 100;
            } else if (value.min < 0 || value.max < 0) {
              neg[i] += value.min;
            } else {
              pos[i] += value.max;
            }
          }
        }
        function updateMinMax(scale2, meta, data) {
          var ilen = data.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            scale2.min = Math.min(scale2.min, value.min);
            scale2.max = Math.max(scale2.max, value.max);
          }
        }
        var scale_linear = scale_linearbase.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var metasets = me._getMatchingVisibleMetas();
            var hasStacks = opts.stacked;
            var stacks = {};
            var ilen = metasets.length;
            var i, meta, data, values;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            if (hasStacks === void 0) {
              for (i = 0; !hasStacks && i < ilen; ++i) {
                meta = metasets[i];
                hasStacks = meta.stack !== void 0;
              }
            }
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              data = datasets[meta.index].data;
              if (hasStacks) {
                stackData(me, stacks, meta, data);
              } else {
                updateMinMax(me, meta, data);
              }
            }
            helpers$1.each(stacks, function(stackValues) {
              values = stackValues.pos.concat(stackValues.neg);
              me.min = Math.min(me.min, helpers$1.min(values));
              me.max = Math.max(me.max, helpers$1.max(values));
            });
            me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
            me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
            me.handleTickRangeOptions();
          },
          // Returns the maximum number of ticks based on the scale dimension
          _computeTickLimit: function() {
            var me = this;
            var tickFont;
            if (me.isHorizontal()) {
              return Math.ceil(me.width / 40);
            }
            tickFont = helpers$1.options._parseFont(me.options.ticks);
            return Math.ceil(me.height / tickFont.lineHeight);
          },
          // Called after the ticks are built. We need
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          // Utils
          getPixelForValue: function(value) {
            var me = this;
            return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
          },
          getValueForPixel: function(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticksAsNumbers;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          }
        });
        var _defaults$1 = defaultConfig$1;
        scale_linear._defaults = _defaults$1;
        var valueOrDefault$b = helpers$1.valueOrDefault;
        var log10 = helpers$1.math.log10;
        function generateTicks$1(generationOptions, dataRange) {
          var ticks = [];
          var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          var endExp = Math.floor(log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;
          if (tickVal === 0) {
            exp = Math.floor(log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }
          var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push(tickVal);
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
        var defaultConfig$2 = {
          position: "left",
          // label settings
          ticks: {
            callback: core_ticks.formatters.logarithmic
          }
        };
        function nonNegativeOrDefault(value, defaultValue) {
          return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
        }
        var scale_logarithmic = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var isHorizontal = me.isHorizontal();
            function IDMatches(meta2) {
              return isHorizontal ? meta2.xAxisID === me.id : meta2.yAxisID === me.id;
            }
            var datasetIndex, meta, value, data, i, ilen;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            me.minNotZero = Number.POSITIVE_INFINITY;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                  break;
                }
              }
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    var values = valuesPerStack[key];
                    value = me._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    values[i] = values[i] || 0;
                    values[i] += value.max;
                  }
                }
              }
              helpers$1.each(valuesPerStack, function(valuesForType) {
                if (valuesForType.length > 0) {
                  var minVal = helpers$1.min(valuesForType);
                  var maxVal = helpers$1.max(valuesForType);
                  me.min = Math.min(me.min, minVal);
                  me.max = Math.max(me.max, maxVal);
                }
              });
            } else {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    value = me._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    me.min = Math.min(value.min, me.min);
                    me.max = Math.max(value.max, me.max);
                    if (value.min !== 0) {
                      me.minNotZero = Math.min(value.min, me.minNotZero);
                    }
                  }
                }
              }
            }
            me.min = helpers$1.isFinite(me.min) ? me.min : null;
            me.max = helpers$1.isFinite(me.max) ? me.max : null;
            me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
            this.handleTickRangeOptions();
          },
          handleTickRangeOptions: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var DEFAULT_MIN2 = 1;
            var DEFAULT_MAX2 = 10;
            me.min = nonNegativeOrDefault(tickOpts.min, me.min);
            me.max = nonNegativeOrDefault(tickOpts.max, me.max);
            if (me.min === me.max) {
              if (me.min !== 0 && me.min !== null) {
                me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
              } else {
                me.min = DEFAULT_MIN2;
                me.max = DEFAULT_MAX2;
              }
            }
            if (me.min === null) {
              me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
            }
            if (me.max === null) {
              me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX2;
            }
            if (me.minNotZero === null) {
              if (me.min > 0) {
                me.minNotZero = me.min;
              } else if (me.max < 1) {
                me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
              } else {
                me.minNotZero = DEFAULT_MIN2;
              }
            }
          },
          buildTicks: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var reverse = !me.isHorizontal();
            var generationOptions = {
              min: nonNegativeOrDefault(tickOpts.min),
              max: nonNegativeOrDefault(tickOpts.max)
            };
            var ticks = me.ticks = generateTicks$1(generationOptions, me);
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              reverse = !reverse;
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
            if (reverse) {
              ticks.reverse();
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            core_scale.prototype.convertTicksToLabels.call(this);
          },
          // Get the correct tooltip label
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          getPixelForTick: function(index2) {
            var ticks = this.tickValues;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          },
          /**
           * Returns the value of the first tick.
           * @param {number} value - The minimum not zero value.
           * @return {number} The first tick value.
           * @private
           */
          _getFirstTickValue: function(value) {
            var exp = Math.floor(log10(value));
            var significand = Math.floor(value / Math.pow(10, exp));
            return significand * Math.pow(10, exp);
          },
          _configure: function() {
            var me = this;
            var start = me.min;
            var offset2 = 0;
            core_scale.prototype._configure.call(me);
            if (start === 0) {
              start = me._getFirstTickValue(me.minNotZero);
              offset2 = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
            }
            me._startValue = log10(start);
            me._valueOffset = offset2;
            me._valueRange = (log10(me.max) - log10(start)) / (1 - offset2);
          },
          getPixelForValue: function(value) {
            var me = this;
            var decimal = 0;
            value = +me.getRightValue(value);
            if (value > me.min && value > 0) {
              decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
            }
            return me.getPixelForDecimal(decimal);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var decimal = me.getDecimalForPixel(pixel);
            return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
          }
        });
        var _defaults$2 = defaultConfig$2;
        scale_logarithmic._defaults = _defaults$2;
        var valueOrDefault$c = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
        var resolve$4 = helpers$1.options.resolve;
        var defaultConfig$3 = {
          display: true,
          // Boolean - Whether to animate scaling the chart from the centre
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          gridLines: {
            circular: false
          },
          // label settings
          ticks: {
            // Boolean - Show a backdrop to the scale label
            showLabelBackdrop: true,
            // String - The colour of the label backdrop
            backdropColor: "rgba(255,255,255,0.75)",
            // Number - The backdrop padding above & below the label in pixels
            backdropPaddingY: 2,
            // Number - The backdrop padding to the side of the label in pixels
            backdropPaddingX: 2,
            callback: core_ticks.formatters.linear
          },
          pointLabels: {
            // Boolean - if true, show point labels
            display: true,
            // Number - Point label font size in pixels
            fontSize: 10,
            // Function - Used to convert point labels
            callback: function(label) {
              return label;
            }
          }
        };
        function getTickBackdropHeight(opts) {
          var tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
          }
          return 0;
        }
        function measureLabelSize(ctx, lineHeight, label) {
          if (helpers$1.isArray(label)) {
            return {
              w: helpers$1.longestText(ctx, ctx.font, label),
              h: label.length * lineHeight
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: lineHeight
          };
        }
        function determineLimits(angle, pos, size, min2, max2) {
          if (angle === min2 || angle === max2) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min2 || angle > max2) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale2) {
          var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
          var furthestLimits = {
            l: 0,
            r: scale2.width,
            t: 0,
            b: scale2.height - scale2.paddingTop
          };
          var furthestAngles = {};
          var i, textSize, pointPosition;
          scale2.ctx.font = plFont.string;
          scale2._pointLabelSizes = [];
          var valueCount = scale2.chart.data.labels.length;
          for (i = 0; i < valueCount; i++) {
            pointPosition = scale2.getPointPosition(i, scale2.drawingArea + 5);
            textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i]);
            scale2._pointLabelSizes[i] = textSize;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text, position, lineHeight) {
          var y = position.y + lineHeight / 2;
          var i, ilen;
          if (helpers$1.isArray(text)) {
            for (i = 0, ilen = text.length; i < ilen; ++i) {
              ctx.fillText(text[i], position.x, y);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, position.x, y);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale2) {
          var ctx = scale2.ctx;
          var opts = scale2.options;
          var pointLabelOpts = opts.pointLabels;
          var tickBackdropHeight = getTickBackdropHeight(opts);
          var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
          var plFont = helpers$1.options._parseFont(pointLabelOpts);
          ctx.save();
          ctx.font = plFont.string;
          ctx.textBaseline = "middle";
          for (var i = scale2.chart.data.labels.length - 1; i >= 0; i--) {
            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale2.getPointPosition(i, outerDistance + extra + 5);
            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale2.pointLabels[i], pointLabelPosition, plFont.lineHeight);
          }
          ctx.restore();
        }
        function drawRadiusLine(scale2, gridLineOpts, radius, index2) {
          var ctx = scale2.ctx;
          var circular = gridLineOpts.circular;
          var valueCount = scale2.chart.data.labels.length;
          var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index2 - 1);
          var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index2 - 1);
          var pointPosition;
          if (!circular && !valueCount || !lineColor || !lineWidth) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          if (ctx.setLineDash) {
            ctx.setLineDash(gridLineOpts.borderDash || []);
            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
          }
          ctx.beginPath();
          if (circular) {
            ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
          } else {
            pointPosition = scale2.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i = 1; i < valueCount; i++) {
              pointPosition = scale2.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function numberOrZero(param) {
          return helpers$1.isNumber(param) ? param : 0;
        }
        var scale_radialLinear = scale_linearbase.extend({
          setDimensions: function() {
            var me = this;
            me.width = me.maxWidth;
            me.height = me.maxHeight;
            me.paddingTop = getTickBackdropHeight(me.options) / 2;
            me.xCenter = Math.floor(me.width / 2);
            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var min2 = Number.POSITIVE_INFINITY;
            var max2 = Number.NEGATIVE_INFINITY;
            helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers$1.each(dataset.data, function(rawValue, index2) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index2].hidden) {
                    return;
                  }
                  min2 = Math.min(value, min2);
                  max2 = Math.max(value, max2);
                });
              }
            });
            me.min = min2 === Number.POSITIVE_INFINITY ? 0 : min2;
            me.max = max2 === Number.NEGATIVE_INFINITY ? 0 : max2;
            me.handleTickRangeOptions();
          },
          // Returns the maximum number of ticks based on the scale dimension
          _computeTickLimit: function() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          },
          convertTicksToLabels: function() {
            var me = this;
            scale_linearbase.prototype.convertTicksToLabels.call(me);
            me.pointLabels = me.chart.data.labels.map(function() {
              var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
              return label || label === 0 ? label : "";
            });
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          fit: function() {
            var me = this;
            var opts = me.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(me);
            } else {
              me.setCenterPoint(0, 0, 0, 0);
            }
          },
          /**
           * Set radius reductions and determine new radius and center point
           * @private
           */
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me.drawingArea = Math.min(
              Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
              Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)
            );
            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me = this;
            var maxRight = me.width - rightMovement - me.drawingArea;
            var maxLeft = leftMovement + me.drawingArea;
            var maxTop = topMovement + me.drawingArea;
            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
          },
          getIndexAngle: function(index2) {
            var chart = this.chart;
            var angleMultiplier = 360 / chart.data.labels.length;
            var options2 = chart.options || {};
            var startAngle = options2.startAngle || 0;
            var angle = (index2 * angleMultiplier + startAngle) % 360;
            return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
          },
          getDistanceFromCenterForValue: function(value) {
            var me = this;
            if (helpers$1.isNullOrUndef(value)) {
              return NaN;
            }
            var scalingFactor = me.drawingArea / (me.max - me.min);
            if (me.options.ticks.reverse) {
              return (me.max - value) * scalingFactor;
            }
            return (value - me.min) * scalingFactor;
          },
          getPointPosition: function(index2, distanceFromCenter) {
            var me = this;
            var thisAngle = me.getIndexAngle(index2) - Math.PI / 2;
            return {
              x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
              y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
            };
          },
          getPointPositionForValue: function(index2, value) {
            return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
          },
          getBasePosition: function(index2) {
            var me = this;
            var min2 = me.min;
            var max2 = me.max;
            return me.getPointPositionForValue(
              index2 || 0,
              me.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0
            );
          },
          /**
           * @private
           */
          _drawGrid: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var gridLineOpts = opts.gridLines;
            var angleLineOpts = opts.angleLines;
            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
            var i, offset2, position;
            if (opts.pointLabels.display) {
              drawPointLabels(me);
            }
            if (gridLineOpts.display) {
              helpers$1.each(me.ticks, function(label, index2) {
                if (index2 !== 0) {
                  offset2 = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index2]);
                  drawRadiusLine(me, gridLineOpts, offset2, index2);
                }
              });
            }
            if (angleLineOpts.display && lineWidth && lineColor) {
              ctx.save();
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = lineColor;
              if (ctx.setLineDash) {
                ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
              }
              for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                offset2 = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                position = me.getPointPosition(i, offset2);
                ctx.beginPath();
                ctx.moveTo(me.xCenter, me.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          },
          /**
           * @private
           */
          _drawLabels: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            var startAngle = me.getIndexAngle(0);
            var tickFont = helpers$1.options._parseFont(tickOpts);
            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
            var offset2, width;
            ctx.save();
            ctx.font = tickFont.string;
            ctx.translate(me.xCenter, me.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            helpers$1.each(me.ticks, function(label, index2) {
              if (index2 === 0 && !tickOpts.reverse) {
                return;
              }
              offset2 = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index2]);
              if (tickOpts.showLabelBackdrop) {
                width = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(
                  -width / 2 - tickOpts.backdropPaddingX,
                  -offset2 - tickFont.size / 2 - tickOpts.backdropPaddingY,
                  width + tickOpts.backdropPaddingX * 2,
                  tickFont.size + tickOpts.backdropPaddingY * 2
                );
              }
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -offset2);
            });
            ctx.restore();
          },
          /**
           * @private
           */
          _drawTitle: helpers$1.noop
        });
        var _defaults$3 = defaultConfig$3;
        scale_radialLinear._defaults = _defaults$3;
        var deprecated$1 = helpers$1._deprecated;
        var resolve$5 = helpers$1.options.resolve;
        var valueOrDefault$d = helpers$1.valueOrDefault;
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1e3
          },
          second: {
            common: true,
            size: 1e3,
            steps: 60
          },
          minute: {
            common: true,
            size: 6e4,
            steps: 60
          },
          hour: {
            common: true,
            size: 36e5,
            steps: 24
          },
          day: {
            common: true,
            size: 864e5,
            steps: 30
          },
          week: {
            common: false,
            size: 6048e5,
            steps: 4
          },
          month: {
            common: true,
            size: 2628e6,
            steps: 12
          },
          quarter: {
            common: false,
            size: 7884e6,
            steps: 4
          },
          year: {
            common: true,
            size: 3154e7
          }
        };
        var UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function arrayUnique(items) {
          var hash = {};
          var out = [];
          var i, ilen, item;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            if (!hash[item]) {
              hash[item] = true;
              out.push(item);
            }
          }
          return out;
        }
        function getMin(options2) {
          return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
        }
        function getMax(options2) {
          return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
        }
        function buildLookupTable(timestamps, min2, max2, distribution) {
          if (distribution === "linear" || !timestamps.length) {
            return [
              { time: min2, pos: 0 },
              { time: max2, pos: 1 }
            ];
          }
          var table = [];
          var items = [min2];
          var i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr > min2 && curr < max2) {
              items.push(curr);
            }
          }
          items.push(max2);
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i / (ilen - 1) });
            }
          }
          return table;
        }
        function lookup(table, key, value) {
          var lo = 0;
          var hi = table.length - 1;
          var mid, i0, i1;
          while (lo >= 0 && lo <= hi) {
            mid = lo + hi >> 1;
            i0 = table[mid - 1] || null;
            i1 = table[mid];
            if (!i0) {
              return { lo: null, hi: i1 };
            } else if (i1[key] < value) {
              lo = mid + 1;
            } else if (i0[key] > value) {
              hi = mid - 1;
            } else {
              return { lo: i0, hi: i1 };
            }
          }
          return { lo: i1, hi: null };
        }
        function interpolate$1(table, skey, sval, tkey) {
          var range = lookup(table, skey, sval);
          var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
          var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
          var span = next[skey] - prev[skey];
          var ratio = span ? (sval - prev[skey]) / span : 0;
          var offset2 = (next[tkey] - prev[tkey]) * ratio;
          return prev[tkey] + offset2;
        }
        function toTimestamp(scale2, input) {
          var adapter = scale2._adapter;
          var options2 = scale2.options.time;
          var parser = options2.parser;
          var format2 = parser || options2.format;
          var value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!helpers$1.isFinite(value)) {
            value = typeof format2 === "string" ? adapter.parse(value, format2) : adapter.parse(value);
          }
          if (value !== null) {
            return +value;
          }
          if (!parser && typeof format2 === "function") {
            value = format2(input);
            if (!helpers$1.isFinite(value)) {
              value = adapter.parse(value);
            }
          }
          return value;
        }
        function parse(scale2, input) {
          if (helpers$1.isNullOrUndef(input)) {
            return null;
          }
          var options2 = scale2.options.time;
          var value = toTimestamp(scale2, scale2.getRightValue(input));
          if (value === null) {
            return value;
          }
          if (options2.round) {
            value = +scale2._adapter.startOf(value, options2.round);
          }
          return value;
        }
        function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
          var ilen = UNITS.length;
          var i, interval, factor;
          for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            interval = INTERVALS[UNITS[i]];
            factor = interval.steps ? interval.steps : MAX_INTEGER;
            if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale2, numTicks, minUnit, min2, max2) {
          var i, unit;
          for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            unit = UNITS[i];
            if (INTERVALS[unit].common && scale2._adapter.diff(max2, min2, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function generate(scale2, min2, max2, capacity) {
          var adapter = scale2._adapter;
          var options2 = scale2.options;
          var timeOpts = options2.time;
          var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, capacity);
          var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
          var weekday = minor === "week" ? timeOpts.isoWeekday : false;
          var first = min2;
          var ticks = [];
          var time;
          if (weekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, weekday ? "day" : minor);
          if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
            throw min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor;
          }
          for (time = first; time < max2; time = +adapter.add(time, stepSize, minor)) {
            ticks.push(time);
          }
          if (time === max2 || options2.bounds === "ticks") {
            ticks.push(time);
          }
          return ticks;
        }
        function computeOffsets(table, ticks, min2, max2, options2) {
          var start = 0;
          var end = 0;
          var first, last;
          if (options2.offset && ticks.length) {
            first = interpolate$1(table, "time", ticks[0], "pos");
            if (ticks.length === 1) {
              start = 1 - first;
            } else {
              start = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
            }
            last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
            if (ticks.length === 1) {
              end = last;
            } else {
              end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
            }
          }
          return { start, end, factor: 1 / (start + 1 + end) };
        }
        function setMajorTicks(scale2, ticks, map2, majorUnit) {
          var adapter = scale2._adapter;
          var first = +adapter.startOf(ticks[0].value, majorUnit);
          var last = ticks[ticks.length - 1].value;
          var major, index2;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index2 = map2[major];
            if (index2 >= 0) {
              ticks[index2].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale2, values, majorUnit) {
          var ticks = [];
          var map2 = {};
          var ilen = values.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map2, majorUnit);
        }
        var defaultConfig$4 = {
          position: "bottom",
          /**
           * Data distribution along the scale:
           * - 'linear': data are spread according to their time (distances can vary),
           * - 'series': data are spread at the same distance from each other.
           * @see https://github.com/chartjs/Chart.js/pull/4507
           * @since 2.7.0
           */
          distribution: "linear",
          /**
           * Scale boundary strategy (bypassed by min/max time options)
           * - `data`: make sure data are fully visible, ticks outside are removed
           * - `ticks`: make sure ticks are fully visible, data outside are truncated
           * @see https://github.com/chartjs/Chart.js/pull/4556
           * @since 2.7.0
           */
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
            unit: false,
            // false == automatic or override with week, month, year, etc.
            round: false,
            // none, or override with week, month, year, etc.
            displayFormat: false,
            // DEPRECATED
            isoWeekday: false,
            // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            autoSkip: false,
            /**
             * Ticks generation input values:
             * - 'auto': generates "optimal" ticks based on scale size and time options.
             * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
             * - 'labels': generates ticks from user given `data.labels` values ONLY.
             * @see https://github.com/chartjs/Chart.js/pull/4507
             * @since 2.7.0
             */
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        var scale_time = core_scale.extend({
          initialize: function() {
            this.mergeTicksOptions();
            core_scale.prototype.initialize.call(this);
          },
          update: function() {
            var me = this;
            var options2 = me.options;
            var time = options2.time || (options2.time = {});
            var adapter = me._adapter = new core_adapters._date(options2.adapters.date);
            deprecated$1("time scale", time.format, "time.format", "time.parser");
            deprecated$1("time scale", time.min, "time.min", "ticks.min");
            deprecated$1("time scale", time.max, "time.max", "ticks.max");
            helpers$1.mergeIf(time.displayFormats, adapter.formats());
            return core_scale.prototype.update.apply(me, arguments);
          },
          /**
           * Allows data to be referenced via 't' attribute
           */
          getRightValue: function(rawValue) {
            if (rawValue && rawValue.t !== void 0) {
              rawValue = rawValue.t;
            }
            return core_scale.prototype.getRightValue.call(this, rawValue);
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var adapter = me._adapter;
            var options2 = me.options;
            var unit = options2.time.unit || "day";
            var min2 = MAX_INTEGER;
            var max2 = MIN_INTEGER;
            var timestamps = [];
            var datasets = [];
            var labels = [];
            var i, j, ilen, jlen, data, timestamp, labelsAdded;
            var dataLabels = me._getLabels();
            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
              labels.push(parse(me, dataLabels[i]));
            }
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                data = chart.data.datasets[i].data;
                if (helpers$1.isObject(data[0])) {
                  datasets[i] = [];
                  for (j = 0, jlen = data.length; j < jlen; ++j) {
                    timestamp = parse(me, data[j]);
                    timestamps.push(timestamp);
                    datasets[i][j] = timestamp;
                  }
                } else {
                  datasets[i] = labels.slice(0);
                  if (!labelsAdded) {
                    timestamps = timestamps.concat(labels);
                    labelsAdded = true;
                  }
                }
              } else {
                datasets[i] = [];
              }
            }
            if (labels.length) {
              min2 = Math.min(min2, labels[0]);
              max2 = Math.max(max2, labels[labels.length - 1]);
            }
            if (timestamps.length) {
              timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
              min2 = Math.min(min2, timestamps[0]);
              max2 = Math.max(max2, timestamps[timestamps.length - 1]);
            }
            min2 = parse(me, getMin(options2)) || min2;
            max2 = parse(me, getMax(options2)) || max2;
            min2 = min2 === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min2;
            max2 = max2 === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max2;
            me.min = Math.min(min2, max2);
            me.max = Math.max(min2 + 1, max2);
            me._table = [];
            me._timestamps = {
              data: timestamps,
              datasets,
              labels
            };
          },
          buildTicks: function() {
            var me = this;
            var min2 = me.min;
            var max2 = me.max;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var timeOpts = options2.time;
            var timestamps = me._timestamps;
            var ticks = [];
            var capacity = me.getLabelCapacity(min2);
            var source = tickOpts.source;
            var distribution = options2.distribution;
            var i, ilen, timestamp;
            if (source === "data" || source === "auto" && distribution === "series") {
              timestamps = timestamps.data;
            } else if (source === "labels") {
              timestamps = timestamps.labels;
            } else {
              timestamps = generate(me, min2, max2, capacity);
            }
            if (options2.bounds === "ticks" && timestamps.length) {
              min2 = timestamps[0];
              max2 = timestamps[timestamps.length - 1];
            }
            min2 = parse(me, getMin(options2)) || min2;
            max2 = parse(me, getMax(options2)) || max2;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              timestamp = timestamps[i];
              if (timestamp >= min2 && timestamp <= max2) {
                ticks.push(timestamp);
              }
            }
            me.min = min2;
            me.max = max2;
            me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
            me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
            me._table = buildLookupTable(me._timestamps.data, min2, max2, distribution);
            me._offsets = computeOffsets(me._table, ticks, min2, max2, options2);
            if (tickOpts.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(me, ticks, me._majorUnit);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me = this;
            var adapter = me._adapter;
            var data = me.chart.data;
            var timeOpts = me.options.time;
            var label = data.labels && index2 < data.labels.length ? data.labels[index2] : "";
            var value = data.datasets[datasetIndex].data[index2];
            if (helpers$1.isObject(value)) {
              label = me.getRightValue(value);
            }
            if (timeOpts.tooltipFormat) {
              return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
            }
            if (typeof label === "string") {
              return label;
            }
            return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
          },
          /**
           * Function to format an individual tick mark
           * @private
           */
          tickFormatFunction: function(time, index2, ticks, format2) {
            var me = this;
            var adapter = me._adapter;
            var options2 = me.options;
            var formats = options2.time.displayFormats;
            var minorFormat = formats[me._unit];
            var majorUnit = me._majorUnit;
            var majorFormat = formats[majorUnit];
            var tick = ticks[index2];
            var tickOpts = options2.ticks;
            var major = majorUnit && majorFormat && tick && tick.major;
            var label = adapter.format(time, format2 ? format2 : major ? majorFormat : minorFormat);
            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
            var formatter = resolve$5([
              nestedTickOpts.callback,
              nestedTickOpts.userCallback,
              tickOpts.callback,
              tickOpts.userCallback
            ]);
            return formatter ? formatter(label, index2, ticks) : label;
          },
          convertTicksToLabels: function(ticks) {
            var labels = [];
            var i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
            }
            return labels;
          },
          /**
           * @private
           */
          getPixelForOffset: function(time) {
            var me = this;
            var offsets = me._offsets;
            var pos = interpolate$1(me._table, "time", time, "pos");
            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          },
          getPixelForValue: function(value, index2, datasetIndex) {
            var me = this;
            var time = null;
            if (index2 !== void 0 && datasetIndex !== void 0) {
              time = me._timestamps.datasets[datasetIndex][index2];
            }
            if (time === null) {
              time = parse(me, value);
            }
            if (time !== null) {
              return me.getPixelForOffset(time);
            }
          },
          getPixelForTick: function(index2) {
            var ticks = this.getTicks();
            return index2 >= 0 && index2 < ticks.length ? this.getPixelForOffset(ticks[index2].value) : null;
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var offsets = me._offsets;
            var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            var time = interpolate$1(me._table, "pos", pos, "time");
            return me._adapter._create(time);
          },
          /**
           * @private
           */
          _getLabelSize: function(label) {
            var me = this;
            var ticksOpts = me.options.ticks;
            var tickLabelWidth = me.ctx.measureText(label).width;
            var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            var cosRotation = Math.cos(angle);
            var sinRotation = Math.sin(angle);
            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          },
          /**
           * Crude approximation of what the label width might be
           * @private
           */
          getLabelWidth: function(label) {
            return this._getLabelSize(label).w;
          },
          /**
           * @private
           */
          getLabelCapacity: function(exampleTime) {
            var me = this;
            var timeOpts = me.options.time;
            var displayFormats = timeOpts.displayFormats;
            var format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format2);
            var size = me._getLabelSize(exampleLabel);
            var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
            if (me.options.offset) {
              capacity--;
            }
            return capacity > 0 ? capacity : 1;
          }
        });
        var _defaults$4 = defaultConfig$4;
        scale_time._defaults = _defaults$4;
        var scales = {
          category: scale_category,
          linear: scale_linear,
          logarithmic: scale_logarithmic,
          radialLinear: scale_radialLinear,
          time: scale_time
        };
        var FORMATS = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        core_adapters._date.override(typeof moment2 === "function" ? {
          _id: "moment",
          // DEBUG ONLY
          formats: function() {
            return FORMATS;
          },
          parse: function(value, format2) {
            if (typeof value === "string" && typeof format2 === "string") {
              value = moment2(value, format2);
            } else if (!(value instanceof moment2)) {
              value = moment2(value);
            }
            return value.isValid() ? value.valueOf() : null;
          },
          format: function(time, format2) {
            return moment2(time).format(format2);
          },
          add: function(time, amount, unit) {
            return moment2(time).add(amount, unit).valueOf();
          },
          diff: function(max2, min2, unit) {
            return moment2(max2).diff(moment2(min2), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment2(time);
            if (unit === "isoWeek") {
              return time.isoWeekday(weekday).valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment2(time).endOf(unit).valueOf();
          },
          // DEPRECATIONS
          /**
           * Provided for backward compatibility with scale.getValueForPixel().
           * @deprecated since version 2.8.0
           * @todo remove at version 3
           * @private
           */
          _create: function(time) {
            return moment2(time);
          }
        } : {});
        core_defaults._set("global", {
          plugins: {
            filler: {
              propagate: true
            }
          }
        });
        var mappers = {
          dataset: function(source) {
            var index2 = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index2);
            var visible = meta && chart.isDatasetVisible(index2);
            var points = visible && meta.dataset._children || [];
            var length = points.length || 0;
            return !length ? null : function(point, i) {
              return i < length && points[i]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x = boundary ? boundary.x : null;
            var y = boundary ? boundary.y : null;
            if (helpers$1.isArray(boundary)) {
              return function(point, i) {
                return boundary[i];
              };
            }
            return function(point) {
              return {
                x: x === null ? point.x : x,
                y: y === null ? point.y : y
              };
            };
          }
        };
        function decodeFill(el, index2, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index2 + target;
            }
            if (target === index2 || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeLinearBoundary(source) {
          var model = source.el._model || {};
          var scale2 = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale2.getBasePixel) {
            target = scale2.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (helpers$1.isFinite(target)) {
              horizontal = scale2.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function computeCircularBoundary(source) {
          var scale2 = source.el._scale;
          var options2 = scale2.options;
          var length = scale2.chart.data.labels.length;
          var fill = source.fill;
          var target = [];
          var start, end, center, i, point;
          if (!length) {
            return null;
          }
          start = options2.ticks.reverse ? scale2.max : scale2.min;
          end = options2.ticks.reverse ? scale2.min : scale2.max;
          center = scale2.getPointPositionForValue(0, start);
          for (i = 0; i < length; ++i) {
            point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i, fill === "start" ? start : end) : scale2.getBasePosition(i);
            if (options2.gridLines.circular) {
              point.cx = center.x;
              point.cy = center.y;
              point.angle = scale2.getIndexAngle(i) - Math.PI / 2;
            }
            target.push(point);
          }
          return target;
        }
        function computeBoundary(source) {
          var scale2 = source.el._scale || {};
          if (scale2.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function resolveTarget(sources, index2, propagate) {
          var source = sources[index2];
          var fill = source.fill;
          var visited = [index2];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i, cx, cy, r;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i = 1; i < len0; ++i) {
            helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
          }
          if (curve1[0].angle !== void 0) {
            cx = curve1[0].cx;
            cy = curve1[0].cy;
            r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
            for (i = len1 - 1; i > 0; --i) {
              ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
            }
            return;
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i = len1 - 1; i > 0; --i) {
            helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i, ilen, index2, p0, p1, d0, d1, loopOffset;
          ctx.beginPath();
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i % count;
            p0 = points[index2]._view;
            p1 = mapper(p0, index2, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (loop && loopOffset === void 0 && d0) {
              loopOffset = i + 1;
              ilen = count + loopOffset;
            }
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        var plugin_filler = {
          id: "filler",
          afterDatasetsUpdate: function(chart, options2) {
            var count = (chart.data.datasets || []).length;
            var propagate = options2.propagate;
            var sources = [];
            var meta, i, el, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  fill: decodeFill(el, i, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetsDraw: function(chart) {
            var metasets = chart._getSortedVisibleDatasetMetas();
            var ctx = chart.ctx;
            var meta, i, el, view, points, mapper, color;
            for (i = metasets.length - 1; i >= 0; --i) {
              meta = metasets[i].$filler;
              if (!meta || !meta.visible) {
                continue;
              }
              el = meta.el;
              view = el._view;
              points = el._children || [];
              mapper = meta.mapper;
              color = view.backgroundColor || core_defaults.global.defaultColor;
              if (mapper && color && points.length) {
                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                doFill(ctx, points, mapper, view, color, el._loop);
                helpers$1.canvas.unclipArea(ctx);
              }
            }
          }
        };
        var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
        var noop$1 = helpers$1.noop;
        var valueOrDefault$e = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          legend: {
            display: true,
            position: "top",
            align: "center",
            fullWidth: true,
            reverse: false,
            weight: 1e3,
            // a callback that will handle
            onClick: function(e, legendItem) {
              var index2 = legendItem.datasetIndex;
              var ci = this.chart;
              var meta = ci.getDatasetMeta(index2);
              meta.hidden = meta.hidden === null ? !ci.data.datasets[index2].hidden : null;
              ci.update();
            },
            onHover: null,
            onLeave: null,
            labels: {
              boxWidth: 40,
              padding: 10,
              // Generates labels shown in the legend
              // Valid properties to return:
              // text : text to display
              // fillStyle : fill of coloured box
              // strokeStyle: stroke of coloured box
              // hidden : if this legend item refers to a hidden item
              // lineCap : cap style for line
              // lineDash
              // lineDashOffset :
              // lineJoin :
              // lineWidth :
              generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var options2 = chart.options.legend || {};
                var usePointStyle = options2.labels && options2.labels.usePointStyle;
                return chart._getSortedDatasetMetas().map(function(meta) {
                  var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    hidden: !chart.isDatasetVisible(meta.index),
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    pointStyle: style.pointStyle,
                    rotation: style.rotation,
                    // Below is extra data used for toggling the datasets
                    datasetIndex: meta.index
                  };
                }, this);
              }
            }
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var datasets = chart.data.datasets;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              listItem = list.appendChild(document.createElement("li"));
              listItemSpan = listItem.appendChild(document.createElement("span"));
              listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
              if (datasets[i].label) {
                listItem.appendChild(document.createTextNode(datasets[i].label));
              }
            }
            return list.outerHTML;
          }
        });
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
        }
        var Legend = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
            me._hoveredItem = null;
            me.doughnutMode = false;
          },
          // These methods are ordered by lifecycle. Utilities then follow.
          // Any function defined here is inherited by all legend types.
          // Any function can be extended by the legend type
          beforeUpdate: noop$1,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$1,
          //
          beforeSetDimensions: noop$1,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$1,
          //
          beforeBuildLabels: noop$1,
          buildLabels: function() {
            var me = this;
            var labelOpts = me.options.labels || {};
            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item) {
                return labelOpts.filter(item, me.chart.data);
              });
            }
            if (me.options.reverse) {
              legendItems.reverse();
            }
            me.legendItems = legendItems;
          },
          afterBuildLabels: noop$1,
          //
          beforeFit: noop$1,
          fit: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me.ctx;
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var hitboxes = me.legendHitBoxes = [];
            var minSize = me.minSize;
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me.maxHeight;
            }
            if (!display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            ctx.font = labelFont.string;
            if (isHorizontal) {
              var lineWidths = me.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = "left";
              ctx.textBaseline = "middle";
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                }
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var columnHeights = me.columnHeights = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  columnHeights.push(currentColHeight);
                  currentColWidth = 0;
                  currentColHeight = 0;
                }
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += fontSize + vPadding;
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              minSize.width += totalWidth;
            }
            me.width = minSize.width;
            me.height = minSize.height;
          },
          afterFit: noop$1,
          // Shared Methods
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          // Actually draw the legend on the canvas
          draw: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me.height;
            var columnHeights = me.columnHeights;
            var legendWidth = me.width;
            var lineWidths = me.lineWidths;
            if (!opts.display) {
              return;
            }
            var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
            var ctx = me.ctx;
            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            ctx.fillStyle = fontColor;
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes;
            var drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              }
              ctx.save();
              var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
              ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
              if (ctx.setLineDash) {
                ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
              }
              if (labelOpts && labelOpts.usePointStyle) {
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                var centerY = y + fontSize / 2;
                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
              } else {
                ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                if (lineWidth !== 0) {
                  ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                }
              }
              ctx.restore();
            };
            var fillText2 = function(x, y, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
              var yMiddle = y + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);
              if (legendItem.hidden) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                ctx.stroke();
              }
            };
            var alignmentOffset = function(dimension, blockSize) {
              switch (opts.align) {
                case "start":
                  return labelOpts.padding;
                case "end":
                  return dimension - blockSize;
                default:
                  return (dimension - blockSize + labelOpts.padding) / 2;
              }
            };
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                y: me.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                line: 0
              };
            }
            helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me.legendItems, function(legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width = boxWidth + fontSize / 2 + textWidth;
              var x = cursor.x;
              var y = cursor.y;
              rtlHelper.setWidth(me.minSize.width);
              if (isHorizontal) {
                if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                cursor.line++;
                y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
              }
              var realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
              hitboxes[i].top = y;
              fillText2(realX, y, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
            helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
          },
          /**
           * @private
           */
          _getLegendItemAt: function(x, y) {
            var me = this;
            var i, hitBox, lh;
            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
              lh = me.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                  return me.legendItems[i];
                }
              }
            }
            return null;
          },
          /**
           * Handle an event
           * @private
           * @param {IEvent} event - The event to handle
           */
          handleEvent: function(e) {
            var me = this;
            var opts = me.options;
            var type = e.type === "mouseup" ? "click" : e.type;
            var hoveredItem;
            if (type === "mousemove") {
              if (!opts.onHover && !opts.onLeave) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            hoveredItem = me._getLegendItemAt(e.x, e.y);
            if (type === "click") {
              if (hoveredItem && opts.onClick) {
                opts.onClick.call(me, e.native, hoveredItem);
              }
            } else {
              if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                if (me._hoveredItem) {
                  opts.onLeave.call(me, e.native, me._hoveredItem);
                }
                me._hoveredItem = hoveredItem;
              }
              if (opts.onHover && hoveredItem) {
                opts.onHover.call(me, e.native, hoveredItem);
              }
            }
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend2 = new Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          core_layouts.configure(chart, legend2, legendOpts);
          core_layouts.addBox(chart, legend2);
          chart.legend = legend2;
        }
        var plugin_legend = {
          id: "legend",
          /**
           * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
           * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
           * the plugin, which one will be re-exposed in the chart.js file.
           * https://github.com/chartjs/Chart.js/pull/2640
           * @private
           */
          _element: Legend,
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend2 = chart.legend;
            if (legendOpts) {
              helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
              if (legend2) {
                core_layouts.configure(chart, legend2, legendOpts);
                legend2.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend2) {
              core_layouts.removeBox(chart, legend2);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e) {
            var legend2 = chart.legend;
            if (legend2) {
              legend2.handleEvent(e);
            }
          }
        };
        var noop$2 = helpers$1.noop;
        core_defaults._set("global", {
          title: {
            display: false,
            fontStyle: "bold",
            fullWidth: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
            // by default greater than legend (1000) to be above
          }
        });
        var Title = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
          },
          // These methods are ordered by lifecycle. Utilities then follow.
          beforeUpdate: noop$2,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$2,
          //
          beforeSetDimensions: noop$2,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$2,
          //
          beforeBuildLabels: noop$2,
          buildLabels: noop$2,
          afterBuildLabels: noop$2,
          //
          beforeFit: noop$2,
          fit: function() {
            var me = this;
            var opts = me.options;
            var minSize = me.minSize = {};
            var isHorizontal = me.isHorizontal();
            var lineCount, textSize;
            if (!opts.display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
            me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
            me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
          },
          afterFit: noop$2,
          // Shared Methods
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          // Actually draw the title block on the canvas
          draw: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            if (!opts.display) {
              return;
            }
            var fontOpts = helpers$1.options._parseFont(opts);
            var lineHeight = fontOpts.lineHeight;
            var offset2 = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me.top;
            var left = me.left;
            var bottom = me.bottom;
            var right = me.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
            ctx.font = fontOpts.string;
            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2;
              titleY = top + offset2;
              maxWidth = right - left;
            } else {
              titleX = opts.position === "left" ? left + offset2 : right - offset2;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var text = opts.text;
            if (helpers$1.isArray(text)) {
              var y = 0;
              for (var i = 0; i < text.length; ++i) {
                ctx.fillText(text[i], 0, y, maxWidth);
                y += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }
            ctx.restore();
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title2 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          core_layouts.configure(chart, title2, titleOpts);
          core_layouts.addBox(chart, title2);
          chart.titleBlock = title2;
        }
        var plugin_title = {
          id: "title",
          /**
           * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
           * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
           * the plugin, which one will be re-exposed in the chart.js file.
           * https://github.com/chartjs/Chart.js/pull/2640
           * @private
           */
          _element: Title,
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              helpers$1.mergeIf(titleOpts, core_defaults.global.title);
              if (titleBlock) {
                core_layouts.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              core_layouts.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
        var plugins = {};
        var filler = plugin_filler;
        var legend = plugin_legend;
        var title = plugin_title;
        plugins.filler = filler;
        plugins.legend = legend;
        plugins.title = title;
        core_controller.helpers = helpers$1;
        core_helpers();
        core_controller._adapters = core_adapters;
        core_controller.Animation = core_animation;
        core_controller.animationService = core_animations;
        core_controller.controllers = controllers;
        core_controller.DatasetController = core_datasetController;
        core_controller.defaults = core_defaults;
        core_controller.Element = core_element;
        core_controller.elements = elements;
        core_controller.Interaction = core_interaction;
        core_controller.layouts = core_layouts;
        core_controller.platform = platform;
        core_controller.plugins = core_plugins;
        core_controller.Scale = core_scale;
        core_controller.scaleService = core_scaleService;
        core_controller.Ticks = core_ticks;
        core_controller.Tooltip = core_tooltip;
        core_controller.helpers.each(scales, function(scale2, type) {
          core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
        });
        for (var k in plugins) {
          if (plugins.hasOwnProperty(k)) {
            core_controller.plugins.register(plugins[k]);
          }
        }
        core_controller.platform.initialize();
        var src = core_controller;
        if (typeof window !== "undefined") {
          window.Chart = core_controller;
        }
        core_controller.Chart = core_controller;
        core_controller.Legend = plugins.legend._element;
        core_controller.Title = plugins.title._element;
        core_controller.pluginService = core_controller.plugins;
        core_controller.PluginBase = core_controller.Element.extend({});
        core_controller.canvasHelpers = core_controller.helpers.canvas;
        core_controller.layoutService = core_controller.layouts;
        core_controller.LinearScaleBase = scale_linearbase;
        core_controller.helpers.each(
          [
            "Bar",
            "Bubble",
            "Doughnut",
            "Line",
            "PolarArea",
            "Radar",
            "Scatter"
          ],
          function(klass) {
            core_controller[klass] = function(ctx, cfg) {
              return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
                type: klass.charAt(0).toLowerCase() + klass.slice(1)
              }));
            };
          }
        );
        return src;
      });
    })(Chart$1);
    return Chart$1.exports;
  }
  var ChartExports = requireChart();
  const Chart = /* @__PURE__ */ getDefaultExportFromCjs(ChartExports);
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var numbro_min = { exports: {} };
  (function(module2, exports) {
    !function(e) {
      module2.exports = e();
    }(function() {
      return function a(o, u, c) {
        function s(t, e2) {
          if (!u[t]) {
            if (!o[t]) {
              var r = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && r)
                return r(t, true);
              if (l)
                return l(t, true);
              var n = new Error("Cannot find module '" + t + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = u[t] = { exports: {} };
            o[t][0].call(i.exports, function(e3) {
              return s(o[t][1][e3] || e3);
            }, i, i.exports, a, o, u, c);
          }
          return u[t].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < c.length; e++)
          s(c[e]);
        return s;
      }({ 1: [function(e, r, t) {
        !function(e2) {
          var t2, T = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator, U = Math.ceil, R = Math.floor, I = "[BigNumber Error] ", $ = I + "Number primitive has more than 15 significant digits: ", G = 1e14, V = 14, q = 9007199254740991, Z = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], z = 1e7, W = 1e9;
          function H(e3) {
            var t3 = 0 | e3;
            return 0 < e3 || e3 === t3 ? t3 : t3 - 1;
          }
          function Y(e3) {
            for (var t3, r2, n = 1, i = e3.length, a = e3[0] + ""; n < i; ) {
              for (t3 = e3[n++] + "", r2 = V - t3.length; r2--; t3 = "0" + t3)
                ;
              a += t3;
            }
            for (i = a.length; 48 === a.charCodeAt(--i); )
              ;
            return a.slice(0, i + 1 || 1);
          }
          function K(e3, t3) {
            var r2, n, i = e3.c, a = t3.c, o = e3.s, u = t3.s, c = e3.e, s = t3.e;
            if (!o || !u)
              return null;
            if (r2 = i && !i[0], n = a && !a[0], r2 || n)
              return r2 ? n ? 0 : -u : o;
            if (o != u)
              return o;
            if (r2 = o < 0, n = c == s, !i || !a)
              return n ? 0 : !i ^ r2 ? 1 : -1;
            if (!n)
              return s < c ^ r2 ? 1 : -1;
            for (u = (c = i.length) < (s = a.length) ? c : s, o = 0; o < u; o++)
              if (i[o] != a[o])
                return i[o] > a[o] ^ r2 ? 1 : -1;
            return c == s ? 0 : s < c ^ r2 ? 1 : -1;
          }
          function J(e3, t3, r2, n) {
            if (e3 < t3 || r2 < e3 || e3 !== R(e3))
              throw Error(I + (n || "Argument") + ("number" == typeof e3 ? e3 < t3 || r2 < e3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
          }
          function X(e3) {
            var t3 = e3.c.length - 1;
            return H(e3.e / V) == t3 && e3.c[t3] % 2 != 0;
          }
          function Q(e3, t3) {
            return (1 < e3.length ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
          }
          function ee(e3, t3, r2) {
            var n, i;
            if (t3 < 0) {
              for (i = r2 + "."; ++t3; i += r2)
                ;
              e3 = i + e3;
            } else if (++t3 > (n = e3.length)) {
              for (i = r2, t3 -= n; --t3; i += r2)
                ;
              e3 += i;
            } else
              t3 < n && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
            return e3;
          }
          (t2 = function e3(t3) {
            var v, f, g, r2, s, m, o, u, c, l, p, n = A.prototype = { constructor: A, toString: null, valueOf: null }, h = new A(1), y = 20, b = 4, d = -7, w = 21, S = -1e7, O = 1e7, x = false, a = 1, N = 0, B = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: " ", suffix: "" }, M = "0123456789abcdefghijklmnopqrstuvwxyz";
            function A(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if (!(l2 instanceof A))
                return new A(e4, t4);
              if (null == t4) {
                if (e4 && true === e4._isBigNumber)
                  return l2.s = e4.s, void (!e4.c || e4.e > O ? l2.c = l2.e = null : e4.e < S ? l2.c = [l2.e = 0] : (l2.e = e4.e, l2.c = e4.c.slice()));
                if ((u2 = "number" == typeof e4) && 0 * e4 == 0) {
                  if (l2.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                    for (a2 = 0, o2 = e4; 10 <= o2; o2 /= 10, a2++)
                      ;
                    return void (O < a2 ? l2.c = l2.e = null : (l2.e = a2, l2.c = [e4]));
                  }
                  s2 = String(e4);
                } else {
                  if (!T.test(s2 = String(e4)))
                    return g(l2, s2, u2);
                  l2.s = 45 == s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                }
                -1 < (a2 = s2.indexOf(".")) && (s2 = s2.replace(".", "")), 0 < (o2 = s2.search(/e/i)) ? (a2 < 0 && (a2 = o2), a2 += +s2.slice(o2 + 1), s2 = s2.substring(0, o2)) : a2 < 0 && (a2 = s2.length);
              } else {
                if (J(t4, 2, M.length, "Base"), 10 == t4)
                  return j(l2 = new A(e4), y + l2.e + 1, b);
                if (s2 = String(e4), u2 = "number" == typeof e4) {
                  if (0 * e4 != 0)
                    return g(l2, s2, u2, t4);
                  if (l2.s = 1 / e4 < 0 ? (s2 = s2.slice(1), -1) : 1, A.DEBUG && 15 < s2.replace(/^0\.0*|\./, "").length)
                    throw Error($ + e4);
                } else
                  l2.s = 45 === s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                for (r3 = M.slice(0, t4), a2 = o2 = 0, c2 = s2.length; o2 < c2; o2++)
                  if (r3.indexOf(n2 = s2.charAt(o2)) < 0) {
                    if ("." == n2) {
                      if (a2 < o2) {
                        a2 = c2;
                        continue;
                      }
                    } else if (!i2 && (s2 == s2.toUpperCase() && (s2 = s2.toLowerCase()) || s2 == s2.toLowerCase() && (s2 = s2.toUpperCase()))) {
                      i2 = true, o2 = -1, a2 = 0;
                      continue;
                    }
                    return g(l2, String(e4), u2, t4);
                  }
                u2 = false, -1 < (a2 = (s2 = f(s2, t4, 10, l2.s)).indexOf(".")) ? s2 = s2.replace(".", "") : a2 = s2.length;
              }
              for (o2 = 0; 48 === s2.charCodeAt(o2); o2++)
                ;
              for (c2 = s2.length; 48 === s2.charCodeAt(--c2); )
                ;
              if (s2 = s2.slice(o2, ++c2)) {
                if (c2 -= o2, u2 && A.DEBUG && 15 < c2 && (q < e4 || e4 !== R(e4)))
                  throw Error($ + l2.s * e4);
                if ((a2 = a2 - o2 - 1) > O)
                  l2.c = l2.e = null;
                else if (a2 < S)
                  l2.c = [l2.e = 0];
                else {
                  if (l2.e = a2, l2.c = [], o2 = (a2 + 1) % V, a2 < 0 && (o2 += V), o2 < c2) {
                    for (o2 && l2.c.push(+s2.slice(0, o2)), c2 -= V; o2 < c2; )
                      l2.c.push(+s2.slice(o2, o2 += V));
                    o2 = V - (s2 = s2.slice(o2)).length;
                  } else
                    o2 -= c2;
                  for (; o2--; s2 += "0")
                    ;
                  l2.c.push(+s2);
                }
              } else
                l2.c = [l2.e = 0];
            }
            function D(e4, t4, r3, n2) {
              for (var i2, a2, o2 = [0], u2 = 0, c2 = e4.length; u2 < c2; ) {
                for (a2 = o2.length; a2--; o2[a2] *= t4)
                  ;
                for (o2[0] += n2.indexOf(e4.charAt(u2++)), i2 = 0; i2 < o2.length; i2++)
                  o2[i2] > r3 - 1 && (null == o2[i2 + 1] && (o2[i2 + 1] = 0), o2[i2 + 1] += o2[i2] / r3 | 0, o2[i2] %= r3);
              }
              return o2.reverse();
            }
            function E(e4, t4, r3) {
              var n2, i2, a2, o2, u2 = 0, c2 = e4.length, s2 = t4 % z, l2 = t4 / z | 0;
              for (e4 = e4.slice(); c2--; )
                u2 = ((i2 = s2 * (a2 = e4[c2] % z) + (n2 = l2 * a2 + (o2 = e4[c2] / z | 0) * s2) % z * z + u2) / r3 | 0) + (n2 / z | 0) + l2 * o2, e4[c2] = i2 % r3;
              return u2 && (e4 = [u2].concat(e4)), e4;
            }
            function F(e4, t4, r3, n2) {
              var i2, a2;
              if (r3 != n2)
                a2 = n2 < r3 ? 1 : -1;
              else
                for (i2 = a2 = 0; i2 < r3; i2++)
                  if (e4[i2] != t4[i2]) {
                    a2 = e4[i2] > t4[i2] ? 1 : -1;
                    break;
                  }
              return a2;
            }
            function k(e4, t4, r3, n2) {
              for (var i2 = 0; r3--; )
                e4[r3] -= i2, i2 = e4[r3] < t4[r3] ? 1 : 0, e4[r3] = i2 * n2 + e4[r3] - t4[r3];
              for (; !e4[0] && 1 < e4.length; e4.splice(0, 1))
                ;
            }
            function i(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2;
              if (null == r3 ? r3 = b : J(r3, 0, 8), !e4.c)
                return e4.toString();
              if (i2 = e4.c[0], o2 = e4.e, null == t4)
                c2 = Y(e4.c), c2 = 1 == n2 || 2 == n2 && (o2 <= d || w <= o2) ? Q(c2, o2) : ee(c2, o2, "0");
              else if (a2 = (e4 = j(new A(e4), t4, r3)).e, u2 = (c2 = Y(e4.c)).length, 1 == n2 || 2 == n2 && (t4 <= a2 || a2 <= d)) {
                for (; u2 < t4; c2 += "0", u2++)
                  ;
                c2 = Q(c2, a2);
              } else if (t4 -= o2, c2 = ee(c2, a2, "0"), u2 < a2 + 1) {
                if (0 < --t4)
                  for (c2 += "."; t4--; c2 += "0")
                    ;
              } else if (0 < (t4 += a2 - u2))
                for (a2 + 1 == u2 && (c2 += "."); t4--; c2 += "0")
                  ;
              return e4.s < 0 && i2 ? "-" + c2 : c2;
            }
            function _(e4, t4) {
              for (var r3, n2 = 1, i2 = new A(e4[0]); n2 < e4.length; n2++) {
                if (!(r3 = new A(e4[n2])).s) {
                  i2 = r3;
                  break;
                }
                t4.call(i2, r3) && (i2 = r3);
              }
              return i2;
            }
            function L(e4, t4, r3) {
              for (var n2 = 1, i2 = t4.length; !t4[--i2]; t4.pop())
                ;
              for (i2 = t4[0]; 10 <= i2; i2 /= 10, n2++)
                ;
              return (r3 = n2 + r3 * V - 1) > O ? e4.c = e4.e = null : r3 < S ? e4.c = [e4.e = 0] : (e4.e = r3, e4.c = t4), e4;
            }
            function j(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2, s2, l2, f2 = e4.c, g2 = Z;
              if (f2) {
                e: {
                  for (i2 = 1, u2 = f2[0]; 10 <= u2; u2 /= 10, i2++)
                    ;
                  if ((a2 = t4 - i2) < 0)
                    a2 += V, o2 = t4, l2 = (c2 = f2[s2 = 0]) / g2[i2 - o2 - 1] % 10 | 0;
                  else if ((s2 = U((a2 + 1) / V)) >= f2.length) {
                    if (!n2)
                      break e;
                    for (; f2.length <= s2; f2.push(0))
                      ;
                    c2 = l2 = 0, o2 = (a2 %= V) - V + (i2 = 1);
                  } else {
                    for (c2 = u2 = f2[s2], i2 = 1; 10 <= u2; u2 /= 10, i2++)
                      ;
                    l2 = (o2 = (a2 %= V) - V + i2) < 0 ? 0 : c2 / g2[i2 - o2 - 1] % 10 | 0;
                  }
                  if (n2 = n2 || t4 < 0 || null != f2[s2 + 1] || (o2 < 0 ? c2 : c2 % g2[i2 - o2 - 1]), n2 = r3 < 4 ? (l2 || n2) && (0 == r3 || r3 == (e4.s < 0 ? 3 : 2)) : 5 < l2 || 5 == l2 && (4 == r3 || n2 || 6 == r3 && (0 < a2 ? 0 < o2 ? c2 / g2[i2 - o2] : 0 : f2[s2 - 1]) % 10 & 1 || r3 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !f2[0])
                    return f2.length = 0, n2 ? (t4 -= e4.e + 1, f2[0] = g2[(V - t4 % V) % V], e4.e = -t4 || 0) : f2[0] = e4.e = 0, e4;
                  if (0 == a2 ? (f2.length = s2, u2 = 1, s2--) : (f2.length = s2 + 1, u2 = g2[V - a2], f2[s2] = 0 < o2 ? R(c2 / g2[i2 - o2] % g2[o2]) * u2 : 0), n2)
                    for (; ; ) {
                      if (0 == s2) {
                        for (a2 = 1, o2 = f2[0]; 10 <= o2; o2 /= 10, a2++)
                          ;
                        for (o2 = f2[0] += u2, u2 = 1; 10 <= o2; o2 /= 10, u2++)
                          ;
                        a2 != u2 && (e4.e++, f2[0] == G && (f2[0] = 1));
                        break;
                      }
                      if (f2[s2] += u2, f2[s2] != G)
                        break;
                      f2[s2--] = 0, u2 = 1;
                    }
                  for (a2 = f2.length; 0 === f2[--a2]; f2.pop())
                    ;
                }
                e4.e > O ? e4.c = e4.e = null : e4.e < S && (e4.c = [e4.e = 0]);
              }
              return e4;
            }
            function P(e4) {
              var t4, r3 = e4.e;
              return null === r3 ? e4.toString() : (t4 = Y(e4.c), t4 = r3 <= d || w <= r3 ? Q(t4, r3) : ee(t4, r3, "0"), e4.s < 0 ? "-" + t4 : t4);
            }
            return A.clone = e3, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(e4) {
              var t4, r3;
              if (null != e4) {
                if ("object" != typeof e4)
                  throw Error(I + "Object expected: " + e4);
                if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (J(r3 = e4[t4], 0, W, t4), y = r3), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (J(r3 = e4[t4], 0, 8, t4), b = r3), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r3 = e4[t4]) && r3.pop ? (J(r3[0], -W, 0, t4), J(r3[1], 0, W, t4), d = r3[0], w = r3[1]) : (J(r3, -W, W, t4), d = -(w = r3 < 0 ? -r3 : r3))), e4.hasOwnProperty(t4 = "RANGE"))
                  if ((r3 = e4[t4]) && r3.pop)
                    J(r3[0], -W, -1, t4), J(r3[1], 1, W, t4), S = r3[0], O = r3[1];
                  else {
                    if (J(r3, -W, W, t4), !r3)
                      throw Error(I + t4 + " cannot be zero: " + r3);
                    S = -(O = r3 < 0 ? -r3 : r3);
                  }
                if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                  if ((r3 = e4[t4]) !== !!r3)
                    throw Error(I + t4 + " not true or false: " + r3);
                  if (r3) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                      throw x = !r3, Error(I + "crypto unavailable");
                    x = r3;
                  } else
                    x = r3;
                }
                if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (J(r3 = e4[t4], 0, 9, t4), a = r3), e4.hasOwnProperty(t4 = "POW_PRECISION") && (J(r3 = e4[t4], 0, W, t4), N = r3), e4.hasOwnProperty(t4 = "FORMAT")) {
                  if ("object" != typeof (r3 = e4[t4]))
                    throw Error(I + t4 + " not an object: " + r3);
                  B = r3;
                }
                if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                  if ("string" != typeof (r3 = e4[t4]) || /^.$|[+-.\s]|(.).*\1/.test(r3))
                    throw Error(I + t4 + " invalid: " + r3);
                  M = r3;
                }
              }
              return { DECIMAL_PLACES: y, ROUNDING_MODE: b, EXPONENTIAL_AT: [d, w], RANGE: [S, O], CRYPTO: x, MODULO_MODE: a, POW_PRECISION: N, FORMAT: B, ALPHABET: M };
            }, A.isBigNumber = function(e4) {
              if (!e4 || true !== e4._isBigNumber)
                return false;
              if (!A.DEBUG)
                return true;
              var t4, r3, n2 = e4.c, i2 = e4.e, a2 = e4.s;
              e:
                if ("[object Array]" == {}.toString.call(n2)) {
                  if ((1 === a2 || -1 === a2) && -W <= i2 && i2 <= W && i2 === R(i2)) {
                    if (0 === n2[0]) {
                      if (0 === i2 && 1 === n2.length)
                        return true;
                      break e;
                    }
                    if ((t4 = (i2 + 1) % V) < 1 && (t4 += V), String(n2[0]).length == t4) {
                      for (t4 = 0; t4 < n2.length; t4++)
                        if ((r3 = n2[t4]) < 0 || G <= r3 || r3 !== R(r3))
                          break e;
                      if (0 !== r3)
                        return true;
                    }
                  }
                } else if (null === n2 && null === i2 && (null === a2 || 1 === a2 || -1 === a2))
                  return true;
              throw Error(I + "Invalid BigNumber: " + e4);
            }, A.maximum = A.max = function() {
              return _(arguments, n.lt);
            }, A.minimum = A.min = function() {
              return _(arguments, n.gt);
            }, A.random = (r2 = 9007199254740992, s = Math.random() * r2 & 2097151 ? function() {
              return R(Math.random() * r2);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e4) {
              var t4, r3, n2, i2, a2, o2 = 0, u2 = [], c2 = new A(h);
              if (null == e4 ? e4 = y : J(e4, 0, W), i2 = U(e4 / V), x)
                if (crypto.getRandomValues) {
                  for (t4 = crypto.getRandomValues(new Uint32Array(i2 *= 2)); o2 < i2; )
                    9e15 <= (a2 = 131072 * t4[o2] + (t4[o2 + 1] >>> 11)) ? (r3 = crypto.getRandomValues(new Uint32Array(2)), t4[o2] = r3[0], t4[o2 + 1] = r3[1]) : (u2.push(a2 % 1e14), o2 += 2);
                  o2 = i2 / 2;
                } else {
                  if (!crypto.randomBytes)
                    throw x = false, Error(I + "crypto unavailable");
                  for (t4 = crypto.randomBytes(i2 *= 7); o2 < i2; )
                    9e15 <= (a2 = 281474976710656 * (31 & t4[o2]) + 1099511627776 * t4[o2 + 1] + 4294967296 * t4[o2 + 2] + 16777216 * t4[o2 + 3] + (t4[o2 + 4] << 16) + (t4[o2 + 5] << 8) + t4[o2 + 6]) ? crypto.randomBytes(7).copy(t4, o2) : (u2.push(a2 % 1e14), o2 += 7);
                  o2 = i2 / 7;
                }
              if (!x)
                for (; o2 < i2; )
                  (a2 = s()) < 9e15 && (u2[o2++] = a2 % 1e14);
              for (i2 = u2[--o2], e4 %= V, i2 && e4 && (a2 = Z[V - e4], u2[o2] = R(i2 / a2) * a2); 0 === u2[o2]; u2.pop(), o2--)
                ;
              if (o2 < 0)
                u2 = [n2 = 0];
              else {
                for (n2 = -1; 0 === u2[0]; u2.splice(0, 1), n2 -= V)
                  ;
                for (o2 = 1, a2 = u2[0]; 10 <= a2; a2 /= 10, o2++)
                  ;
                o2 < V && (n2 -= V - o2);
              }
              return c2.e = n2, c2.c = u2, c2;
            }), A.sum = function() {
              for (var e4 = 1, t4 = arguments, r3 = new A(t4[0]); e4 < t4.length; )
                r3 = r3.plus(t4[e4++]);
              return r3;
            }, m = "0123456789", f = function(e4, t4, r3, n2, i2) {
              var a2, o2, u2, c2, s2, l2, f2, g2, p2 = e4.indexOf("."), d2 = y, h2 = b;
              for (0 <= p2 && (c2 = N, N = 0, e4 = e4.replace(".", ""), l2 = (g2 = new A(t4)).pow(e4.length - p2), N = c2, g2.c = D(ee(Y(l2.c), l2.e, "0"), 10, r3, m), g2.e = g2.c.length), u2 = c2 = (f2 = D(e4, t4, r3, i2 ? (a2 = M, m) : (a2 = m, M))).length; 0 == f2[--c2]; f2.pop())
                ;
              if (!f2[0])
                return a2.charAt(0);
              if (p2 < 0 ? --u2 : (l2.c = f2, l2.e = u2, l2.s = n2, f2 = (l2 = v(l2, g2, d2, h2, r3)).c, s2 = l2.r, u2 = l2.e), p2 = f2[o2 = u2 + d2 + 1], c2 = r3 / 2, s2 = s2 || o2 < 0 || null != f2[o2 + 1], s2 = h2 < 4 ? (null != p2 || s2) && (0 == h2 || h2 == (l2.s < 0 ? 3 : 2)) : c2 < p2 || p2 == c2 && (4 == h2 || s2 || 6 == h2 && 1 & f2[o2 - 1] || h2 == (l2.s < 0 ? 8 : 7)), o2 < 1 || !f2[0])
                e4 = s2 ? ee(a2.charAt(1), -d2, a2.charAt(0)) : a2.charAt(0);
              else {
                if (f2.length = o2, s2)
                  for (--r3; ++f2[--o2] > r3; )
                    f2[o2] = 0, o2 || (++u2, f2 = [1].concat(f2));
                for (c2 = f2.length; !f2[--c2]; )
                  ;
                for (p2 = 0, e4 = ""; p2 <= c2; e4 += a2.charAt(f2[p2++]))
                  ;
                e4 = ee(e4, u2, a2.charAt(0));
              }
              return e4;
            }, v = function(e4, t4, r3, n2, i2) {
              var a2, o2, u2, c2, s2, l2, f2, g2, p2, d2, h2, v2, m2, y2, b2, w2, S2, O2 = e4.s == t4.s ? 1 : -1, x2 = e4.c, N2 = t4.c;
              if (!(x2 && x2[0] && N2 && N2[0]))
                return new A(e4.s && t4.s && (x2 ? !N2 || x2[0] != N2[0] : N2) ? x2 && 0 == x2[0] || !N2 ? 0 * O2 : O2 / 0 : NaN);
              for (p2 = (g2 = new A(O2)).c = [], O2 = r3 + (o2 = e4.e - t4.e) + 1, i2 || (i2 = G, o2 = H(e4.e / V) - H(t4.e / V), O2 = O2 / V | 0), u2 = 0; N2[u2] == (x2[u2] || 0); u2++)
                ;
              if (N2[u2] > (x2[u2] || 0) && o2--, O2 < 0)
                p2.push(1), c2 = true;
              else {
                for (y2 = x2.length, w2 = N2.length, O2 += 2, 1 < (s2 = R(i2 / (N2[u2 = 0] + 1))) && (N2 = E(N2, s2, i2), x2 = E(x2, s2, i2), w2 = N2.length, y2 = x2.length), m2 = w2, h2 = (d2 = x2.slice(0, w2)).length; h2 < w2; d2[h2++] = 0)
                  ;
                S2 = N2.slice(), S2 = [0].concat(S2), b2 = N2[0], N2[1] >= i2 / 2 && b2++;
                do {
                  if (s2 = 0, (a2 = F(N2, d2, w2, h2)) < 0) {
                    if (v2 = d2[0], w2 != h2 && (v2 = v2 * i2 + (d2[1] || 0)), 1 < (s2 = R(v2 / b2)))
                      for (i2 <= s2 && (s2 = i2 - 1), f2 = (l2 = E(N2, s2, i2)).length, h2 = d2.length; 1 == F(l2, d2, f2, h2); )
                        s2--, k(l2, w2 < f2 ? S2 : N2, f2, i2), f2 = l2.length, a2 = 1;
                    else
                      0 == s2 && (a2 = s2 = 1), f2 = (l2 = N2.slice()).length;
                    if (f2 < h2 && (l2 = [0].concat(l2)), k(d2, l2, h2, i2), h2 = d2.length, -1 == a2)
                      for (; F(N2, d2, w2, h2) < 1; )
                        s2++, k(d2, w2 < h2 ? S2 : N2, h2, i2), h2 = d2.length;
                  } else
                    0 === a2 && (s2++, d2 = [0]);
                  p2[u2++] = s2, d2[0] ? d2[h2++] = x2[m2] || 0 : (d2 = [x2[m2]], h2 = 1);
                } while ((m2++ < y2 || null != d2[0]) && O2--);
                c2 = null != d2[0], p2[0] || p2.splice(0, 1);
              }
              if (i2 == G) {
                for (u2 = 1, O2 = p2[0]; 10 <= O2; O2 /= 10, u2++)
                  ;
                j(g2, r3 + (g2.e = u2 + o2 * V - 1) + 1, n2, c2);
              } else
                g2.e = o2, g2.r = +c2;
              return g2;
            }, o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u = /^([^.]+)\.$/, c = /^\.([^.]+)$/, l = /^-?(Infinity|NaN)$/, p = /^\s*\+(?=[\w.])|^\s+|\s+$/g, g = function(e4, t4, r3, n2) {
              var i2, a2 = r3 ? t4 : t4.replace(p, "");
              if (l.test(a2))
                e4.s = isNaN(a2) ? null : a2 < 0 ? -1 : 1;
              else {
                if (!r3 && (a2 = a2.replace(o, function(e5, t5, r4) {
                  return i2 = "x" == (r4 = r4.toLowerCase()) ? 16 : "b" == r4 ? 2 : 8, n2 && n2 != i2 ? e5 : t5;
                }), n2 && (i2 = n2, a2 = a2.replace(u, "$1").replace(c, "0.$1")), t4 != a2))
                  return new A(a2, i2);
                if (A.DEBUG)
                  throw Error(I + "Not a" + (n2 ? " base " + n2 : "") + " number: " + t4);
                e4.s = null;
              }
              e4.c = e4.e = null;
            }, n.absoluteValue = n.abs = function() {
              var e4 = new A(this);
              return e4.s < 0 && (e4.s = 1), e4;
            }, n.comparedTo = function(e4, t4) {
              return K(this, new A(e4, t4));
            }, n.decimalPlaces = n.dp = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4)
                return J(e4, 0, W), null == t4 ? t4 = b : J(t4, 0, 8), j(new A(this), e4 + this.e + 1, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = ((i2 = r3.length - 1) - H(this.e / V)) * V, i2 = r3[i2])
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
              return n2 < 0 && (n2 = 0), n2;
            }, n.dividedBy = n.div = function(e4, t4) {
              return v(this, new A(e4, t4), y, b);
            }, n.dividedToIntegerBy = n.idiv = function(e4, t4) {
              return v(this, new A(e4, t4), 0, 1);
            }, n.exponentiatedBy = n.pow = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if ((e4 = new A(e4)).c && !e4.isInteger())
                throw Error(I + "Exponent not an integer: " + P(e4));
              if (null != t4 && (t4 = new A(t4)), o2 = 14 < e4.e, !l2.c || !l2.c[0] || 1 == l2.c[0] && !l2.e && 1 == l2.c.length || !e4.c || !e4.c[0])
                return s2 = new A(Math.pow(+P(l2), o2 ? 2 - X(e4) : +P(e4))), t4 ? s2.mod(t4) : s2;
              if (u2 = e4.s < 0, t4) {
                if (t4.c ? !t4.c[0] : !t4.s)
                  return new A(NaN);
                (n2 = !u2 && l2.isInteger() && t4.isInteger()) && (l2 = l2.mod(t4));
              } else {
                if (9 < e4.e && (0 < l2.e || l2.e < -1 || (0 == l2.e ? 1 < l2.c[0] || o2 && 24e7 <= l2.c[1] : l2.c[0] < 8e13 || o2 && l2.c[0] <= 9999975e7)))
                  return a2 = l2.s < 0 && X(e4) ? -0 : 0, -1 < l2.e && (a2 = 1 / a2), new A(u2 ? 1 / a2 : a2);
                N && (a2 = U(N / V + 2));
              }
              for (c2 = o2 ? (r3 = new A(0.5), u2 && (e4.s = 1), X(e4)) : (i2 = Math.abs(+P(e4))) % 2, s2 = new A(h); ; ) {
                if (c2) {
                  if (!(s2 = s2.times(l2)).c)
                    break;
                  a2 ? s2.c.length > a2 && (s2.c.length = a2) : n2 && (s2 = s2.mod(t4));
                }
                if (i2) {
                  if (0 === (i2 = R(i2 / 2)))
                    break;
                  c2 = i2 % 2;
                } else if (j(e4 = e4.times(r3), e4.e + 1, 1), 14 < e4.e)
                  c2 = X(e4);
                else {
                  if (0 == (i2 = +P(e4)))
                    break;
                  c2 = i2 % 2;
                }
                l2 = l2.times(l2), a2 ? l2.c && l2.c.length > a2 && (l2.c.length = a2) : n2 && (l2 = l2.mod(t4));
              }
              return n2 ? s2 : (u2 && (s2 = h.div(s2)), t4 ? s2.mod(t4) : a2 ? j(s2, N, b, void 0) : s2);
            }, n.integerValue = function(e4) {
              var t4 = new A(this);
              return null == e4 ? e4 = b : J(e4, 0, 8), j(t4, t4.e + 1, e4);
            }, n.isEqualTo = n.eq = function(e4, t4) {
              return 0 === K(this, new A(e4, t4));
            }, n.isFinite = function() {
              return !!this.c;
            }, n.isGreaterThan = n.gt = function(e4, t4) {
              return 0 < K(this, new A(e4, t4));
            }, n.isGreaterThanOrEqualTo = n.gte = function(e4, t4) {
              return 1 === (t4 = K(this, new A(e4, t4))) || 0 === t4;
            }, n.isInteger = function() {
              return !!this.c && H(this.e / V) > this.c.length - 2;
            }, n.isLessThan = n.lt = function(e4, t4) {
              return K(this, new A(e4, t4)) < 0;
            }, n.isLessThanOrEqualTo = n.lte = function(e4, t4) {
              return -1 === (t4 = K(this, new A(e4, t4))) || 0 === t4;
            }, n.isNaN = function() {
              return !this.s;
            }, n.isNegative = function() {
              return this.s < 0;
            }, n.isPositive = function() {
              return 0 < this.s;
            }, n.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, n.minus = function(e4, t4) {
              var r3, n2, i2, a2, o2 = this, u2 = o2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !u2 || !t4)
                return new A(NaN);
              if (u2 != t4)
                return e4.s = -t4, o2.plus(e4);
              var c2 = o2.e / V, s2 = e4.e / V, l2 = o2.c, f2 = e4.c;
              if (!c2 || !s2) {
                if (!l2 || !f2)
                  return l2 ? (e4.s = -t4, e4) : new A(f2 ? o2 : NaN);
                if (!l2[0] || !f2[0])
                  return f2[0] ? (e4.s = -t4, e4) : new A(l2[0] ? o2 : 3 == b ? -0 : 0);
              }
              if (c2 = H(c2), s2 = H(s2), l2 = l2.slice(), u2 = c2 - s2) {
                for ((i2 = (a2 = u2 < 0) ? (u2 = -u2, l2) : (s2 = c2, f2)).reverse(), t4 = u2; t4--; i2.push(0))
                  ;
                i2.reverse();
              } else
                for (n2 = (a2 = (u2 = l2.length) < (t4 = f2.length)) ? u2 : t4, u2 = t4 = 0; t4 < n2; t4++)
                  if (l2[t4] != f2[t4]) {
                    a2 = l2[t4] < f2[t4];
                    break;
                  }
              if (a2 && (i2 = l2, l2 = f2, f2 = i2, e4.s = -e4.s), 0 < (t4 = (n2 = f2.length) - (r3 = l2.length)))
                for (; t4--; l2[r3++] = 0)
                  ;
              for (t4 = G - 1; u2 < n2; ) {
                if (l2[--n2] < f2[n2]) {
                  for (r3 = n2; r3 && !l2[--r3]; l2[r3] = t4)
                    ;
                  --l2[r3], l2[n2] += G;
                }
                l2[n2] -= f2[n2];
              }
              for (; 0 == l2[0]; l2.splice(0, 1), --s2)
                ;
              return l2[0] ? L(e4, l2, s2) : (e4.s = 3 == b ? -1 : 1, e4.c = [e4.e = 0], e4);
            }, n.modulo = n.mod = function(e4, t4) {
              var r3, n2, i2 = this;
              return e4 = new A(e4, t4), !i2.c || !e4.s || e4.c && !e4.c[0] ? new A(NaN) : !e4.c || i2.c && !i2.c[0] ? new A(i2) : (9 == a ? (n2 = e4.s, e4.s = 1, r3 = v(i2, e4, 0, 3), e4.s = n2, r3.s *= n2) : r3 = v(i2, e4, 0, a), (e4 = i2.minus(r3.times(e4))).c[0] || 1 != a || (e4.s = i2.s), e4);
            }, n.multipliedBy = n.times = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, g2, p2, d2, h2, v2, m2 = this, y2 = m2.c, b2 = (e4 = new A(e4, t4)).c;
              if (!(y2 && b2 && y2[0] && b2[0]))
                return !m2.s || !e4.s || y2 && !y2[0] && !b2 || b2 && !b2[0] && !y2 ? e4.c = e4.e = e4.s = null : (e4.s *= m2.s, y2 && b2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
              for (n2 = H(m2.e / V) + H(e4.e / V), e4.s *= m2.s, (c2 = y2.length) < (f2 = b2.length) && (d2 = y2, y2 = b2, b2 = d2, i2 = c2, c2 = f2, f2 = i2), i2 = c2 + f2, d2 = []; i2--; d2.push(0))
                ;
              for (h2 = G, v2 = z, i2 = f2; 0 <= --i2; ) {
                for (r3 = 0, g2 = b2[i2] % v2, p2 = b2[i2] / v2 | 0, a2 = i2 + (o2 = c2); i2 < a2; )
                  r3 = ((s2 = g2 * (s2 = y2[--o2] % v2) + (u2 = p2 * s2 + (l2 = y2[o2] / v2 | 0) * g2) % v2 * v2 + d2[a2] + r3) / h2 | 0) + (u2 / v2 | 0) + p2 * l2, d2[a2--] = s2 % h2;
                d2[a2] = r3;
              }
              return r3 ? ++n2 : d2.splice(0, 1), L(e4, d2, n2);
            }, n.negated = function() {
              var e4 = new A(this);
              return e4.s = -e4.s || null, e4;
            }, n.plus = function(e4, t4) {
              var r3, n2 = this, i2 = n2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !i2 || !t4)
                return new A(NaN);
              if (i2 != t4)
                return e4.s = -t4, n2.minus(e4);
              var a2 = n2.e / V, o2 = e4.e / V, u2 = n2.c, c2 = e4.c;
              if (!a2 || !o2) {
                if (!u2 || !c2)
                  return new A(i2 / 0);
                if (!u2[0] || !c2[0])
                  return c2[0] ? e4 : new A(u2[0] ? n2 : 0 * i2);
              }
              if (a2 = H(a2), o2 = H(o2), u2 = u2.slice(), i2 = a2 - o2) {
                for ((r3 = 0 < i2 ? (o2 = a2, c2) : (i2 = -i2, u2)).reverse(); i2--; r3.push(0))
                  ;
                r3.reverse();
              }
              for ((i2 = u2.length) - (t4 = c2.length) < 0 && (r3 = c2, c2 = u2, u2 = r3, t4 = i2), i2 = 0; t4; )
                i2 = (u2[--t4] = u2[t4] + c2[t4] + i2) / G | 0, u2[t4] = G === u2[t4] ? 0 : u2[t4] % G;
              return i2 && (u2 = [i2].concat(u2), ++o2), L(e4, u2, o2);
            }, n.precision = n.sd = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4 && e4 !== !!e4)
                return J(e4, 1, W), null == t4 ? t4 = b : J(t4, 0, 8), j(new A(this), e4, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = (i2 = r3.length - 1) * V + 1, i2 = r3[i2]) {
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
                for (i2 = r3[0]; 10 <= i2; i2 /= 10, n2++)
                  ;
              }
              return e4 && this.e + 1 > n2 && (n2 = this.e + 1), n2;
            }, n.shiftedBy = function(e4) {
              return J(e4, -q, q), this.times("1e" + e4);
            }, n.squareRoot = n.sqrt = function() {
              var e4, t4, r3, n2, i2, a2 = this, o2 = a2.c, u2 = a2.s, c2 = a2.e, s2 = y + 4, l2 = new A("0.5");
              if (1 !== u2 || !o2 || !o2[0])
                return new A(!u2 || u2 < 0 && (!o2 || o2[0]) ? NaN : o2 ? a2 : 1 / 0);
              if ((r3 = 0 == (u2 = Math.sqrt(+P(a2))) || u2 == 1 / 0 ? (((t4 = Y(o2)).length + c2) % 2 == 0 && (t4 += "0"), u2 = Math.sqrt(+t4), c2 = H((c2 + 1) / 2) - (c2 < 0 || c2 % 2), new A(t4 = u2 == 1 / 0 ? "1e" + c2 : (t4 = u2.toExponential()).slice(0, t4.indexOf("e") + 1) + c2)) : new A(u2 + "")).c[0]) {
                for ((u2 = (c2 = r3.e) + s2) < 3 && (u2 = 0); ; )
                  if (i2 = r3, r3 = l2.times(i2.plus(v(a2, i2, s2, 1))), Y(i2.c).slice(0, u2) === (t4 = Y(r3.c)).slice(0, u2)) {
                    if (r3.e < c2 && --u2, "9999" != (t4 = t4.slice(u2 - 3, u2 + 1)) && (n2 || "4999" != t4)) {
                      +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || (j(r3, r3.e + y + 2, 1), e4 = !r3.times(r3).eq(a2));
                      break;
                    }
                    if (!n2 && (j(i2, i2.e + y + 2, 0), i2.times(i2).eq(a2))) {
                      r3 = i2;
                      break;
                    }
                    s2 += 4, u2 += 4, n2 = 1;
                  }
              }
              return j(r3, r3.e + y + 1, b, e4);
            }, n.toExponential = function(e4, t4) {
              return null != e4 && (J(e4, 0, W), e4++), i(this, e4, t4, 1);
            }, n.toFixed = function(e4, t4) {
              return null != e4 && (J(e4, 0, W), e4 = e4 + this.e + 1), i(this, e4, t4);
            }, n.toFormat = function(e4, t4, r3) {
              var n2;
              if (null == r3)
                null != e4 && t4 && "object" == typeof t4 ? (r3 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r3 = e4, e4 = t4 = null) : r3 = B;
              else if ("object" != typeof r3)
                throw Error(I + "Argument not an object: " + r3);
              if (n2 = this.toFixed(e4, t4), this.c) {
                var i2, a2 = n2.split("."), o2 = +r3.groupSize, u2 = +r3.secondaryGroupSize, c2 = r3.groupSeparator || "", s2 = a2[0], l2 = a2[1], f2 = this.s < 0, g2 = f2 ? s2.slice(1) : s2, p2 = g2.length;
                if (u2 && (i2 = o2, o2 = u2, p2 -= u2 = i2), 0 < o2 && 0 < p2) {
                  for (i2 = p2 % o2 || o2, s2 = g2.substr(0, i2); i2 < p2; i2 += o2)
                    s2 += c2 + g2.substr(i2, o2);
                  0 < u2 && (s2 += c2 + g2.slice(i2)), f2 && (s2 = "-" + s2);
                }
                n2 = l2 ? s2 + (r3.decimalSeparator || "") + ((u2 = +r3.fractionGroupSize) ? l2.replace(new RegExp("\\d{" + u2 + "}\\B", "g"), "$&" + (r3.fractionGroupSeparator || "")) : l2) : s2;
              }
              return (r3.prefix || "") + n2 + (r3.suffix || "");
            }, n.toFraction = function(e4) {
              var t4, r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, g2, p2 = this, d2 = p2.c;
              if (null != e4 && (!(u2 = new A(e4)).isInteger() && (u2.c || 1 !== u2.s) || u2.lt(h)))
                throw Error(I + "Argument " + (u2.isInteger() ? "out of range: " : "not an integer: ") + P(u2));
              if (!d2)
                return new A(p2);
              for (t4 = new A(h), s2 = r3 = new A(h), n2 = c2 = new A(h), g2 = Y(d2), a2 = t4.e = g2.length - p2.e - 1, t4.c[0] = Z[(o2 = a2 % V) < 0 ? V + o2 : o2], e4 = !e4 || 0 < u2.comparedTo(t4) ? 0 < a2 ? t4 : s2 : u2, o2 = O, O = 1 / 0, u2 = new A(g2), c2.c[0] = 0; l2 = v(u2, t4, 0, 1), 1 != (i2 = r3.plus(l2.times(n2))).comparedTo(e4); )
                r3 = n2, n2 = i2, s2 = c2.plus(l2.times(i2 = s2)), c2 = i2, t4 = u2.minus(l2.times(i2 = t4)), u2 = i2;
              return i2 = v(e4.minus(r3), n2, 0, 1), c2 = c2.plus(i2.times(s2)), r3 = r3.plus(i2.times(n2)), c2.s = s2.s = p2.s, f2 = v(s2, n2, a2 *= 2, b).minus(p2).abs().comparedTo(v(c2, r3, a2, b).minus(p2).abs()) < 1 ? [s2, n2] : [c2, r3], O = o2, f2;
            }, n.toNumber = function() {
              return +P(this);
            }, n.toPrecision = function(e4, t4) {
              return null != e4 && J(e4, 1, W), i(this, e4, t4, 2);
            }, n.toString = function(e4) {
              var t4, r3 = this, n2 = r3.s, i2 = r3.e;
              return null === i2 ? n2 ? (t4 = "Infinity", n2 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (t4 = null == e4 ? i2 <= d || w <= i2 ? Q(Y(r3.c), i2) : ee(Y(r3.c), i2, "0") : 10 === e4 ? ee(Y((r3 = j(new A(r3), y + i2 + 1, b)).c), r3.e, "0") : (J(e4, 2, M.length, "Base"), f(ee(Y(r3.c), i2, "0"), 10, e4, n2, true)), n2 < 0 && r3.c[0] && (t4 = "-" + t4)), t4;
            }, n.valueOf = n.toJSON = function() {
              return P(this);
            }, n._isBigNumber = true, C && (n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf), null != t3 && A.set(t3), A;
          }()).default = t2.BigNumber = t2, void 0 !== r && r.exports ? r.exports = t2 : (e2 = e2 || ("undefined" != typeof self && self ? self : window)).BigNumber = t2;
        }(this);
      }, {}], 2: [function(e, t, r) {
        t.exports = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e2) {
          var t2 = e2 % 10;
          return 1 == ~~(e2 % 100 / 10) ? "th" : 1 == t2 ? "st" : 2 == t2 ? "nd" : 3 == t2 ? "rd" : "th";
        }, bytes: { binarySuffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], decimalSuffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true, spaceSeparatedCurrency: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } };
      }, {}], 3: [function(e, t, r) {
        function I(e2, t2) {
          return function(e3) {
            if (Array.isArray(e3))
              return e3;
          }(e2) || function(e3, t3) {
            if (!(Symbol.iterator in Object(e3) || "[object Arguments]" === Object.prototype.toString.call(e3)))
              return;
            var r2 = [], n2 = true, i2 = false, a2 = void 0;
            try {
              for (var o2, u2 = e3[Symbol.iterator](); !(n2 = (o2 = u2.next()).done) && (r2.push(o2.value), !t3 || r2.length !== t3); n2 = true)
                ;
            } catch (e4) {
              i2 = true, a2 = e4;
            } finally {
              try {
                n2 || null == u2.return || u2.return();
              } finally {
                if (i2)
                  throw a2;
              }
            }
            return r2;
          }(e2, t2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var $ = e("./globalState"), o = e("./validating"), u = e("./parsing"), i = e("bignumber.js"), G = { trillion: Math.pow(10, 12), billion: Math.pow(10, 9), million: Math.pow(10, 6), thousand: Math.pow(10, 3) }, V = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false, roundingFunction: Math.round, spaceSeparatedAbbreviation: false }, n = $.currentBytes(), d = n.binarySuffixes, h = n.decimalSuffixes, a = { general: { scale: 1024, suffixes: h, marker: "bd" }, binary: { scale: 1024, suffixes: d, marker: "b" }, decimal: { scale: 1e3, suffixes: h, marker: "d" } };
        function c(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = 2 < arguments.length ? arguments[2] : void 0;
          if ("string" == typeof t2 && (t2 = u.parseFormat(t2)), !o.validateFormat(t2))
            return "ERROR: invalid format";
          var n2 = t2.prefix || "", i2 = t2.postfix || "", a2 = function(e3, t3, r3) {
            switch (t3.output) {
              case "currency":
                return t3 = s(t3, $.currentCurrencyDefaultFormat()), function(e4, t4, r4) {
                  var n3 = r4.currentCurrency(), i3 = Object.assign({}, t4), a3 = Object.assign({}, V, i3), o2 = void 0, u2 = "", c2 = !!a3.totalLength || !!a3.forceAverage || a3.average, s2 = i3.currencyPosition || n3.position, l = i3.currencySymbol || n3.symbol, f = void 0 !== a3.spaceSeparatedCurrency ? a3.spaceSeparatedCurrency : a3.spaceSeparated;
                  void 0 === i3.lowPrecision && (i3.lowPrecision = false);
                  f && (u2 = " ");
                  "infix" === s2 && (o2 = u2 + l + u2);
                  var g2 = m({ instance: e4, providedFormat: i3, state: r4, decimalSeparator: o2 });
                  "prefix" === s2 && (g2 = e4._value < 0 && "sign" === a3.negative ? "-".concat(u2).concat(l).concat(g2.slice(1)) : 0 < e4._value && a3.forceSign ? "+".concat(u2).concat(l).concat(g2.slice(1)) : l + u2 + g2);
                  s2 && "postfix" !== s2 || (u2 = !a3.spaceSeparatedAbbreviation && c2 ? "" : u2, g2 = g2 + u2 + l);
                  return g2;
                }(e3, t3, $);
              case "percent":
                return t3 = s(t3, $.currentPercentageDefaultFormat()), function(e4, t4, r4, n3) {
                  var i3 = t4.prefixSymbol, a3 = m({ instance: n3(100 * e4._value), providedFormat: t4, state: r4 }), o2 = Object.assign({}, V, t4);
                  if (i3)
                    return "%".concat(o2.spaceSeparated ? " " : "").concat(a3);
                  return "".concat(a3).concat(o2.spaceSeparated ? " " : "", "%");
                }(e3, t3, $, r3);
              case "byte":
                return t3 = s(t3, $.currentByteDefaultFormat()), function(e4, t4, r4, n3) {
                  var i3 = t4.base || "binary", a3 = Object.assign({}, V, t4), o2 = r4.currentBytes(), u2 = o2.binarySuffixes, c2 = o2.decimalSuffixes, s2 = { general: { scale: 1024, suffixes: c2 || h, marker: "bd" }, binary: { scale: 1024, suffixes: u2 || d, marker: "b" }, decimal: { scale: 1e3, suffixes: c2 || h, marker: "d" } }[i3], l = v(e4._value, s2.suffixes, s2.scale), f = l.value, g2 = l.suffix, p = m({ instance: n3(f), providedFormat: t4, state: r4, defaults: r4.currentByteDefaultFormat() });
                  return "".concat(p).concat(a3.spaceSeparated ? " " : "").concat(g2);
                }(e3, t3, $, r3);
              case "time":
                return t3 = s(t3, $.currentTimeDefaultFormat()), function(e4) {
                  var t4 = Math.floor(e4._value / 60 / 60), r4 = Math.floor((e4._value - 60 * t4 * 60) / 60), n3 = Math.round(e4._value - 60 * t4 * 60 - 60 * r4);
                  return "".concat(t4, ":").concat(r4 < 10 ? "0" : "").concat(r4, ":").concat(n3 < 10 ? "0" : "").concat(n3);
                }(e3);
              case "ordinal":
                return t3 = s(t3, $.currentOrdinalDefaultFormat()), function(e4, t4, r4) {
                  var n3 = r4.currentOrdinal(), i3 = Object.assign({}, V, t4), a3 = m({ instance: e4, providedFormat: t4, state: r4 }), o2 = n3(e4._value);
                  return "".concat(a3).concat(i3.spaceSeparated ? " " : "").concat(o2);
                }(e3, t3, $);
              case "number":
              default:
                return m({ instance: e3, providedFormat: t3, numbro: r3 });
            }
          }(e2, t2, r2);
          return a2 = (a2 = n2 + a2) + i2;
        }
        function v(e2, t2, r2) {
          var n2 = t2[0], i2 = Math.abs(e2);
          if (r2 <= i2) {
            for (var a2 = 1; a2 < t2.length; ++a2) {
              var o2 = Math.pow(r2, a2), u2 = Math.pow(r2, a2 + 1);
              if (o2 <= i2 && i2 < u2) {
                n2 = t2[a2], e2 /= o2;
                break;
              }
            }
            n2 === t2[0] && (e2 /= Math.pow(r2, t2.length - 1), n2 = t2[t2.length - 1]);
          }
          return { value: e2, suffix: n2 };
        }
        function g(e2) {
          for (var t2 = "", r2 = 0; r2 < e2; r2++)
            t2 += "0";
          return t2;
        }
        function q(e2, t2, r2) {
          var n2 = 2 < arguments.length && void 0 !== r2 ? r2 : Math.round;
          return -1 !== e2.toString().indexOf("e") ? function(e3, t3) {
            var r3 = e3.toString(), n3 = I(r3.split("e"), 2), i2 = n3[0], a2 = n3[1], o2 = I(i2.split("."), 2), u2 = o2[0], c2 = o2[1], s2 = void 0 === c2 ? "" : c2;
            if (0 < +a2)
              r3 = u2 + s2 + g(a2 - s2.length);
            else {
              var l = ".";
              l = +u2 < 0 ? "-0".concat(l) : "0".concat(l);
              var f = (g(-a2 - 1) + Math.abs(u2) + s2).substr(0, t3);
              f.length < t3 && (f += g(t3 - f.length)), r3 = l + f;
            }
            return 0 < +a2 && 0 < t3 && (r3 += ".".concat(g(t3))), r3;
          }(e2, t2) : new i(n2(+"".concat(e2, "e+").concat(t2)) / Math.pow(10, t2)).toFixed(t2);
        }
        function Z(e2, t2, r2, n2, i2) {
          var a2 = n2.currentDelimiters(), o2 = a2.thousands;
          i2 = i2 || a2.decimal;
          var u2 = a2.thousandsSize || 3, c2 = e2.toString(), s2 = c2.split(".")[0], l = c2.split(".")[1], f = t2 < 0 && 0 === s2.indexOf("-");
          r2 && (f && (s2 = s2.slice(1)), function(e3, t3) {
            for (var r3 = [], n3 = 0, i3 = e3; 0 < i3; i3--)
              n3 === t3 && (r3.unshift(i3), n3 = 0), n3++;
            return r3;
          }(s2.length, u2).forEach(function(e3, t3) {
            s2 = s2.slice(0, e3 + t3) + o2 + s2.slice(e3 + t3);
          }), f && (s2 = "-".concat(s2)));
          return c2 = l ? s2 + i2 + l : s2;
        }
        function m(e2) {
          var t2 = e2.instance, r2 = e2.providedFormat, n2 = e2.state, i2 = void 0 === n2 ? $ : n2, a2 = e2.decimalSeparator, o2 = e2.defaults, u2 = void 0 === o2 ? i2.currentDefaults() : o2, c2 = t2._value;
          if (0 === c2 && i2.hasZeroFormat())
            return i2.getZeroFormat();
          if (!isFinite(c2))
            return c2.toString();
          var s2, l, f, g2, p, d2, h2, v2, m2 = Object.assign({}, V, u2, r2), y = m2.totalLength, b = y ? 0 : m2.characteristic, w = m2.optionalCharacteristic, S = m2.forceAverage, O = m2.lowPrecision, x = !!y || !!S || m2.average, N = y ? -1 : x && void 0 === r2.mantissa ? 0 : m2.mantissa, B = !y && (void 0 === r2.optionalMantissa ? -1 === N : m2.optionalMantissa), M = m2.trimMantissa, A = m2.thousandSeparated, D = m2.spaceSeparated, E = m2.negative, F = m2.forceSign, k = m2.exponential, _ = m2.roundingFunction, L = "";
          if (x) {
            var j = function(e3) {
              var t3 = e3.value, r3 = e3.forceAverage, n3 = e3.lowPrecision, i3 = void 0 === n3 || n3, a3 = e3.abbreviations, o3 = e3.spaceSeparated, u3 = void 0 !== o3 && o3, c3 = e3.totalLength, s3 = void 0 === c3 ? 0 : c3, l2 = e3.roundingFunction, f2 = void 0 === l2 ? Math.round : l2, g3 = "", p2 = Math.abs(t3), d3 = -1;
              if (r3 && a3[r3] && G[r3] ? (g3 = a3[r3], t3 /= G[r3]) : p2 >= G.trillion || i3 && 1 === f2(p2 / G.trillion) ? (g3 = a3.trillion, t3 /= G.trillion) : p2 < G.trillion && p2 >= G.billion || i3 && 1 === f2(p2 / G.billion) ? (g3 = a3.billion, t3 /= G.billion) : p2 < G.billion && p2 >= G.million || i3 && 1 === f2(p2 / G.million) ? (g3 = a3.million, t3 /= G.million) : (p2 < G.million && p2 >= G.thousand || i3 && 1 === f2(p2 / G.thousand)) && (g3 = a3.thousand, t3 /= G.thousand), g3 = g3 && (u3 ? " " : "") + g3, s3) {
                var h3 = t3 < 0, v3 = t3.toString().split(".")[0], m3 = h3 ? v3.length - 1 : v3.length;
                d3 = Math.max(s3 - m3, 0);
              }
              return { value: t3, abbreviation: g3, mantissaPrecision: d3 };
            }({ value: c2, forceAverage: S, lowPrecision: O, abbreviations: i2.currentAbbreviations(), spaceSeparated: D, roundingFunction: _, totalLength: y });
            c2 = j.value, L += j.abbreviation, y && (N = j.mantissaPrecision);
          }
          if (k) {
            var P = (l = (s2 = { value: c2, characteristicPrecision: b }).value, f = s2.characteristicPrecision, g2 = void 0 === f ? 0 : f, p = I(l.toExponential().split("e"), 2), d2 = p[0], h2 = p[1], v2 = +d2, g2 && 1 < g2 && (v2 *= Math.pow(10, g2 - 1), h2 = 0 <= (h2 -= g2 - 1) ? "+".concat(h2) : h2), { value: v2, abbreviation: "e".concat(h2) });
            c2 = P.value, L = P.abbreviation + L;
          }
          var T, C, U, R = function(e3, t3, r3, n3, i3, a3) {
            if (-1 === n3)
              return e3;
            var o3 = q(t3, n3, a3), u3 = I(o3.toString().split("."), 2), c3 = u3[0], s3 = u3[1], l2 = void 0 === s3 ? "" : s3;
            if (l2.match(/^0+$/) && (r3 || i3))
              return c3;
            var f2 = l2.match(/0+$/);
            return i3 && f2 ? "".concat(c3, ".").concat(l2.toString().slice(0, f2.index)) : o3.toString();
          }(c2.toString(), c2, B, N, M, _);
          return R = Z(R = function(e3, t3, r3, n3) {
            var i3 = e3, a3 = I(i3.toString().split("."), 2), o3 = a3[0], u3 = a3[1];
            if (o3.match(/^-?0$/) && r3)
              return u3 ? "".concat(o3.replace("0", ""), ".").concat(u3) : o3.replace("0", "");
            var c3 = t3 < 0 && 0 === o3.indexOf("-");
            if (c3 && (o3 = o3.slice(1), i3 = i3.slice(1)), o3.length < n3)
              for (var s3 = n3 - o3.length, l2 = 0; l2 < s3; l2++)
                i3 = "0".concat(i3);
            return c3 && (i3 = "-".concat(i3)), i3.toString();
          }(R, c2, w, b), c2, A, i2, a2), (x || k) && (R = R + L), (F || c2 < 0) && (T = R, U = E, R = 0 === (C = c2) ? T : 0 == +T ? T.replace("-", "") : 0 < C ? "+".concat(T) : "sign" === U ? T : "(".concat(T.replace("-", ""), ")")), R;
        }
        function s(e2, t2) {
          if (!e2)
            return t2;
          var r2 = Object.keys(e2);
          return 1 === r2.length && "output" === r2[0] ? t2 : e2;
        }
        t.exports = function(n2) {
          return { format: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return c.apply(void 0, t2.concat([n2]));
          }, getByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = a.general;
              return v(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getBinaryByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = a.binary;
              return v(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getDecimalByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = a.decimal;
              return v(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, formatOrDefault: s };
        };
      }, { "./globalState": 4, "./parsing": 8, "./validating": 10, "bignumber.js": 1 }], 4: [function(e, t, r) {
        var i = e("./en-US"), n = e("./validating"), a = e("./parsing"), o = {}, u = void 0, c = {}, s = null, l = {};
        function f(e2) {
          u = e2;
        }
        function g() {
          return c[u];
        }
        o.languages = function() {
          return Object.assign({}, c);
        }, o.currentLanguage = function() {
          return u;
        }, o.currentBytes = function() {
          return g().bytes || {};
        }, o.currentCurrency = function() {
          return g().currency;
        }, o.currentAbbreviations = function() {
          return g().abbreviations;
        }, o.currentDelimiters = function() {
          return g().delimiters;
        }, o.currentOrdinal = function() {
          return g().ordinal;
        }, o.currentDefaults = function() {
          return Object.assign({}, g().defaults, l);
        }, o.currentOrdinalDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().ordinalFormat);
        }, o.currentByteDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().byteFormat);
        }, o.currentPercentageDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().percentageFormat);
        }, o.currentCurrencyDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().currencyFormat);
        }, o.currentTimeDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().timeFormat);
        }, o.setDefaults = function(e2) {
          e2 = a.parseFormat(e2), n.validateFormat(e2) && (l = e2);
        }, o.getZeroFormat = function() {
          return s;
        }, o.setZeroFormat = function(e2) {
          return s = "string" == typeof e2 ? e2 : null;
        }, o.hasZeroFormat = function() {
          return null !== s;
        }, o.languageData = function(e2) {
          if (e2) {
            if (c[e2])
              return c[e2];
            throw new Error('Unknown tag "'.concat(e2, '"'));
          }
          return g();
        }, o.registerLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          if (!n.validateLanguage(e2))
            throw new Error("Invalid language data");
          c[e2.languageTag] = e2, t2 && f(e2.languageTag);
        }, o.setLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : i.languageTag;
          if (!c[e2]) {
            var r2 = e2.split("-")[0], n2 = Object.keys(c).find(function(e3) {
              return e3.split("-")[0] === r2;
            });
            return c[n2] ? void f(n2) : void f(t2);
          }
          f(e2);
        }, o.registerLanguage(i), u = i.languageTag, t.exports = o;
      }, { "./en-US": 2, "./parsing": 8, "./validating": 10 }], 5: [function(n, e, t) {
        e.exports = function(t2) {
          return { loadLanguagesInNode: function(e2) {
            return r = t2, void e2.forEach(function(t3) {
              var e3 = void 0;
              try {
                e3 = n("../languages/".concat(t3));
              } catch (e4) {
                console.error('Unable to load "'.concat(t3, '". No matching language file found.'));
              }
              e3 && r.registerLanguage(e3);
            });
            var r;
          } };
        };
      }, {}], 6: [function(e, t, r) {
        var c = e("bignumber.js");
        function a(e2, t2, r2) {
          var n = new c(e2._value), i = t2;
          return r2.isNumbro(t2) && (i = t2._value), i = new c(i), e2._value = n.minus(i).toNumber(), e2;
        }
        t.exports = function(u) {
          return { add: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.plus(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, subtract: function(e2, t2) {
            return a(e2, t2, u);
          }, multiply: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.times(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, divide: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.dividedBy(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, set: function(e2, t2) {
            return r2 = e2, i = n = t2, u.isNumbro(n) && (i = n._value), r2._value = i, r2;
            var r2, n, i;
          }, difference: function(e2, t2) {
            return r2 = t2, a(i = (n = u)(e2._value), r2, n), Math.abs(i._value);
            var r2, n, i;
          }, BigNumber: c };
        };
      }, { "bignumber.js": 1 }], 7: [function(e, t, r) {
        function i(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var a = e("./globalState"), n = e("./validating"), o = e("./loading")(p), u = e("./unformatting"), c = e("./formatting")(p), s = e("./manipulating")(p), l = e("./parsing"), f = function() {
          function t2(e3) {
            !function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, t2), this._value = e3;
          }
          var e2, r2;
          return e2 = t2, (r2 = [{ key: "clone", value: function() {
            return p(this._value);
          } }, { key: "format", value: function(e3) {
            var t3 = 0 < arguments.length && void 0 !== e3 ? e3 : {};
            return c.format(this, t3);
          } }, { key: "formatCurrency", value: function(e3) {
            return "string" == typeof e3 && (e3 = l.parseFormat(e3)), (e3 = c.formatOrDefault(e3, a.currentCurrencyDefaultFormat())).output = "currency", c.format(this, e3);
          } }, { key: "formatTime", value: function(e3) {
            var t3 = 0 < arguments.length && void 0 !== e3 ? e3 : {};
            return t3.output = "time", c.format(this, t3);
          } }, { key: "binaryByteUnits", value: function() {
            return c.getBinaryByteUnit(this);
          } }, { key: "decimalByteUnits", value: function() {
            return c.getDecimalByteUnit(this);
          } }, { key: "byteUnits", value: function() {
            return c.getByteUnit(this);
          } }, { key: "difference", value: function(e3) {
            return s.difference(this, e3);
          } }, { key: "add", value: function(e3) {
            return s.add(this, e3);
          } }, { key: "subtract", value: function(e3) {
            return s.subtract(this, e3);
          } }, { key: "multiply", value: function(e3) {
            return s.multiply(this, e3);
          } }, { key: "divide", value: function(e3) {
            return s.divide(this, e3);
          } }, { key: "set", value: function(e3) {
            return s.set(this, g(e3));
          } }, { key: "value", value: function() {
            return this._value;
          } }, { key: "valueOf", value: function() {
            return this._value;
          } }]) && i(e2.prototype, r2), t2;
        }();
        function g(e2) {
          var t2 = e2;
          return p.isNumbro(e2) ? t2 = e2._value : "string" == typeof e2 ? t2 = p.unformat(e2) : isNaN(e2) && (t2 = NaN), t2;
        }
        function p(e2) {
          return new f(g(e2));
        }
        p.version = "2.3.6", p.isNumbro = function(e2) {
          return e2 instanceof f;
        }, p.language = a.currentLanguage, p.registerLanguage = a.registerLanguage, p.setLanguage = a.setLanguage, p.languages = a.languages, p.languageData = a.languageData, p.zeroFormat = a.setZeroFormat, p.defaultFormat = a.currentDefaults, p.setDefaults = a.setDefaults, p.defaultCurrencyFormat = a.currentCurrencyDefaultFormat, p.validate = n.validate, p.loadLanguagesInNode = o.loadLanguagesInNode, p.unformat = u.unformat, p.BigNumber = s.BigNumber, t.exports = p;
      }, { "./formatting": 3, "./globalState": 4, "./loading": 5, "./manipulating": 6, "./parsing": 8, "./unformatting": 9, "./validating": 10 }], 8: [function(e, t, r) {
        t.exports = { parseFormat: function(e2) {
          var t2, r2, n, i, a, o, u, c, s, l, f, g, p, d, h, v, m, y, b, w, S, O, x = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          return "string" != typeof e2 ? e2 : (r2 = x, e2 = (n = (t2 = e2).match(/^{([^}]*)}/)) ? (r2.prefix = n[1], t2.slice(n[0].length)) : t2, a = x, function(e3, t3) {
            if (-1 === e3.indexOf("$")) {
              if (-1 === e3.indexOf("%"))
                return -1 !== e3.indexOf("bd") ? (t3.output = "byte", t3.base = "general") : -1 !== e3.indexOf("b") ? (t3.output = "byte", t3.base = "binary") : -1 !== e3.indexOf("d") ? (t3.output = "byte", t3.base = "decimal") : -1 === e3.indexOf(":") ? -1 !== e3.indexOf("o") && (t3.output = "ordinal") : t3.output = "time";
              t3.output = "percent";
            } else
              t3.output = "currency";
          }(e2 = (o = (i = e2).match(/{([^}]*)}$/)) ? (a.postfix = o[1], i.slice(0, -o[0].length)) : i, x), u = x, (c = e2.match(/[1-9]+[0-9]*/)) && (u.totalLength = +c[0]), s = x, (l = e2.split(".")[0].match(/0+/)) && (s.characteristic = l[0].length), function(e3, t3) {
            if (-1 !== e3.indexOf(".")) {
              var r3 = e3.split(".")[0];
              t3.optionalCharacteristic = -1 === r3.indexOf("0");
            }
          }(e2, x), f = x, -1 !== e2.indexOf("a") && (f.average = true), p = x, -1 !== (g = e2).indexOf("K") ? p.forceAverage = "thousand" : -1 !== g.indexOf("M") ? p.forceAverage = "million" : -1 !== g.indexOf("B") ? p.forceAverage = "billion" : -1 !== g.indexOf("T") && (p.forceAverage = "trillion"), function(e3, t3) {
            var r3 = e3.split(".")[1];
            if (r3) {
              var n2 = r3.match(/0+/);
              n2 && (t3.mantissa = n2[0].length);
            }
          }(e2, x), h = x, (d = e2).match(/\[\.]/) ? h.optionalMantissa = true : d.match(/\./) && (h.optionalMantissa = false), v = x, (m = e2.split(".")[1]) && (v.trimMantissa = -1 !== m.indexOf("[")), y = x, -1 !== e2.indexOf(",") && (y.thousandSeparated = true), b = x, -1 !== e2.indexOf(" ") && (b.spaceSeparated = true, b.spaceSeparatedCurrency = true, (b.average || b.forceAverage) && (b.spaceSeparatedAbbreviation = true)), S = x, (w = e2).match(/^\+?\([^)]*\)$/) && (S.negative = "parenthesis"), w.match(/^\+?-/) && (S.negative = "sign"), O = x, e2.match(/^\+/) && (O.forceSign = true), x);
        } };
      }, {}], 9: [function(g, e, t) {
        var M = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
        function A(e2) {
          return e2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function p(e2, t2, r, n, i, a, o) {
          var u = 2 < arguments.length && void 0 !== r ? r : "", c = 3 < arguments.length ? n : void 0, s = 4 < arguments.length ? i : void 0, l = 5 < arguments.length ? a : void 0, f = 6 < arguments.length ? o : void 0;
          if ("" !== e2)
            return e2 === s ? 0 : function e3(t3, r2, n2, i2, a2, o2, u2) {
              var c2 = 2 < arguments.length && void 0 !== n2 ? n2 : "", s2 = 3 < arguments.length ? i2 : void 0, l2 = 4 < arguments.length ? a2 : void 0, f2 = 5 < arguments.length ? o2 : void 0, g2 = 6 < arguments.length ? u2 : void 0;
              if (!isNaN(+t3))
                return +t3;
              var p2 = "", d = t3.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
              if (d !== t3)
                return -1 * e3(d, r2, c2, s2, l2, f2, g2);
              for (var h = 0; h < M.length; h++) {
                var v = M[h];
                if ((p2 = t3.replace(RegExp("([0-9 ])(".concat(v.key, ")$")), "$1")) !== t3)
                  return e3(p2, r2, c2, s2, l2, f2, g2) * v.factor;
              }
              if ((p2 = t3.replace("%", "")) !== t3)
                return e3(p2, r2, c2, s2, l2, f2, g2) / 100;
              var m = parseFloat(t3);
              if (!isNaN(m)) {
                var y = s2(m);
                if (y && "." !== y && (p2 = t3.replace(new RegExp("".concat(A(y), "$")), "")) !== t3)
                  return e3(p2, r2, c2, s2, l2, f2, g2);
                var b = {};
                Object.keys(f2).forEach(function(e4) {
                  b[f2[e4]] = e4;
                });
                for (var w = Object.keys(b).sort().reverse(), S = w.length, O = 0; O < S; O++) {
                  var x = w[O], N = b[x];
                  if ((p2 = t3.replace(x, "")) !== t3) {
                    var B = void 0;
                    switch (N) {
                      case "thousand":
                        B = Math.pow(10, 3);
                        break;
                      case "million":
                        B = Math.pow(10, 6);
                        break;
                      case "billion":
                        B = Math.pow(10, 9);
                        break;
                      case "trillion":
                        B = Math.pow(10, 12);
                    }
                    return e3(p2, r2, c2, s2, l2, f2, g2) * B;
                  }
                }
              }
            }(function(e3, t3, r2) {
              var n2 = 2 < arguments.length && void 0 !== r2 ? r2 : "", i2 = e3.replace(n2, "");
              return i2 = (i2 = i2.replace(new RegExp("([0-9])".concat(A(t3.thousands), "([0-9])"), "g"), "$1$2")).replace(t3.decimal, ".");
            }(e2, t2, u), t2, u, c, s, l, f);
        }
        e.exports = { unformat: function(e2, t2) {
          var r, n, i, a = g("./globalState"), o = a.currentDelimiters(), u = a.currentCurrency().symbol, c = a.currentOrdinal(), s = a.getZeroFormat(), l = a.currentAbbreviations(), f = void 0;
          if ("string" == typeof e2)
            f = function(e3, t3) {
              if (e3.indexOf(":") && ":" !== t3.thousands) {
                var r2 = e3.split(":");
                if (3 === r2.length) {
                  var n2 = +r2[0], i2 = +r2[1], a2 = +r2[2];
                  return !isNaN(n2) && !isNaN(i2) && !isNaN(a2);
                }
              }
            }(e2, o) ? (r = e2.split(":"), n = +r[0], i = +r[1], +r[2] + 60 * i + 3600 * n) : p(e2, o, u, c, s, l, t2);
          else {
            if ("number" != typeof e2)
              return;
            f = e2;
          }
          if (void 0 !== f)
            return f;
        } };
      }, { "./globalState": 4 }], 10: [function(e, t, r) {
        function n(e2) {
          return function(e3) {
            if (Array.isArray(e3)) {
              for (var t2 = 0, r2 = new Array(e3.length); t2 < e3.length; t2++)
                r2[t2] = e3[t2];
              return r2;
            }
          }(e2) || function(e3) {
            if (Symbol.iterator in Object(e3) || "[object Arguments]" === Object.prototype.toString.call(e3))
              return Array.from(e3);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }();
        }
        function f(e2) {
          return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var i = e("./unformatting"), a = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, g = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: function(e2, t2) {
          return "byte" === t2.output;
        }, message: "`base` must be provided only when the output is `byte`", mandatory: function(e2) {
          return "byte" === e2.output;
        } }, characteristic: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", lowPrecision: { type: "boolean", restriction: function(e2, t2) {
          return true === t2.average;
        }, message: "`lowPrecision` must be provided only when the option `average` is set" }, currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, { restriction: function(e2, t2) {
          return !t2.exponential;
        }, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", roundingFunction: "function", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", spaceSeparatedAbbreviation: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: function(e2, t2) {
          return "percent" === t2.output;
        }, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, o = { languageTag: { type: "string", mandatory: true, restriction: function(e2) {
          return e2.match(a);
        }, message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", ordinal: { type: "function", mandatory: true }, bytes: { type: "object", children: { binarySuffixes: "object", decimalSuffixes: "object" } }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
        function u(e2) {
          return void 0 !== i.unformat(e2);
        }
        function p(c2, s, l, e2) {
          var t2 = 3 < arguments.length && void 0 !== e2 && e2, r2 = Object.keys(c2).map(function(e3) {
            if (!s[e3])
              return console.error("".concat(l, " Invalid key: ").concat(e3)), false;
            var t3 = c2[e3], r3 = s[e3];
            if ("string" == typeof r3 && (r3 = { type: r3 }), "format" === r3.type) {
              if (!p(t3, g, "[Validate ".concat(e3, "]"), true))
                return false;
            } else if (f(t3) !== r3.type)
              return console.error("".concat(l, " ").concat(e3, ' type mismatched: "').concat(r3.type, '" expected, "').concat(f(t3), '" provided')), false;
            if (r3.restrictions && r3.restrictions.length)
              for (var n2 = r3.restrictions.length, i2 = 0; i2 < n2; i2++) {
                var a2 = r3.restrictions[i2], o2 = a2.restriction, u2 = a2.message;
                if (!o2(t3, c2))
                  return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(u2)), false;
              }
            if (r3.restriction && !r3.restriction(t3, c2))
              return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(r3.message)), false;
            if (r3.validValues && -1 === r3.validValues.indexOf(t3))
              return console.error("".concat(l, " ").concat(e3, " invalid value: must be among ").concat(JSON.stringify(r3.validValues), ', "').concat(t3, '" provided')), false;
            if (r3.children && !p(t3, r3.children, "[Validate ".concat(e3, "]")))
              return false;
            return true;
          });
          return t2 || r2.push.apply(r2, n(Object.keys(s).map(function(e3) {
            var t3 = s[e3];
            if ("string" == typeof t3 && (t3 = { type: t3 }), t3.mandatory) {
              var r3 = t3.mandatory;
              if ("function" == typeof r3 && (r3 = r3(c2)), r3 && void 0 === c2[e3])
                return console.error("".concat(l, ' Missing mandatory key "').concat(e3, '"')), false;
            }
            return true;
          }))), r2.reduce(function(e3, t3) {
            return e3 && t3;
          }, true);
        }
        function c(e2) {
          return p(e2, g, "[Validate format]");
        }
        t.exports = { validate: function(e2, t2) {
          var r2 = u(e2), n2 = c(t2);
          return r2 && n2;
        }, validateFormat: c, validateInput: u, validateLanguage: function(e2) {
          return p(e2, o, "[Validate language]");
        } };
      }, { "./unformatting": 9 }] }, {}, [7])(7);
    });
  })(numbro_min);
  var numbro_minExports = numbro_min.exports;
  const numbro = /* @__PURE__ */ getDefaultExportFromCjs(numbro_minExports);
  function formatNumber(number, format2, showNumberScale = true) {
    var _a;
    let numberFormatOptions = getFormatOptions(format2);
    let isCustomRound = true;
    const {
      decimalPlaces,
      isThousandsSeparated = false,
      prefix = "",
      suffix = "",
      isPercent = false
    } = numberFormatOptions ?? {};
    const showAverage = showNumberScale !== false;
    const numbroOptions = {
      prefix,
      postfix: suffix,
      thousandSeparated: isThousandsSeparated,
      output: isPercent ? "percent" : "number",
      average: showAverage
    };
    const absNum = Math.abs(number);
    if (decimalPlaces !== void 0) {
      numbroOptions.mantissa = decimalPlaces;
      if (decimalPlaces === 0 && isCustomRound) {
        numbroOptions.trimMantissa = true;
        if (absNum >= 0.1) {
          numbroOptions.mantissa = 2;
        } else if (absNum >= 0.01) {
          numbroOptions.mantissa = 3;
        } else if (absNum >= 1e-3) {
          numbroOptions.mantissa = 5;
        } else if (absNum >= 1e-4) {
          numbroOptions.mantissa = 6;
        } else if (absNum >= 1e-5) {
          numbroOptions.mantissa = 7;
        } else if (absNum >= 1e-6) {
          numbroOptions.mantissa = 8;
        }
      }
    }
    if (decimalPlaces === void 0 && showAverage) {
      numbroOptions.mantissa = MAX_MANTISSA;
      numbroOptions.trimMantissa = true;
    }
    if (showAverage) {
      const NumberScales = [
        { key: "trillion", value: 1e12 },
        { key: "billion", value: 1e9 },
        { key: "million", value: 1e6 },
        { key: "thousand", value: 1e3 }
      ];
      for (let i = 0; i < NumberScales.length; i++) {
        if (Math.abs(number) >= NumberScales[i].value) {
          numbroOptions.forceAverage = NumberScales[i].key;
          break;
        }
      }
    }
    return (_a = numbro(number).format(numbroOptions)) == null ? void 0 : _a.toUpperCase();
  }
  function getFormatOptions(value) {
    var _a, _b;
    if (!value) {
      value = "###,##0.00";
    }
    const [, prefix, thousandsFormat, decimalFormat, percent, suffix] = /^('[^']+'|[^0#.%';]*)([#]*,[#]*)?([0#]*\.[0#]*)?(#*%)?('[^']+'|[^0#.%';]*)/g.exec(value) ?? [];
    let decimalPlaces = 0;
    if (decimalFormat == null ? void 0 : decimalFormat.length) {
      decimalPlaces = (_b = (_a = /\.(0+)/g.exec(decimalFormat)) == null ? void 0 : _a[1]) == null ? void 0 : _b.length;
    }
    const unwrappedPrefix = prefix.replace(/'/g, "");
    const unwrappedSuffix = suffix.replace(/'/g, "");
    return {
      decimalPlaces,
      isThousandsSeparated: !!thousandsFormat,
      prefix: unwrappedPrefix,
      suffix: unwrappedSuffix,
      isPercent: !!percent
    };
  }
  var chartjsPluginDatalabels = { exports: {} };
  /*!
   * chartjs-plugin-datalabels v1.0.0
   * https://chartjs-plugin-datalabels.netlify.app
   * (c) 2017-2021 chartjs-plugin-datalabels contributors
   * Released under the MIT license
   */
  (function(module2, exports) {
    (function(global2, factory) {
      module2.exports = factory(requireChart());
    })(commonjsGlobal, function(Chart2) {
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var Chart__default = /* @__PURE__ */ _interopDefaultLegacy(Chart2);
      var helpers$4 = Chart__default["default"].helpers;
      var devicePixelRatio = function() {
        if (typeof window !== "undefined") {
          if (window.devicePixelRatio) {
            return window.devicePixelRatio;
          }
          var screen = window.screen;
          if (screen) {
            return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
          }
        }
        return 1;
      }();
      var utils = {
        // @todo move this in Chart.helpers.toTextLines
        toTextLines: function(inputs) {
          var lines = [];
          var input;
          inputs = [].concat(inputs);
          while (inputs.length) {
            input = inputs.pop();
            if (typeof input === "string") {
              lines.unshift.apply(lines, input.split("\n"));
            } else if (Array.isArray(input)) {
              inputs.push.apply(inputs, input);
            } else if (!helpers$4.isNullOrUndef(inputs)) {
              lines.unshift("" + input);
            }
          }
          return lines;
        },
        // @todo move this method in Chart.helpers.canvas.toFont (deprecates helpers.fontString)
        // @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
        toFontString: function(font) {
          if (!font || helpers$4.isNullOrUndef(font.size) || helpers$4.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        },
        // @todo move this in Chart.helpers.canvas.textSize
        // @todo cache calls of measureText if font doesn't change?!
        textSize: function(ctx, lines, font) {
          var items = [].concat(lines);
          var ilen = items.length;
          var prev = ctx.font;
          var width = 0;
          var i;
          ctx.font = font.string;
          for (i = 0; i < ilen; ++i) {
            width = Math.max(ctx.measureText(items[i]).width, width);
          }
          ctx.font = prev;
          return {
            height: ilen * font.lineHeight,
            width
          };
        },
        // @todo move this method in Chart.helpers.options.toFont
        parseFont: function(value) {
          var global2 = Chart__default["default"].defaults.global;
          var size = helpers$4.valueOrDefault(value.size, global2.defaultFontSize);
          var font = {
            family: helpers$4.valueOrDefault(value.family, global2.defaultFontFamily),
            lineHeight: helpers$4.options.toLineHeight(value.lineHeight, size),
            size,
            style: helpers$4.valueOrDefault(value.style, global2.defaultFontStyle),
            weight: helpers$4.valueOrDefault(value.weight, null),
            string: ""
          };
          font.string = utils.toFontString(font);
          return font;
        },
        /**
         * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
         * @todo move this method in Chart.helpers.bound
         * https://doc.qt.io/qt-5/qtglobal.html#qBound
         */
        bound: function(min2, value, max2) {
          return Math.max(min2, Math.min(value, max2));
        },
        /**
         * Returns an array of pair [value, state] where state is:
         * * -1: value is only in a0 (removed)
         * *  1: value is only in a1 (added)
         */
        arrayDiff: function(a0, a1) {
          var prev = a0.slice();
          var updates = [];
          var i, j, ilen, v;
          for (i = 0, ilen = a1.length; i < ilen; ++i) {
            v = a1[i];
            j = prev.indexOf(v);
            if (j === -1) {
              updates.push([v, 1]);
            } else {
              prev.splice(j, 1);
            }
          }
          for (i = 0, ilen = prev.length; i < ilen; ++i) {
            updates.push([prev[i], -1]);
          }
          return updates;
        },
        /**
         * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
         */
        rasterize: function(v) {
          return Math.round(v * devicePixelRatio) / devicePixelRatio;
        }
      };
      function orient(point, origin) {
        var x0 = origin.x;
        var y0 = origin.y;
        if (x0 === null) {
          return { x: 0, y: -1 };
        }
        if (y0 === null) {
          return { x: 1, y: 0 };
        }
        var dx = point.x - x0;
        var dy = point.y - y0;
        var ln = Math.sqrt(dx * dx + dy * dy);
        return {
          x: ln ? dx / ln : 0,
          y: ln ? dy / ln : -1
        };
      }
      function aligned(x, y, vx, vy, align) {
        switch (align) {
          case "center":
            vx = vy = 0;
            break;
          case "bottom":
            vx = 0;
            vy = 1;
            break;
          case "right":
            vx = 1;
            vy = 0;
            break;
          case "left":
            vx = -1;
            vy = 0;
            break;
          case "top":
            vx = 0;
            vy = -1;
            break;
          case "start":
            vx = -vx;
            vy = -vy;
            break;
          case "end":
            break;
          default:
            align *= Math.PI / 180;
            vx = Math.cos(align);
            vy = Math.sin(align);
            break;
        }
        return {
          x,
          y,
          vx,
          vy
        };
      }
      var R_INSIDE = 0;
      var R_LEFT = 1;
      var R_RIGHT = 2;
      var R_BOTTOM = 4;
      var R_TOP = 8;
      function region(x, y, rect) {
        var res = R_INSIDE;
        if (x < rect.left) {
          res |= R_LEFT;
        } else if (x > rect.right) {
          res |= R_RIGHT;
        }
        if (y < rect.top) {
          res |= R_TOP;
        } else if (y > rect.bottom) {
          res |= R_BOTTOM;
        }
        return res;
      }
      function clipped(segment, area) {
        var x0 = segment.x0;
        var y0 = segment.y0;
        var x1 = segment.x1;
        var y1 = segment.y1;
        var r0 = region(x0, y0, area);
        var r1 = region(x1, y1, area);
        var r, x, y;
        while (true) {
          if (!(r0 | r1) || r0 & r1) {
            break;
          }
          r = r0 || r1;
          if (r & R_TOP) {
            x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
            y = area.top;
          } else if (r & R_BOTTOM) {
            x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
            y = area.bottom;
          } else if (r & R_RIGHT) {
            y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
            x = area.right;
          } else if (r & R_LEFT) {
            y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
            x = area.left;
          }
          if (r === r0) {
            x0 = x;
            y0 = y;
            r0 = region(x0, y0, area);
          } else {
            x1 = x;
            y1 = y;
            r1 = region(x1, y1, area);
          }
        }
        return {
          x0,
          x1,
          y0,
          y1
        };
      }
      function compute$1(range, config) {
        var anchor = config.anchor;
        var segment = range;
        var x, y;
        if (config.clamp) {
          segment = clipped(segment, config.area);
        }
        if (anchor === "start") {
          x = segment.x0;
          y = segment.y0;
        } else if (anchor === "end") {
          x = segment.x1;
          y = segment.y1;
        } else {
          x = (segment.x0 + segment.x1) / 2;
          y = (segment.y0 + segment.y1) / 2;
        }
        return aligned(x, y, range.vx, range.vy, config.align);
      }
      var positioners = {
        arc: function(vm, config) {
          var angle = (vm.startAngle + vm.endAngle) / 2;
          var vx = Math.cos(angle);
          var vy = Math.sin(angle);
          var r0 = vm.innerRadius;
          var r1 = vm.outerRadius;
          return compute$1({
            x0: vm.x + vx * r0,
            y0: vm.y + vy * r0,
            x1: vm.x + vx * r1,
            y1: vm.y + vy * r1,
            vx,
            vy
          }, config);
        },
        point: function(vm, config) {
          var v = orient(vm, config.origin);
          var rx = v.x * vm.radius;
          var ry = v.y * vm.radius;
          return compute$1({
            x0: vm.x - rx,
            y0: vm.y - ry,
            x1: vm.x + rx,
            y1: vm.y + ry,
            vx: v.x,
            vy: v.y
          }, config);
        },
        rect: function(vm, config) {
          var v = orient(vm, config.origin);
          var x = vm.x;
          var y = vm.y;
          var sx = 0;
          var sy = 0;
          if (vm.horizontal) {
            x = Math.min(vm.x, vm.base);
            sx = Math.abs(vm.base - vm.x);
          } else {
            y = Math.min(vm.y, vm.base);
            sy = Math.abs(vm.base - vm.y);
          }
          return compute$1({
            x0: x,
            y0: y + sy,
            x1: x + sx,
            y1: y,
            vx: v.x,
            vy: v.y
          }, config);
        },
        fallback: function(vm, config) {
          var v = orient(vm, config.origin);
          return compute$1({
            x0: vm.x,
            y0: vm.y,
            x1: vm.x,
            y1: vm.y,
            vx: v.x,
            vy: v.y
          }, config);
        }
      };
      var helpers$3 = Chart__default["default"].helpers;
      var rasterize = utils.rasterize;
      function boundingRects(model) {
        var borderWidth = model.borderWidth || 0;
        var padding = model.padding;
        var th = model.size.height;
        var tw = model.size.width;
        var tx = -tw / 2;
        var ty = -th / 2;
        return {
          frame: {
            x: tx - padding.left - borderWidth,
            y: ty - padding.top - borderWidth,
            w: tw + padding.width + borderWidth * 2,
            h: th + padding.height + borderWidth * 2
          },
          text: {
            x: tx,
            y: ty,
            w: tw,
            h: th
          }
        };
      }
      function getScaleOrigin(el) {
        var horizontal = el._model.horizontal;
        var scale = el._scale || horizontal && el._xScale || el._yScale;
        if (!scale) {
          return null;
        }
        if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
          return { x: scale.xCenter, y: scale.yCenter };
        }
        var pixel = scale.getBasePixel();
        return horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
      }
      function getPositioner(el) {
        if (el instanceof Chart__default["default"].elements.Arc) {
          return positioners.arc;
        }
        if (el instanceof Chart__default["default"].elements.Point) {
          return positioners.point;
        }
        if (el instanceof Chart__default["default"].elements.Rectangle) {
          return positioners.rect;
        }
        return positioners.fallback;
      }
      function drawFrame(ctx, rect, model) {
        var bgColor = model.backgroundColor;
        var borderColor = model.borderColor;
        var borderWidth = model.borderWidth;
        if (!bgColor && (!borderColor || !borderWidth)) {
          return;
        }
        ctx.beginPath();
        helpers$3.canvas.roundedRect(
          ctx,
          rasterize(rect.x) + borderWidth / 2,
          rasterize(rect.y) + borderWidth / 2,
          rasterize(rect.w) - borderWidth,
          rasterize(rect.h) - borderWidth,
          model.borderRadius
        );
        ctx.closePath();
        if (bgColor) {
          ctx.fillStyle = bgColor;
          ctx.fill();
        }
        if (borderColor && borderWidth) {
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = borderWidth;
          ctx.lineJoin = "miter";
          ctx.stroke();
        }
      }
      function textGeometry(rect, align, font) {
        var h = font.lineHeight;
        var w = rect.w;
        var x = rect.x;
        var y = rect.y + h / 2;
        if (align === "center") {
          x += w / 2;
        } else if (align === "end" || align === "right") {
          x += w;
        }
        return {
          h,
          w,
          x,
          y
        };
      }
      function drawTextLine(ctx, text, cfg) {
        var shadow = ctx.shadowBlur;
        var stroked = cfg.stroked;
        var x = rasterize(cfg.x);
        var y = rasterize(cfg.y);
        var w = rasterize(cfg.w);
        if (stroked) {
          ctx.strokeText(text, x, y, w);
        }
        if (cfg.filled) {
          if (shadow && stroked) {
            ctx.shadowBlur = 0;
          }
          ctx.fillText(text, x, y, w);
          if (shadow && stroked) {
            ctx.shadowBlur = shadow;
          }
        }
      }
      function drawText(ctx, lines, rect, model) {
        var align = model.textAlign;
        var color = model.color;
        var filled = !!color;
        var font = model.font;
        var ilen = lines.length;
        var strokeColor = model.textStrokeColor;
        var strokeWidth = model.textStrokeWidth;
        var stroked = strokeColor && strokeWidth;
        var i;
        if (!ilen || !filled && !stroked) {
          return;
        }
        rect = textGeometry(rect, align, font);
        ctx.font = font.string;
        ctx.textAlign = align;
        ctx.textBaseline = "middle";
        ctx.shadowBlur = model.textShadowBlur;
        ctx.shadowColor = model.textShadowColor;
        if (filled) {
          ctx.fillStyle = color;
        }
        if (stroked) {
          ctx.lineJoin = "round";
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = strokeColor;
        }
        for (i = 0, ilen = lines.length; i < ilen; ++i) {
          drawTextLine(ctx, lines[i], {
            stroked,
            filled,
            w: rect.w,
            x: rect.x,
            y: rect.y + rect.h * i
          });
        }
      }
      var Label = function(config, ctx, el, index2) {
        var me = this;
        me._config = config;
        me._index = index2;
        me._model = null;
        me._rects = null;
        me._ctx = ctx;
        me._el = el;
      };
      helpers$3.extend(Label.prototype, {
        /**
         * @private
         */
        _modelize: function(display, lines, config, context) {
          var me = this;
          var index2 = me._index;
          var resolve = helpers$3.options.resolve;
          var font = utils.parseFont(resolve([config.font, {}], context, index2));
          var color = resolve([config.color, Chart__default["default"].defaults.global.defaultFontColor], context, index2);
          return {
            align: resolve([config.align, "center"], context, index2),
            anchor: resolve([config.anchor, "center"], context, index2),
            area: context.chart.chartArea,
            backgroundColor: resolve([config.backgroundColor, null], context, index2),
            borderColor: resolve([config.borderColor, null], context, index2),
            borderRadius: resolve([config.borderRadius, 0], context, index2),
            borderWidth: resolve([config.borderWidth, 0], context, index2),
            clamp: resolve([config.clamp, false], context, index2),
            clip: resolve([config.clip, false], context, index2),
            color,
            display,
            font,
            lines,
            offset: resolve([config.offset, 0], context, index2),
            opacity: resolve([config.opacity, 1], context, index2),
            origin: getScaleOrigin(me._el),
            padding: helpers$3.options.toPadding(resolve([config.padding, 0], context, index2)),
            positioner: getPositioner(me._el),
            rotation: resolve([config.rotation, 0], context, index2) * (Math.PI / 180),
            size: utils.textSize(me._ctx, lines, font),
            textAlign: resolve([config.textAlign, "start"], context, index2),
            textShadowBlur: resolve([config.textShadowBlur, 0], context, index2),
            textShadowColor: resolve([config.textShadowColor, color], context, index2),
            textStrokeColor: resolve([config.textStrokeColor, color], context, index2),
            textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index2)
          };
        },
        update: function(context) {
          var me = this;
          var model = null;
          var rects = null;
          var index2 = me._index;
          var config = me._config;
          var value, label, lines;
          var display = helpers$3.options.resolve([config.display, true], context, index2);
          if (display) {
            value = context.dataset.data[index2];
            label = helpers$3.valueOrDefault(helpers$3.callback(config.formatter, [value, context]), value);
            lines = helpers$3.isNullOrUndef(label) ? [] : utils.toTextLines(label);
            if (lines.length) {
              model = me._modelize(display, lines, config, context);
              rects = boundingRects(model);
            }
          }
          me._model = model;
          me._rects = rects;
        },
        geometry: function() {
          return this._rects ? this._rects.frame : {};
        },
        rotation: function() {
          return this._model ? this._model.rotation : 0;
        },
        visible: function() {
          return this._model && this._model.opacity;
        },
        model: function() {
          return this._model;
        },
        draw: function(chart, center) {
          var me = this;
          var ctx = chart.ctx;
          var model = me._model;
          var rects = me._rects;
          var area;
          if (!this.visible()) {
            return;
          }
          ctx.save();
          if (model.clip) {
            area = model.area;
            ctx.beginPath();
            ctx.rect(
              area.left,
              area.top,
              area.right - area.left,
              area.bottom - area.top
            );
            ctx.clip();
          }
          ctx.globalAlpha = utils.bound(0, model.opacity, 1);
          ctx.translate(rasterize(center.x), rasterize(center.y));
          ctx.rotate(model.rotation);
          drawFrame(ctx, rects.frame, model);
          drawText(ctx, model.lines, rects.text, model);
          ctx.restore();
        }
      });
      var helpers$2 = Chart__default["default"].helpers;
      var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
      var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      function rotated(point, center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var cx = center.x;
        var cy = center.y;
        return {
          x: cx + cos * (point.x - cx) - sin * (point.y - cy),
          y: cy + sin * (point.x - cx) + cos * (point.y - cy)
        };
      }
      function projected(points, axis) {
        var min2 = MAX_INTEGER;
        var max2 = MIN_INTEGER;
        var origin = axis.origin;
        var i, pt, vx, vy, dp;
        for (i = 0; i < points.length; ++i) {
          pt = points[i];
          vx = pt.x - origin.x;
          vy = pt.y - origin.y;
          dp = axis.vx * vx + axis.vy * vy;
          min2 = Math.min(min2, dp);
          max2 = Math.max(max2, dp);
        }
        return {
          min: min2,
          max: max2
        };
      }
      function toAxis(p0, p1) {
        var vx = p1.x - p0.x;
        var vy = p1.y - p0.y;
        var ln = Math.sqrt(vx * vx + vy * vy);
        return {
          vx: (p1.x - p0.x) / ln,
          vy: (p1.y - p0.y) / ln,
          origin: p0,
          ln
        };
      }
      var HitBox = function() {
        this._rotation = 0;
        this._rect = {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        };
      };
      helpers$2.extend(HitBox.prototype, {
        center: function() {
          var r = this._rect;
          return {
            x: r.x + r.w / 2,
            y: r.y + r.h / 2
          };
        },
        update: function(center, rect, rotation) {
          this._rotation = rotation;
          this._rect = {
            x: rect.x + center.x,
            y: rect.y + center.y,
            w: rect.w,
            h: rect.h
          };
        },
        contains: function(point) {
          var me = this;
          var margin = 1;
          var rect = me._rect;
          point = rotated(point, me.center(), -me._rotation);
          return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
        },
        // Separating Axis Theorem
        // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
        intersects: function(other) {
          var r0 = this._points();
          var r1 = other._points();
          var axes = [
            toAxis(r0[0], r0[1]),
            toAxis(r0[0], r0[3])
          ];
          var i, pr0, pr1;
          if (this._rotation !== other._rotation) {
            axes.push(
              toAxis(r1[0], r1[1]),
              toAxis(r1[0], r1[3])
            );
          }
          for (i = 0; i < axes.length; ++i) {
            pr0 = projected(r0, axes[i]);
            pr1 = projected(r1, axes[i]);
            if (pr0.max < pr1.min || pr1.max < pr0.min) {
              return false;
            }
          }
          return true;
        },
        /**
         * @private
         */
        _points: function() {
          var me = this;
          var rect = me._rect;
          var angle = me._rotation;
          var center = me.center();
          return [
            rotated({ x: rect.x, y: rect.y }, center, angle),
            rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
            rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
            rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
          ];
        }
      });
      function coordinates(view, model, geometry) {
        var point = model.positioner(view, model);
        var vx = point.vx;
        var vy = point.vy;
        if (!vx && !vy) {
          return { x: point.x, y: point.y };
        }
        var w = geometry.w;
        var h = geometry.h;
        var rotation = model.rotation;
        var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
        var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
        var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
        dx *= vx * vs;
        dy *= vy * vs;
        dx += model.offset * vx;
        dy += model.offset * vy;
        return {
          x: point.x + dx,
          y: point.y + dy
        };
      }
      function collide(labels, collider) {
        var i, j, s0, s1;
        for (i = labels.length - 1; i >= 0; --i) {
          s0 = labels[i].$layout;
          for (j = i - 1; j >= 0 && s0._visible; --j) {
            s1 = labels[j].$layout;
            if (s1._visible && s0._box.intersects(s1._box)) {
              collider(s0, s1);
            }
          }
        }
        return labels;
      }
      function compute(labels) {
        var i, ilen, label, state, geometry, center;
        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          state = label.$layout;
          if (state._visible) {
            geometry = label.geometry();
            center = coordinates(label._el._model, label.model(), geometry);
            state._box.update(center, geometry, label.rotation());
          }
        }
        return collide(labels, function(s0, s1) {
          var h0 = s0._hidable;
          var h1 = s1._hidable;
          if (h0 && h1 || h1) {
            s1._visible = false;
          } else if (h0) {
            s0._visible = false;
          }
        });
      }
      var layout = {
        prepare: function(datasets) {
          var labels = [];
          var i, j, ilen, jlen, label;
          for (i = 0, ilen = datasets.length; i < ilen; ++i) {
            for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
              label = datasets[i][j];
              labels.push(label);
              label.$layout = {
                _box: new HitBox(),
                _hidable: false,
                _visible: true,
                _set: i,
                _idx: j
              };
            }
          }
          labels.sort(function(a, b) {
            var sa = a.$layout;
            var sb = b.$layout;
            return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
          });
          this.update(labels);
          return labels;
        },
        update: function(labels) {
          var dirty = false;
          var i, ilen, label, model, state;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            model = label.model();
            state = label.$layout;
            state._hidable = model && model.display === "auto";
            state._visible = label.visible();
            dirty |= state._hidable;
          }
          if (dirty) {
            compute(labels);
          }
        },
        lookup: function(labels, point) {
          var i, state;
          for (i = labels.length - 1; i >= 0; --i) {
            state = labels[i].$layout;
            if (state && state._visible && state._box.contains(point)) {
              return labels[i];
            }
          }
          return null;
        },
        draw: function(chart, labels) {
          var i, ilen, label, state, geometry, center;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
              geometry = label.geometry();
              center = coordinates(label._el._view, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
              label.draw(chart, center);
            }
          }
        }
      };
      var helpers$1 = Chart__default["default"].helpers;
      var formatter = function(value) {
        if (helpers$1.isNullOrUndef(value)) {
          return null;
        }
        var label = value;
        var keys2, klen, k;
        if (helpers$1.isObject(value)) {
          if (!helpers$1.isNullOrUndef(value.label)) {
            label = value.label;
          } else if (!helpers$1.isNullOrUndef(value.r)) {
            label = value.r;
          } else {
            label = "";
            keys2 = Object.keys(value);
            for (k = 0, klen = keys2.length; k < klen; ++k) {
              label += (k !== 0 ? ", " : "") + keys2[k] + ": " + value[keys2[k]];
            }
          }
        }
        return "" + label;
      };
      var defaults2 = {
        align: "center",
        anchor: "center",
        backgroundColor: null,
        borderColor: null,
        borderRadius: 0,
        borderWidth: 0,
        clamp: false,
        clip: false,
        color: void 0,
        display: true,
        font: {
          family: void 0,
          lineHeight: 1.2,
          size: void 0,
          style: void 0,
          weight: null
        },
        formatter,
        labels: void 0,
        listeners: {},
        offset: 4,
        opacity: 1,
        padding: {
          top: 4,
          right: 4,
          bottom: 4,
          left: 4
        },
        rotation: 0,
        textAlign: "start",
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        textShadowBlur: 0,
        textShadowColor: void 0
      };
      var helpers = Chart__default["default"].helpers;
      var EXPANDO_KEY = "$datalabels";
      var DEFAULT_KEY = "$default";
      function configure(dataset, options) {
        var override = dataset.datalabels;
        var listeners = {};
        var configs = [];
        var labels, keys2;
        if (override === false) {
          return null;
        }
        if (override === true) {
          override = {};
        }
        options = helpers.merge({}, [options, override]);
        labels = options.labels || {};
        keys2 = Object.keys(labels);
        delete options.labels;
        if (keys2.length) {
          keys2.forEach(function(key) {
            if (labels[key]) {
              configs.push(helpers.merge({}, [
                options,
                labels[key],
                { _key: key }
              ]));
            }
          });
        } else {
          configs.push(options);
        }
        listeners = configs.reduce(function(target, config) {
          helpers.each(config.listeners || {}, function(fn, event) {
            target[event] = target[event] || {};
            target[event][config._key || DEFAULT_KEY] = fn;
          });
          delete config.listeners;
          return target;
        }, {});
        return {
          labels: configs,
          listeners
        };
      }
      function dispatchEvent(chart, listeners, label) {
        if (!listeners) {
          return;
        }
        var context = label.$context;
        var groups = label.$groups;
        var callback;
        if (!listeners[groups._set]) {
          return;
        }
        callback = listeners[groups._set][groups._key];
        if (!callback) {
          return;
        }
        if (helpers.callback(callback, [context]) === true) {
          chart[EXPANDO_KEY]._dirty = true;
          label.update(context);
        }
      }
      function dispatchMoveEvents(chart, listeners, previous, label) {
        var enter, leave;
        if (!previous && !label) {
          return;
        }
        if (!previous) {
          enter = true;
        } else if (!label) {
          leave = true;
        } else if (previous !== label) {
          leave = enter = true;
        }
        if (leave) {
          dispatchEvent(chart, listeners.leave, previous);
        }
        if (enter) {
          dispatchEvent(chart, listeners.enter, label);
        }
      }
      function handleMoveEvents(chart, event) {
        var expando = chart[EXPANDO_KEY];
        var listeners = expando._listeners;
        var previous, label;
        if (!listeners.enter && !listeners.leave) {
          return;
        }
        if (event.type === "mousemove") {
          label = layout.lookup(expando._labels, event);
        } else if (event.type !== "mouseout") {
          return;
        }
        previous = expando._hovered;
        expando._hovered = label;
        dispatchMoveEvents(chart, listeners, previous, label);
      }
      function handleClickEvents(chart, event) {
        var expando = chart[EXPANDO_KEY];
        var handlers = expando._listeners.click;
        var label = handlers && layout.lookup(expando._labels, event);
        if (label) {
          dispatchEvent(chart, handlers, label);
        }
      }
      function invalidate(chart) {
        if (chart.animating) {
          return;
        }
        var animations = Chart__default["default"].animationService.animations;
        for (var i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            return;
          }
        }
        chart.render({ duration: 1, lazy: true });
      }
      Chart__default["default"].defaults.global.plugins.datalabels = defaults2;
      var plugin = {
        id: "datalabels",
        beforeInit: function(chart) {
          chart[EXPANDO_KEY] = {
            _actives: []
          };
        },
        beforeUpdate: function(chart) {
          var expando = chart[EXPANDO_KEY];
          expando._listened = false;
          expando._listeners = {};
          expando._datasets = [];
          expando._labels = [];
        },
        afterDatasetUpdate: function(chart, args, options) {
          var datasetIndex = args.index;
          var expando = chart[EXPANDO_KEY];
          var labels = expando._datasets[datasetIndex] = [];
          var visible = chart.isDatasetVisible(datasetIndex);
          var dataset = chart.data.datasets[datasetIndex];
          var config = configure(dataset, options);
          var elements = args.meta.data || [];
          var ctx = chart.ctx;
          var i, j, ilen, jlen, cfg, key, el, label;
          ctx.save();
          for (i = 0, ilen = elements.length; i < ilen; ++i) {
            el = elements[i];
            el[EXPANDO_KEY] = [];
            if (visible && el && !el.hidden && !el._model.skip) {
              for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                cfg = config.labels[j];
                key = cfg._key;
                label = new Label(cfg, ctx, el, i);
                label.$groups = {
                  _set: datasetIndex,
                  _key: key || DEFAULT_KEY
                };
                label.$context = {
                  active: false,
                  chart,
                  dataIndex: i,
                  dataset,
                  datasetIndex
                };
                label.update(label.$context);
                el[EXPANDO_KEY].push(label);
                labels.push(label);
              }
            }
          }
          ctx.restore();
          helpers.merge(expando._listeners, config.listeners, {
            merger: function(event, target, source) {
              target[event] = target[event] || {};
              target[event][args.index] = source[event];
              expando._listened = true;
            }
          });
        },
        afterUpdate: function(chart, options) {
          chart[EXPANDO_KEY]._labels = layout.prepare(
            chart[EXPANDO_KEY]._datasets,
            options
          );
        },
        // Draw labels on top of all dataset elements
        // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
        // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
        afterDatasetsDraw: function(chart) {
          layout.draw(chart, chart[EXPANDO_KEY]._labels);
        },
        beforeEvent: function(chart, event) {
          if (chart[EXPANDO_KEY]._listened) {
            switch (event.type) {
              case "mousemove":
              case "mouseout":
                handleMoveEvents(chart, event);
                break;
              case "click":
                handleClickEvents(chart, event);
                break;
            }
          }
        },
        afterEvent: function(chart) {
          var expando = chart[EXPANDO_KEY];
          var previous = expando._actives;
          var actives = expando._actives = chart.lastActive || [];
          var updates = utils.arrayDiff(previous, actives);
          var i, ilen, j, jlen, update, label, labels;
          for (i = 0, ilen = updates.length; i < ilen; ++i) {
            update = updates[i];
            if (update[1]) {
              labels = update[0][EXPANDO_KEY] || [];
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                label = labels[j];
                label.$context.active = update[1] === 1;
                label.update(label.$context);
              }
            }
          }
          if (expando._dirty || updates.length) {
            layout.update(expando._labels);
            invalidate(chart);
          }
          delete expando._dirty;
        }
      };
      return plugin;
    });
  })(chartjsPluginDatalabels);
  var chartjsPluginDatalabelsExports = chartjsPluginDatalabels.exports;
  const ChartDataLabels = /* @__PURE__ */ getDefaultExportFromCjs(chartjsPluginDatalabelsExports);
  const TornadoChart = ({ context, prompts, data, drillDown }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const { showValues = true } = context.component.settings ?? {};
    const color1 = ((_c = (_b = (_a = context.component.bindings) == null ? void 0 : _a.measure) == null ? void 0 : _b[0].settings) == null ? void 0 : _c.color) ?? context.app.color_palette[0];
    const color2 = ((_f = (_e = (_d = context.component.bindings) == null ? void 0 : _d.measure) == null ? void 0 : _e[1].settings) == null ? void 0 : _f.color) ?? context.app.color_palette[1];
    const format1 = (_i = (_h = (_g = context.component.bindings) == null ? void 0 : _g.measure) == null ? void 0 : _h[0].settings) == null ? void 0 : _i.format;
    const format2 = (_l = (_k = (_j = context.component.bindings) == null ? void 0 : _j.measure) == null ? void 0 : _k[1].settings) == null ? void 0 : _l.format;
    const canvasRef = React2.useRef(null);
    const { width, height } = context.component.dimensions;
    const { barChartData, catLabel, data1Label, data2Label } = React2.useMemo(() => {
      var _a2;
      const labels = [];
      const data1 = [];
      const data2 = [];
      const catLabel2 = (_a2 = data.rowHeaders) == null ? void 0 : _a2[0].label;
      const data1Label2 = data.measureHeaders[0].label;
      const data2Label2 = data.measureHeaders[1].label;
      data.data.forEach((point) => {
        labels.push(point[0].value);
        data1.push(point[1].value);
        data2.push(point[2].value);
      });
      return {
        labels,
        data1,
        data2,
        catLabel: catLabel2,
        data1Label: data1Label2,
        data2Label: data2Label2,
        barChartData: {
          labels,
          datasets: [
            {
              label: data1Label2,
              backgroundColor: color1,
              data: data1.map(Number).map((k) => -k),
              datalabels: {
                anchor: "start",
                align: "start",
                formatter: function(_, c) {
                  var _a3, _b2;
                  return formatNumber(
                    (_b2 = (_a3 = data.data) == null ? void 0 : _a3[c.dataIndex]) == null ? void 0 : _b2[c.datasetIndex + 1].value,
                    format1
                  );
                }
              }
            },
            {
              label: data2Label2,
              backgroundColor: color2,
              data: data2.map(Number),
              datalabels: {
                anchor: "end",
                align: "end",
                formatter: function(_, c) {
                  var _a3, _b2;
                  return formatNumber(
                    (_b2 = (_a3 = data.data) == null ? void 0 : _a3[c.dataIndex]) == null ? void 0 : _b2[c.datasetIndex + 1].value,
                    format2
                  );
                }
              }
            }
          ]
        }
      };
    }, [data, color1, color2]);
    React2.useEffect(() => {
      if (!canvasRef.current) {
        return;
      }
      const ctx = canvasRef.current.getContext("2d");
      if (ctx) {
        const chartRender = new Chart(ctx, {
          type: "horizontalBar",
          data: barChartData,
          plugins: [showValues && ChartDataLabels].filter(Boolean),
          options: {
            animation: {
              duration: 0
            },
            tooltips: {
              intersect: false,
              callbacks: {
                title(tooltipItem, data2) {
                  const label = tooltipItem[0].label;
                  return `${catLabel}: ${label}`;
                },
                label: (c) => {
                  let retStr = "";
                  if (c.datasetIndex === 0) {
                    retStr += `${data1Label}: ${formatNumber(-c.value, format1, false)}`;
                  } else {
                    retStr += `${data2Label}: ${formatNumber(c.value, format2, false)}`;
                  }
                  return retStr;
                }
              }
            },
            responsive: true,
            maintainAspectRatio: false,
            legend: {
              position: "bottom"
            },
            scales: {
              xAxes: [
                {
                  stacked: false,
                  ticks: {
                    beginAtZero: true,
                    fontSize: 13,
                    callback: (v, i) => {
                      return v < 0 ? formatNumber(-v, format1) : formatNumber(v, format2);
                    }
                  }
                }
              ],
              yAxes: [
                {
                  scaleLabel: {
                    display: true,
                    labelString: catLabel
                  },
                  stacked: true,
                  ticks: {
                    beginAtZero: true,
                    fontSize: 13
                  },
                  position: "left"
                }
              ]
            }
          }
        });
        return () => {
          chartRender.destroy();
        };
      }
    }, [barChartData, showValues, width, height]);
    return /* @__PURE__ */ React2.createElement("canvas", { ref: canvasRef, style: { width, height } });
  };
  const styles = "";
  const index = () => {
    const { prompts, drillDown } = usePrompts();
    const { data, context, isLoading, isError, error } = useQuery(useContext(), prompts);
    return /* @__PURE__ */ React2.createElement(ErrorOverlay, { isError, error }, /* @__PURE__ */ React2.createElement(LoadingOverlay, { isLoading, data }, context && data ? /* @__PURE__ */ React2.createElement(TornadoChart, { data, context, prompts, drillDown }) : null));
  };
  return index;
}(React);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLmpzIiwic291cmNlcyI6WyIuLi8uLi9ub2RlX21vZHVsZXMvQGluY29ydGEtb3JnL2NvbXBvbmVudC1zZGsvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbW9tZW50L2Rpc3QvbW9tZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvQ2hhcnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbnVtYnJvL2Rpc3QvbnVtYnJvLm1pbi5qcyIsIi4uLy4uL3NyYy9mb3JtYXROdW1iZXIudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuanMiLCIuLi8uLi9zcmMvVG9ybmFkb0NoYXJ0LnRzeCIsIi4uLy4uL3NyYy9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHtcbiAgdXNlTG9jYWxlLFxuICB1c2VDb250ZXh0LFxuICB1c2VQcm9tcHRzLFxuICB1c2VRdWVyeUJ1aWxkZXIsXG4gIHVzZUN1c3RvbVF1ZXJ5LFxuICB1c2VRdWVyeSxcbiAgTG9hZGluZ092ZXJsYXksXG4gIEVycm9yT3ZlcmxheVxufSA9IHdpbmRvdy5pbmNvcnRhU0RLQXBpID8/IHt9O1xuXG5leHBvcnQge1xuICB1c2VMb2NhbGUsXG4gIHVzZUNvbnRleHQsXG4gIHVzZVByb21wdHMsXG4gIHVzZVF1ZXJ5QnVpbGRlcixcbiAgdXNlQ3VzdG9tUXVlcnksXG4gIHVzZVF1ZXJ5LFxuICBMb2FkaW5nT3ZlcmxheSxcbiAgRXJyb3JPdmVybGF5XG59O1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjI5LjNcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcygpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgcmV0dXJuIChcbiAgICAgICAgaW5wdXQgIT0gbnVsbCAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICk7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICApO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxuICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgIG51bGxJbnB1dDogZmFsc2UsXG4gICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXG4gICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXG4gICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgIHJmYzI4MjI6IGZhbHNlLFxuICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgfVxuICAgIHJldHVybiBtLl9wZjtcbn1cblxudmFyIHNvbWU7XG5pZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG59IGVsc2Uge1xuICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pLFxuICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEVyYSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gKGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXSksXG4gICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHByb3AsXG4gICAgICAgIHZhbCxcbiAgICAgICAgbW9tZW50UHJvcGVydGllc0xlbiA9IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50KG9iaikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbClcbiAgICApO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmIChcbiAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuXG4gICAgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArXG4gICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmbik7XG59XG5cbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICB9XG4gICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cblxuaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICk7XG59XG5cbmZ1bmN0aW9uIHNldChjb25maWcpIHtcbiAgICB2YXIgcHJvcCwgaTtcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNvbmZpZywgaSkpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgJ3wnICtcbiAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgfVxufVxuXG52YXIga2V5cztcblxuaWYgKE9iamVjdC5rZXlzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xufSBlbHNlIHtcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICBuZXh0RGF5OiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgbGFzdFdlZWs6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZTogJ0wnLFxufTtcblxuZnVuY3Rpb24gY2FsZW5kYXIoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKFxuICAgICAgICAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICBhYnNOdW1iZXJcbiAgICApO1xufVxuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgIC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98TnsxLDV9fFlZWVlZWXxZWVlZWXxZWVlZfFlZfHl7Miw0fXx5bz98Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2csXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcbiAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4vLyB0b2tlbjogICAgJ00nXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4vLyBvcmRpbmFsOiAgJ01vJ1xuLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICB9XG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKFxuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpXG4gICAgICAgICAgICAgICAgOiBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5cbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID1cbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgIHZhciBpID0gNTtcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICB9XG5cbiAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMsXG4gICAgICAgICAgICByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnNcbiAgICAgICAgKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgIExUUzogJ2g6bW06c3MgQScsXG4gICAgTFQ6ICdoOm1tIEEnLFxuICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICBMTDogJ01NTU0gRCwgWVlZWScsXG4gICAgTExMOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxufTtcblxuZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXJcbiAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRvaykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgdG9rID09PSAnTU0nIHx8XG4gICAgICAgICAgICAgICAgdG9rID09PSAnREQnIHx8XG4gICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2suc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignJyk7XG5cbiAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbn1cblxudmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG5mdW5jdGlvbiBpbnZhbGlkRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG5cbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCcsXG4gICAgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlOiAnaW4gJXMnLFxuICAgIHBhc3Q6ICclcyBhZ28nLFxuICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzczogJyVkIHNlY29uZHMnLFxuICAgIG06ICdhIG1pbnV0ZScsXG4gICAgbW06ICclZCBtaW51dGVzJyxcbiAgICBoOiAnYW4gaG91cicsXG4gICAgaGg6ICclZCBob3VycycsXG4gICAgZDogJ2EgZGF5JyxcbiAgICBkZDogJyVkIGRheXMnLFxuICAgIHc6ICdhIHdlZWsnLFxuICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgIE06ICdhIG1vbnRoJyxcbiAgICBNTTogJyVkIG1vbnRocycsXG4gICAgeTogJ2EgeWVhcicsXG4gICAgeXk6ICclZCB5ZWFycycsXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dClcbiAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICA6IG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG59XG5cbnZhciBhbGlhc2VzID0ge307XG5cbmZ1bmN0aW9uIGFkZFVuaXRBbGlhcyh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgIHU7XG4gICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7IHVuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufVxuXG5mdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgIHJldHVybiBtb20uaXNWYWxpZCgpXG4gICAgICAgID8gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKClcbiAgICAgICAgOiBOYU47XG59XG5cbmZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHVuaXQgPT09ICdGdWxsWWVhcicgJiZcbiAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgIG1vbS5tb250aCgpID09PSAxICYmXG4gICAgICAgICAgICBtb20uZGF0ZSgpID09PSAyOVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIG1vbS5tb250aCgpLFxuICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1NldCh1bml0cywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJpb3JpdGl6ZWRMZW4gPSBwcmlvcml0aXplZC5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmlvcml0aXplZExlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBtYXRjaDEgPSAvXFxkLywgLy8gICAgICAgMCAtIDlcbiAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgbWF0Y2gzID0gL1xcZHszfS8sIC8vICAgICAwMDAgLSA5OTlcbiAgICBtYXRjaDQgPSAvXFxkezR9LywgLy8gICAgMDAwMCAtIDk5OTlcbiAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgbWF0Y2gxdG8yID0gL1xcZFxcZD8vLCAvLyAgICAgICAwIC0gOTlcbiAgICBtYXRjaDN0bzQgPSAvXFxkXFxkXFxkXFxkPy8sIC8vICAgICA5OTkgLSA5OTk5XG4gICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgbWF0Y2gxdG8zID0gL1xcZHsxLDN9LywgLy8gICAgICAgMCAtIDk5OVxuICAgIG1hdGNoMXRvNCA9IC9cXGR7MSw0fS8sIC8vICAgICAgIDAgLSA5OTk5XG4gICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgbWF0Y2hVbnNpZ25lZCA9IC9cXGQrLywgLy8gICAgICAgMCAtIGluZlxuICAgIG1hdGNoU2lnbmVkID0gL1srLV0/XFxkKy8sIC8vICAgIC1pbmYgLSBpbmZcbiAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpLCAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgbWF0Y2hXb3JkID1cbiAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgcmVnZXhlcztcblxucmVnZXhlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgID8gcmVnZXhcbiAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgc1xuICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGZ1bmMgPSBjYWxsYmFjayxcbiAgICAgICAgdG9rZW5MZW47XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICB9XG59XG5cbnZhciBZRUFSID0gMCxcbiAgICBNT05USCA9IDEsXG4gICAgREFURSA9IDIsXG4gICAgSE9VUiA9IDMsXG4gICAgTUlOVVRFID0gNCxcbiAgICBTRUNPTkQgPSA1LFxuICAgIE1JTExJU0VDT05EID0gNixcbiAgICBXRUVLID0gNyxcbiAgICBXRUVLREFZID0gODtcblxuZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG59XG5cbnZhciBpbmRleE9mO1xuXG5pZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG59IGVsc2Uge1xuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICByZXR1cm4gbW9kTW9udGggPT09IDFcbiAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICA6IDI4XG4gICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzID1cbiAgICAgICAgJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KFxuICAgICAgICAgICAgJ18nXG4gICAgICAgICksXG4gICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID1cbiAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXG4gICAgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG5mdW5jdGlvbiBsb2NhbGVNb250aHMobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV1cbiAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgIF1bbS5tb250aCgpXTtcbn1cblxuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldXG4gICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbXG4gICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICBdW20ubW9udGgoKV07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaWksXG4gICAgICAgIG1vbSxcbiAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NTScgJiZcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NJyAmJlxuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc2V0TW9udGgobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG5mdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleFxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSxcbiAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBtb207XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgJ2knXG4gICAgKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgJ2knXG4gICAgKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgIHJldHVybiB5IDw9IDk5OTkgPyB6ZXJvRmlsbCh5LCA0KSA6ICcrJyArIHk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsIDVdLCAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVknLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG4vLyBIT09LU1xuXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG59O1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuZnVuY3Rpb24gZ2V0SXNMZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGU7XG4gICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgdmFyIGRhdGUsIGFyZ3M7XG4gICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgcmVzWWVhcixcbiAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXIsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLFxuICAgICAgICByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihcbiAgICBbJ3cnLCAnd3cnLCAnVycsICdXVyddLFxuICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfVxuKTtcblxuLy8gSEVMUEVSU1xuXG4vLyBMT0NBTEVTXG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxufTtcblxuZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcbmZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9XG4gICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXG4gICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpXG4gICAgICAgID8gdGhpcy5fd2Vla2RheXNcbiAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgbSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICBdO1xuICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgIDogbVxuICAgICAgICA/IHdlZWtkYXlzW20uZGF5KCldXG4gICAgICAgIDogd2Vla2RheXM7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQobSkge1xuICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgOiBtXG4gICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNNaW4sIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICA6IG1cbiAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLFxuICAgICAgICBpaSxcbiAgICAgICAgbW9tLFxuICAgICAgICBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQoXG4gICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAnXicgK1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArXG4gICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICBmb3JtYXQgPT09ICdkZGRkJyAmJlxuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkJyAmJlxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkJyAmJlxuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleFxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgIGxvbmdQaWVjZXMgPSBbXSxcbiAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgbW9tLFxuICAgICAgICBtaW5wLFxuICAgICAgICBzaG9ydHAsXG4gICAgICAgIGxvbmdwO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICBsb25ncCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXMobW9tLCAnJykpO1xuICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgJ2knXG4gICAgKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAnaSdcbiAgICApO1xuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgJ2knXG4gICAgKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbn1cblxuZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xufVxuXG5hZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbmFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbmFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAnJyArXG4gICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAnJyArXG4gICAgICAgIHRoaXMuaG91cnMoKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICk7XG59KTtcblxuZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgIHRoaXMubWludXRlcygpLFxuICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0oaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG59XG5cbmFkZFJlZ2V4VG9rZW4oJ2EnLCBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignaCcsIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2ksXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxudmFyIGJhc2VDb25maWcgPSB7XG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fSxcbiAgICBsb2NhbGVGYW1pbGllcyA9IHt9LFxuICAgIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmw7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG59XG5cbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbi8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaixcbiAgICAgICAgbmV4dCxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBzcGxpdDtcblxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgbmV4dC5sZW5ndGggPj0gaiAmJlxuICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWxlTmFtZVNhbmUobmFtZSkge1xuICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICByZXR1cm4gbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGwsXG4gICAgICAgIGFsaWFzZWRSZXF1aXJlO1xuICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgaWYgKFxuICAgICAgICBsb2NhbGVzW25hbWVdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbW9kdWxlICYmXG4gICAgICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbWFyayBhcyBub3QgZm91bmQgdG8gYXZvaWQgcmVwZWF0aW5nIGV4cGVuc2l2ZSBmaWxlIHJlcXVpcmUgY2FsbCBjYXVzaW5nIGhpZ2ggQ1BVXG4gICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbnVsbDsgLy8gbnVsbCBtZWFucyBub3QgZm91bmRcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwgJiYgbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVMb2NhbGUgaXMgY2FsbGVkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGVcbiAgICAgICAgICAgICAgICAvLyBTZXQgYWJiciBzbyBpdCB3aWxsIGhhdmUgYSBuYW1lIChnZXR0ZXJzIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGdldFNldEdsb2JhbExvY2FsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyByZXR1cm5zIGxvY2FsZSBkYXRhXG5mdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICB2YXIgb3ZlcmZsb3csXG4gICAgICAgIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgID8gTU9OVEhcbiAgICAgICAgICAgICAgICA6IGFbREFURV0gPCAxIHx8IGFbREFURV0gPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSlcbiAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICBhW0hPVVJdID4gMjQgfHxcbiAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYVtTRUNPTkRdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICA6IGFbTUlOVVRFXSA8IDAgfHwgYVtNSU5VVEVdID4gNTlcbiAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgID8gU0VDT05EXG4gICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgOiAtMTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gaXNvIDg2MDEgcmVnZXhcbi8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxudmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICBiYXNpY0lzb1JlZ2V4ID1cbiAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vLFxuICAgIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXSxcbiAgICAgICAgWydZWVlZTU0nLCAvXFxkezZ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgIF0sXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgXSxcbiAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaSxcbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgcmZjMjgyMiA9XG4gICAgICAgIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC8sXG4gICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgfTtcblxuLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICB0aW1lRm9ybWF0LFxuICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgaXNvRGF0ZXNMZW4gPSBpc29EYXRlcy5sZW5ndGgsXG4gICAgICAgIGlzb1RpbWVzTGVuID0gaXNvVGltZXMubGVuZ3RoO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlc0xlbjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lc0xlbjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgeWVhclN0cixcbiAgICBtb250aFN0cixcbiAgICBkYXlTdHIsXG4gICAgaG91clN0cixcbiAgICBtaW51dGVTdHIsXG4gICAgc2Vjb25kU3RyXG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICBdO1xuXG4gICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICB9XG4gICAgcmV0dXJuIHllYXI7XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgIHJldHVybiBzXG4gICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpXG4gICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xufVxuXG5mdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMl1cbiAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgIG0gPSBobSAlIDEwMCxcbiAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgfVxufVxuXG4vLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgIHBhcnNlZEFycmF5O1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgIG1hdGNoWzNdLFxuICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgIG1hdGNoWzZdLFxuICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSAxKSBBU1AuTkVULCAyKSBJU08sIDMpIFJGQyAyODIyIGZvcm1hdHMsIG9yIDQpIG9wdGlvbmFsIGZhbGxiYWNrIGlmIHBhcnNpbmcgaXNuJ3Qgc3RyaWN0XG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGRhdGUsXG4gICAgICAgIGlucHV0ID0gW10sXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgIHllYXJUb1VzZTtcblxuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgIH1cblxuICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgY29uZmlnLl9hW2ldID09IG51bGwgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgaWYgKFxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGlucHV0XG4gICAgKTtcbiAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICBpZiAoXG4gICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICB3ID0gY29uZmlnLl93O1xuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgZG93ID0gMTtcbiAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0sXG4gICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgKTtcbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG59XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbmhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG5ob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uZmlnLl9hID0gW107XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgIGksXG4gICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHRva2VuLFxuICAgICAgICBza2lwcGVkLFxuICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgZXJhLFxuICAgICAgICB0b2tlbkxlbjtcblxuICAgIHRva2VucyA9XG4gICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcbiAgICB0b2tlbkxlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8XG4gICAgICAgICAgICBbXSlbMF07XG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgY29uZmlnLl9sb2NhbGUsXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICk7XG5cbiAgICAvLyBoYW5kbGUgZXJhXG4gICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgIGlmIChlcmEgIT09IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgdmFyIGlzUG07XG5cbiAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbiAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCxcbiAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgY29uZmlnZkxlbiA9IGNvbmZpZy5fZi5sZW5ndGg7XG5cbiAgICBpZiAoY29uZmlnZkxlbiA9PT0gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWdmTGVuOyBpKyspIHtcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkRm9ybWF0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgIGRheU9yRGF0ZSA9IGkuZGF5ID09PSB1bmRlZmluZWQgPyBpLmRhdGUgOiBpLmRheTtcbiAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnKGNvbmZpZykge1xuICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyhjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmljdCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApXG4gICAgKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICBjLl9sID0gbG9jYWxlO1xuICAgIGMuX2kgPSBpbnB1dDtcbiAgICBjLl9mID0gZm9ybWF0O1xuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG59XG5cbnZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICksXG4gICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZnVuY3Rpb24gbWluKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4KCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xufVxuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbn07XG5cbnZhciBvcmRlcmluZyA9IFtcbiAgICAneWVhcicsXG4gICAgJ3F1YXJ0ZXInLFxuICAgICdtb250aCcsXG4gICAgJ3dlZWsnLFxuICAgICdkYXknLFxuICAgICdob3VyJyxcbiAgICAnbWludXRlJyxcbiAgICAnc2Vjb25kJyxcbiAgICAnbWlsbGlzZWNvbmQnLFxuXTtcblxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICB2YXIga2V5LFxuICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICBpLFxuICAgICAgICBvcmRlckxlbiA9IG9yZGVyaW5nLmxlbmd0aDtcbiAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG5cbmZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArIHF1YXJ0ZXJzICogMyArIHllYXJzICogMTI7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgIHRoaXMuX2J1YmJsZSgpO1xufVxuXG5mdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICtcbiAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xufVxuXG5vZmZzZXQoJ1onLCAnOicpO1xub2Zmc2V0KCdaWicsICcnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdaJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyB0aW1lem9uZSBjaHVua2VyXG4vLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlciksXG4gICAgICAgIGNodW5rLFxuICAgICAgICBwYXJ0cyxcbiAgICAgICAgbWludXRlcztcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpXG4gICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyhrZWVwTG9jYWxUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHt9LFxuICAgICAgICBvdGhlcjtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xufVxuXG4vLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbnZhciBhc3BOZXRSZWdleCA9IC9eKC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKyk6KFxcZCspKD86OihcXGQrKShcXC5cXGQqKT8pPyQvLFxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICBpc29SZWdleCA9XG4gICAgICAgIC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICBzaWduLFxuICAgICAgICByZXQsXG4gICAgICAgIGRpZmZSZXM7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgTTogaW5wdXQuX21vbnRocyxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKVxuICAgICAgICApO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbmNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge307XG5cbiAgICByZXMubW9udGhzID1cbiAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgIC0tcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgfVxuXG4gICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgdmFsID0gcGVyaW9kO1xuICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcbiAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG5mdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcbiAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XG4gICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB7XG4gICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAneScsXG4gICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnTScsXG4gICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgJ2gnLFxuICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICdtcycsXG4gICAgICAgIF0sXG4gICAgICAgIGksXG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBwcm9wZXJ0eUxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICBkYXRhVHlwZVRlc3QgPSBmYWxzZTtcbiAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG59XG5cbmZ1bmN0aW9uIGlzQ2FsZW5kYXJTcGVjKGlucHV0KSB7XG4gICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICdsYXN0RGF5JyxcbiAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgJ3NhbWVFbHNlJyxcbiAgICAgICAgXSxcbiAgICAgICAgaSxcbiAgICAgICAgcHJvcGVydHk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02XG4gICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICA/ICdsYXN0V2VlaydcbiAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICA6IGRpZmYgPCAxXG4gICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgPyAnbmV4dERheSdcbiAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgOiAnc2FtZUVsc2UnO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBzaW5nbGUgcGFyYW1ldGVyLCBmb3JtYXRzIG9ubHkgb3ZlcmxvYWQgdG8gdGhlIGNhbGVuZGFyIGZ1bmN0aW9uXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgdGltZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgZm9ybWF0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KVxuICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgb3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gaXNBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbEZyb20uaXNWYWxpZCgpICYmIGxvY2FsVG8uaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICByZXR1cm4gKFxuICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cylcbiAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICA/IHRoaXMuaXNCZWZvcmUobG9jYWxUbywgdW5pdHMpXG4gICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgIGlmIChhLmRhdGUoKSA8IGIuZGF0ZSgpKSB7XG4gICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICByZXR1cm4gLW1vbnRoRGlmZihiLCBhKTtcbiAgICB9XG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMiArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgIGFuY2hvcjIsXG4gICAgICAgIGFkanVzdDtcblxuICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgfVxuXG4gICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xufVxuXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICBtLFxuICAgICAgICB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICpcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICB6b25lID0gJycsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeWVhcixcbiAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgIHN1ZmZpeDtcbiAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICB6b25lID0gJ1onO1xuICAgIH1cbiAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgIHllYXIgPSAwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAoXG4gICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG5mdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKFxuICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbn1cblxudmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwLFxuICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4vLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICByZXR1cm4gKChkaXZpZGVuZCAlIGRpdmlzb3IpICsgZGl2aXNvcikgJSBkaXZpc29yO1xufVxuXG5mdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICB2YXIgdGltZSwgc3RhcnRPZkRhdGU7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpICsgMSwgMSkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSArIDdcbiAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHRpbWUgKz1cbiAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG59XG5cbmZ1bmN0aW9uIHVuaXgoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbn1cblxuZnVuY3Rpb24gdG9EYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICAgIG0ueWVhcigpLFxuICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICBtLmhvdXIoKSxcbiAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgbS5taWxsaXNlY29uZCgpLFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKCksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgIH07XG59XG5cbmFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignTk5OJywgMCwgMCwgJ2VyYUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbmFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3knLCAxXSwgJ3lvJywgJ2VyYVllYXInKTtcbmFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eXknLCA0XSwgMCwgJ2VyYVllYXInKTtcblxuYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG5hZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG5hZGRSZWdleFRva2VuKCdOTk4nLCBtYXRjaEVyYUFiYnIpO1xuYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG5hZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuYWRkUGFyc2VUb2tlbihcbiAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBlcmEgPSBjb25maWcuX2xvY2FsZS5lcmFzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ3l5JywgbWF0Y2hVbnNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ3lvJywgbWF0Y2hFcmFZZWFyT3JkaW5hbCk7XG5cbmFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVyYXM7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUVyYXNQYXJzZShlcmFOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGFiYnIsXG4gICAgICAgIG5hcnJvdztcbiAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIG5hbWUgPSBlcmFzW2ldLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgY2FzZSAnTk4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ05OTk4nOlxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXJyb3cgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpICsgKHllYXIgLSBlcmEub2Zmc2V0KSAqIGRpcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEVyYU5hbWUoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHZhbCxcbiAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgdmFsLFxuICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHZhbCxcbiAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldEVyYVllYXIoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGRpcixcbiAgICAgICAgdmFsLFxuICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAodGhpcy55ZWFyKCkgLSBob29rcyhlcmFzW2ldLnNpbmNlKS55ZWFyKCkpICogZGlyICtcbiAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnllYXIoKTtcbn1cblxuZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG59XG5cbmZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xufVxuXG5mdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICBuYW1lUGllY2VzID0gW10sXG4gICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgbmFtZVBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG5cbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuICAgIH1cblxuICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9lcmFzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbmFtZVBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICdeKCcgKyBuYXJyb3dQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAnaSdcbiAgICApO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG59XG5cbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdnZ2dnJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH1cbik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGlucHV0LFxuICAgICAgICB0aGlzLmlzb1dlZWsoKSxcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgIDEsXG4gICAgICAgIDRcbiAgICApO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhcigpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luSVNPV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMud2Vla1llYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKVxuICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgID8gbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlXG4gICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbmFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mWWVhcihpbnB1dCkge1xuICAgIHZhciBkYXlPZlllYXIgPVxuICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTVcbiAgICAgICAgKSArIDE7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG5hZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTUycsIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxudmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbmZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xufVxuXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG59XG5cbmdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG5cbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCA9IGFkZDtcbnByb3RvLmNhbGVuZGFyID0gY2FsZW5kYXIkMTtcbnByb3RvLmNsb25lID0gY2xvbmU7XG5wcm90by5kaWZmID0gZGlmZjtcbnByb3RvLmVuZE9mID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgPSBmb3JtYXQ7XG5wcm90by5mcm9tID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgPSBmcm9tTm93O1xucHJvdG8udG8gPSB0bztcbnByb3RvLnRvTm93ID0gdG9Ob3c7XG5wcm90by5nZXQgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG5wcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG5wcm90by5pc1NhbWUgPSBpc1NhbWU7XG5wcm90by5pc1NhbWVPckFmdGVyID0gaXNTYW1lT3JBZnRlcjtcbnByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG5wcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xucHJvdG8ubGFuZyA9IGxhbmc7XG5wcm90by5sb2NhbGUgPSBsb2NhbGU7XG5wcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbnByb3RvLm1heCA9IHByb3RvdHlwZU1heDtcbnByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbnByb3RvLnNldCA9IHN0cmluZ1NldDtcbnByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xucHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbnByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbnByb3RvLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmc7XG5wcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICBwcm90b1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgfTtcbn1cbnByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbnByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG5wcm90by51bml4ID0gdW5peDtcbnByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xucHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xucHJvdG8uZXJhTmFtZSA9IGdldEVyYU5hbWU7XG5wcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG5wcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbnByb3RvLmVyYVllYXIgPSBnZXRFcmFZZWFyO1xucHJvdG8ueWVhciA9IGdldFNldFllYXI7XG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbnByb3RvLndlZWtZZWFyID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xucHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbnByb3RvLm1vbnRoID0gZ2V0U2V0TW9udGg7XG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xucHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgPSBwcm90by5pc29XZWVrcyA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbnByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbnByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ID0gcHJvdG8uZGF5cyA9IGdldFNldERheU9mV2VlaztcbnByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG5wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xucHJvdG8uZGF5T2ZZZWFyID0gZ2V0U2V0RGF5T2ZZZWFyO1xucHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbnByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG5wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xucHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbnByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjID0gaXNVdGM7XG5wcm90by5pc1VUQyA9IGlzVXRjO1xucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5wcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLFxuICAgIGdldFNldERheU9mTW9udGhcbik7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoXG4gICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgZ2V0U2V0TW9udGhcbik7XG5wcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgZ2V0U2V0WWVhclxuKTtcbnByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJyxcbiAgICBnZXRTZXRab25lXG4pO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKFxuICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbik7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xufVxuXG5mdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG5wcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ID0gbG9uZ0RhdGVGb3JtYXQ7XG5wcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG5wcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xucHJvdG8kMS5wcmVwYXJzZSA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xucHJvdG8kMS5wYXN0RnV0dXJlID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ID0gc2V0O1xucHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbnByb3RvJDEuZXJhc1BhcnNlID0gbG9jYWxlRXJhc1BhcnNlO1xucHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG5wcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xucHJvdG8kMS5lcmFzTmFtZVJlZ2V4ID0gZXJhc05hbWVSZWdleDtcbnByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG5wcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbnByb3RvJDEubW9udGhzU2hvcnQgPSBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbnByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCA9IG1vbnRoc1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG5wcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG5wcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG5wcm90byQxLndlZWtkYXlzU2hvcnQgPSBsb2NhbGVXZWVrZGF5c1Nob3J0O1xucHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ID0gd2Vla2RheXNTaG9ydFJlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGksXG4gICAgICAgIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDAsXG4gICAgICAgIGksXG4gICAgICAgIG91dCA9IFtdO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZXJhczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgdW50aWw6ICtJbmZpbml0eSxcbiAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICBuYXJyb3c6ICdBRCcsXG4gICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgIGFiYnI6ICdCQycsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICA/ICduZCdcbiAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfSxcbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbmhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJyxcbiAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbik7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgZ2V0TG9jYWxlXG4pO1xuXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBhYnMoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgIHRoaXMuX21vbnRocyA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG5mdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZnVuY3Rpb24gc3VidHJhY3QkMShpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbn1cblxuZnVuY3Rpb24gYWJzQ2VpbChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgbWludXRlcyxcbiAgICAgICAgaG91cnMsXG4gICAgICAgIHllYXJzLFxuICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICBpZiAoXG4gICAgICAgICEoXG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgIGRheXMgPSAwO1xuICAgICAgICBtb250aHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcblxuICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG4gICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICBkYXRhLnllYXJzID0geWVhcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGF5c1RvTW9udGhzKGRheXMpIHtcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgcmV0dXJuIChkYXlzICogNDgwMCkgLyAxNDYwOTc7XG59XG5cbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xufVxuXG5mdW5jdGlvbiBhcyh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXMsXG4gICAgICAgIG1vbnRocyxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgLyA3ICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMTQ0MCArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmZ1bmN0aW9uIHZhbHVlT2YkMSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzKGFsaWFzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgIH07XG59XG5cbnZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICBhc1NlY29uZHMgPSBtYWtlQXMoJ3MnKSxcbiAgICBhc01pbnV0ZXMgPSBtYWtlQXMoJ20nKSxcbiAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgYXNEYXlzID0gbWFrZUFzKCdkJyksXG4gICAgYXNXZWVrcyA9IG1ha2VBcygndycpLFxuICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgYXNRdWFydGVycyA9IG1ha2VBcygnUScpLFxuICAgIGFzWWVhcnMgPSBtYWtlQXMoJ3knKTtcblxuZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG59XG5cbmZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICBtaW51dGVzID0gbWFrZUdldHRlcignbWludXRlcycpLFxuICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgIG1vbnRocyA9IG1ha2VHZXR0ZXIoJ21vbnRocycpLFxuICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgIHc6IG51bGwsIC8vIHdlZWtzIHRvIG1vbnRoXG4gICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICBzZWNvbmRzID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSksXG4gICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgZGF5cyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpLFxuICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgeWVhcnMgPSByb3VuZChkdXJhdGlvbi5hcygneScpKSxcbiAgICAgICAgYSA9XG4gICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgKHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzcycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgIChob3VycyA8PSAxICYmIFsnaCddKSB8fFxuICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgKGRheXMgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdKTtcblxuICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICBhID1cbiAgICAgICAgICAgIGEgfHxcbiAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgIH1cbiAgICBhID0gYSB8fFxuICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgIChtb250aHMgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10pIHx8XG4gICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByb3VuZGluZ0Z1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIHdpdGhTdWZmaXggPSBmYWxzZSxcbiAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG91dHB1dDtcblxuICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgIGFyZ1dpdGhTdWZmaXggPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgd2l0aFN1ZmZpeCA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGggPSBPYmplY3QuYXNzaWduKHt9LCB0aHJlc2hvbGRzLCBhcmdUaHJlc2hvbGRzKTtcbiAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIHRoLCBsb2NhbGUpO1xuXG4gICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbnZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwLFxuICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgIG1pbnV0ZXMsXG4gICAgICAgIGhvdXJzLFxuICAgICAgICB5ZWFycyxcbiAgICAgICAgcyxcbiAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgIHltU2lnbixcbiAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgIGhtc1NpZ247XG5cbiAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgfVxuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgIHJldHVybiAoXG4gICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICdQJyArXG4gICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgIChkYXlzID8gZGF5c1NpZ24gKyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgIChtaW51dGVzID8gaG1zU2lnbiArIG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgKTtcbn1cblxudmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbnByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbnByb3RvJDIuYWJzID0gYWJzO1xucHJvdG8kMi5hZGQgPSBhZGQkMTtcbnByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xucHJvdG8kMi5hcyA9IGFzO1xucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xucHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG5wcm90byQyLmFzTWludXRlcyA9IGFzTWludXRlcztcbnByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG5wcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbnByb3RvJDIuYXNXZWVrcyA9IGFzV2Vla3M7XG5wcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG5wcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xucHJvdG8kMi5hc1llYXJzID0gYXNZZWFycztcbnByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbnByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbnByb3RvJDIuY2xvbmUgPSBjbG9uZSQxO1xucHJvdG8kMi5nZXQgPSBnZXQkMjtcbnByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xucHJvdG8kMi5zZWNvbmRzID0gc2Vjb25kcztcbnByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzID0gaG91cnM7XG5wcm90byQyLmRheXMgPSBkYXlzO1xucHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xucHJvdG8kMi5tb250aHMgPSBtb250aHM7XG5wcm90byQyLnllYXJzID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG5wcm90byQyLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgdG9JU09TdHJpbmckMVxuKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vISBtb21lbnQuanNcblxuaG9va3MudmVyc2lvbiA9ICcyLjI5LjMnO1xuXG5zZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG5ob29rcy5mbiA9IHByb3RvO1xuaG9va3MubWluID0gbWluO1xuaG9va3MubWF4ID0gbWF4O1xuaG9va3Mubm93ID0gbm93O1xuaG9va3MudXRjID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG5ob29rcy5tb250aHMgPSBsaXN0TW9udGhzO1xuaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuaG9va3MuaW52YWxpZCA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgPSBsaXN0V2Vla2RheXNTaG9ydDtcbmhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbmhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4vLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuaG9va3MuSFRNTDVfRk1UID0ge1xuICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgIFRJTUU6ICdISDptbScsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxufTtcblxuZXhwb3J0IGRlZmF1bHQgaG9va3M7XG4iLCIvKiFcbiAqIENoYXJ0LmpzIHYyLjkuNFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIwIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydyZXF1aXJlJ10sIGZ1bmN0aW9uKHJlcXVpcmUpIHsgcmV0dXJuIGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKTsgfSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KGdsb2JhbC5tb21lbnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5tb21lbnQgPSBtb21lbnQgJiYgbW9tZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBtb21lbnRbJ2RlZmF1bHQnXSA6IG1vbWVudDtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcblx0cmV0dXJuIG4gJiYgblsnZGVmYXVsdCddIHx8IG47XG59XG5cbnZhciBjb2xvck5hbWUgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG52YXIgY29udmVyc2lvbnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbi8vIE5PVEU6IGNvbnZlcnNpb25zIHNob3VsZCBvbmx5IHJldHVybiBwcmltaXRpdmUgdmFsdWVzIChpLmUuIGFycmF5cywgb3Jcbi8vICAgICAgIHZhbHVlcyB0aGF0IGdpdmUgY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzKS5cbi8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjb2xvck5hbWUpIHtcblx0aWYgKGNvbG9yTmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0cmV2ZXJzZUtleXdvcmRzW2NvbG9yTmFtZVtrZXldXSA9IGtleTtcblx0fVxufVxuXG52YXIgY29udmVydCA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHRyZ2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAncmdiJ30sXG5cdGhzbDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc2wnfSxcblx0aHN2OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzdid9LFxuXHRod2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHdiJ30sXG5cdGNteWs6IHtjaGFubmVsczogNCwgbGFiZWxzOiAnY215ayd9LFxuXHR4eXo6IHtjaGFubmVsczogMywgbGFiZWxzOiAneHl6J30sXG5cdGxhYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsYWInfSxcblx0bGNoOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xjaCd9LFxuXHRoZXg6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2hleCddfSxcblx0a2V5d29yZDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsna2V5d29yZCddfSxcblx0YW5zaTE2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMTYnXX0sXG5cdGFuc2kyNTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kyNTYnXX0sXG5cdGhjZzoge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXX0sXG5cdGFwcGxlOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydyMTYnLCAnZzE2JywgJ2IxNiddfSxcblx0Z3JheToge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnZ3JheSddfVxufTtcblxuLy8gaGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuZm9yICh2YXIgbW9kZWwgaW4gY29udmVydCkge1xuXHRpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcblx0XHRpZiAoISgnY2hhbm5lbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmICghKCdsYWJlbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmIChjb252ZXJ0W21vZGVsXS5sYWJlbHMubGVuZ3RoICE9PSBjb252ZXJ0W21vZGVsXS5jaGFubmVscykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNoYW5uZWxzID0gY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY2hhbm5lbHN9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGxhYmVsc30pO1xuXHR9XG59XG5cbmNvbnZlcnQucmdiLmhzbCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXHR2YXIgbDtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fSBlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmRpZjtcblx0dmFyIGdkaWY7XG5cdHZhciBiZGlmO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIHYgPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRpZmYgPSB2IC0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBkaWZmYyA9IGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuXHR9O1xuXG5cdGlmIChkaWZmID09PSAwKSB7XG5cdFx0aCA9IHMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkaWZmIC8gdjtcblx0XHRyZGlmID0gZGlmZmMocik7XG5cdFx0Z2RpZiA9IGRpZmZjKGcpO1xuXHRcdGJkaWYgPSBkaWZmYyhiKTtcblxuXHRcdGlmIChyID09PSB2KSB7XG5cdFx0XHRoID0gYmRpZiAtIGdkaWY7XG5cdFx0fSBlbHNlIGlmIChnID09PSB2KSB7XG5cdFx0XHRoID0gKDEgLyAzKSArIHJkaWYgLSBiZGlmO1xuXHRcdH0gZWxzZSBpZiAoYiA9PT0gdikge1xuXHRcdFx0aCA9ICgyIC8gMykgKyBnZGlmIC0gcmRpZjtcblx0XHR9XG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDE7XG5cdFx0fSBlbHNlIGlmIChoID4gMSkge1xuXHRcdFx0aCAtPSAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0aCAqIDM2MCxcblx0XHRzICogMTAwLFxuXHRcdHYgKiAxMDBcblx0XTtcbn07XG5cbmNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF07XG5cdHZhciBnID0gcmdiWzFdO1xuXHR2YXIgYiA9IHJnYlsyXTtcblx0dmFyIGggPSBjb252ZXJ0LnJnYi5oc2wocmdiKVswXTtcblx0dmFyIHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuXG5cdGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuXHRyZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIGM7XG5cdHZhciBtO1xuXHR2YXIgeTtcblx0dmFyIGs7XG5cblx0ayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuXHRjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0eSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXG5cdHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59O1xuXG4vKipcbiAqIFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuICogKi9cbmZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuXHRyZXR1cm4gKFxuXHRcdE1hdGgucG93KHhbMF0gLSB5WzBdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsxXSAtIHlbMV0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzJdIC0geVsyXSwgMilcblx0KTtcbn1cblxuY29udmVydC5yZ2Iua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG5cdGlmIChyZXZlcnNlZCkge1xuXHRcdHJldHVybiByZXZlcnNlZDtcblx0fVxuXG5cdHZhciBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cdHZhciBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cblx0Zm9yICh2YXIga2V5d29yZCBpbiBjb2xvck5hbWUpIHtcblx0XHRpZiAoY29sb3JOYW1lLmhhc093blByb3BlcnR5KGtleXdvcmQpKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBjb2xvck5hbWVba2V5d29yZF07XG5cblx0XHRcdC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2Vcblx0XHRcdHZhciBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG5cblx0XHRcdC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXHRcdFx0aWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0S2V5d29yZCA9IGtleXdvcmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbn07XG5cbmNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHRyZXR1cm4gY29sb3JOYW1lW2tleXdvcmRdO1xufTtcblxuY29udmVydC5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0dmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG5cdHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuXHR2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuXHRyZXR1cm4gW3ggKiAxMDAsIHkgKiAxMDAsIHogKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IubGFiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXSAvIDM2MDtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgdDE7XG5cdHZhciB0Mjtcblx0dmFyIHQzO1xuXHR2YXIgcmdiO1xuXHR2YXIgdmFsO1xuXG5cdGlmIChzID09PSAwKSB7XG5cdFx0dmFsID0gbCAqIDI1NTtcblx0XHRyZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuXHR9XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHR0MiA9IGwgKiAoMSArIHMpO1xuXHR9IGVsc2Uge1xuXHRcdHQyID0gbCArIHMgLSBsICogcztcblx0fVxuXG5cdHQxID0gMiAqIGwgLSB0MjtcblxuXHRyZ2IgPSBbMCwgMCwgMF07XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0dDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcblx0XHRpZiAodDMgPCAwKSB7XG5cdFx0XHR0MysrO1xuXHRcdH1cblx0XHRpZiAodDMgPiAxKSB7XG5cdFx0XHR0My0tO1xuXHRcdH1cblxuXHRcdGlmICg2ICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0Mztcblx0XHR9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQyO1xuXHRcdH0gZWxzZSBpZiAoMyAqIHQzIDwgMikge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSB0MTtcblx0XHR9XG5cblx0XHRyZ2JbaV0gPSB2YWwgKiAyNTU7XG5cdH1cblxuXHRyZXR1cm4gcmdiO1xufTtcblxuY29udmVydC5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXTtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgc21pbiA9IHM7XG5cdHZhciBsbWluID0gTWF0aC5tYXgobCwgMC4wMSk7XG5cdHZhciBzdjtcblx0dmFyIHY7XG5cblx0bCAqPSAyO1xuXHRzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuXHRzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0diA9IChsICsgcykgLyAyO1xuXHRzdiA9IGwgPT09IDAgPyAoMiAqIHNtaW4pIC8gKGxtaW4gKyBzbWluKSA6ICgyICogcykgLyAobCArIHMpO1xuXG5cdHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXSAvIDYwO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG5cdHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG5cdHZhciBwID0gMjU1ICogdiAqICgxIC0gcyk7XG5cdHZhciBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSk7XG5cdHZhciB0ID0gMjU1ICogdiAqICgxIC0gKHMgKiAoMSAtIGYpKSk7XG5cdHYgKj0gMjU1O1xuXG5cdHN3aXRjaCAoaGkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRyZXR1cm4gW3YsIHQsIHBdO1xuXHRcdGNhc2UgMTpcblx0XHRcdHJldHVybiBbcSwgdiwgcF07XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cmV0dXJuIFtwLCB2LCB0XTtcblx0XHRjYXNlIDM6XG5cdFx0XHRyZXR1cm4gW3AsIHEsIHZdO1xuXHRcdGNhc2UgNDpcblx0XHRcdHJldHVybiBbdCwgcCwgdl07XG5cdFx0Y2FzZSA1OlxuXHRcdFx0cmV0dXJuIFt2LCBwLCBxXTtcblx0fVxufTtcblxuY29udmVydC5oc3YuaHNsID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXTtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuXHR2YXIgbG1pbjtcblx0dmFyIHNsO1xuXHR2YXIgbDtcblxuXHRsID0gKDIgLSBzKSAqIHY7XG5cdGxtaW4gPSAoMiAtIHMpICogdm1pbjtcblx0c2wgPSBzICogdm1pbjtcblx0c2wgLz0gKGxtaW4gPD0gMSkgPyBsbWluIDogMiAtIGxtaW47XG5cdHNsID0gc2wgfHwgMDtcblx0bCAvPSAyO1xuXG5cdHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5jb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciBoID0gaHdiWzBdIC8gMzYwO1xuXHR2YXIgd2ggPSBod2JbMV0gLyAxMDA7XG5cdHZhciBibCA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHJhdGlvID0gd2ggKyBibDtcblx0dmFyIGk7XG5cdHZhciB2O1xuXHR2YXIgZjtcblx0dmFyIG47XG5cblx0Ly8gd2ggKyBibCBjYW50IGJlID4gMVxuXHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0d2ggLz0gcmF0aW87XG5cdFx0YmwgLz0gcmF0aW87XG5cdH1cblxuXHRpID0gTWF0aC5mbG9vcig2ICogaCk7XG5cdHYgPSAxIC0gYmw7XG5cdGYgPSA2ICogaCAtIGk7XG5cblx0aWYgKChpICYgMHgwMSkgIT09IDApIHtcblx0XHRmID0gMSAtIGY7XG5cdH1cblxuXHRuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblx0c3dpdGNoIChpKSB7XG5cdFx0ZGVmYXVsdDpcblx0XHRjYXNlIDY6XG5cdFx0Y2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG5cdFx0Y2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uIChjbXlrKSB7XG5cdHZhciBjID0gY215a1swXSAvIDEwMDtcblx0dmFyIG0gPSBjbXlrWzFdIC8gMTAwO1xuXHR2YXIgeSA9IGNteWtbMl0gLyAxMDA7XG5cdHZhciBrID0gY215a1szXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG5cdGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcblx0YiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdIC8gMTAwO1xuXHR2YXIgeSA9IHh5elsxXSAvIDEwMDtcblx0dmFyIHogPSB4eXpbMl0gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuXHRnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcblx0YiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogciAqIDEyLjkyO1xuXG5cdGcgPSBnID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGcgKiAxMi45MjtcblxuXHRiID0gYiA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBiICogMTIuOTI7XG5cblx0ciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcblx0ZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcblx0YiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoubGFiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIHg7XG5cdHZhciB5O1xuXHR2YXIgejtcblxuXHR5ID0gKGwgKyAxNikgLyAxMTY7XG5cdHggPSBhIC8gNTAwICsgeTtcblx0eiA9IHkgLSBiIC8gMjAwO1xuXG5cdHZhciB5MiA9IE1hdGgucG93KHksIDMpO1xuXHR2YXIgeDIgPSBNYXRoLnBvdyh4LCAzKTtcblx0dmFyIHoyID0gTWF0aC5wb3coeiwgMyk7XG5cdHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cblx0eCAqPSA5NS4wNDc7XG5cdHkgKj0gMTAwO1xuXHR6ICo9IDEwOC44ODM7XG5cblx0cmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnZlcnQubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIGhyO1xuXHR2YXIgaDtcblx0dmFyIGM7XG5cblx0aHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuXHRoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cblx0cmV0dXJuIFtsLCBjLCBoXTtcbn07XG5cbmNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcblx0dmFyIGwgPSBsY2hbMF07XG5cdHZhciBjID0gbGNoWzFdO1xuXHR2YXIgaCA9IGxjaFsyXTtcblx0dmFyIGE7XG5cdHZhciBiO1xuXHR2YXIgaHI7XG5cblx0aHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdGEgPSBjICogTWF0aC5jb3MoaHIpO1xuXHRiID0gYyAqIE1hdGguc2luKGhyKTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblx0dmFyIHZhbHVlID0gMSBpbiBhcmd1bWVudHMgPyBhcmd1bWVudHNbMV0gOiBjb252ZXJ0LnJnYi5oc3YoYXJncylbMl07IC8vIGhzdiAtPiBhbnNpMTYgb3B0aW1pemF0aW9uXG5cblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAzMDtcblx0fVxuXG5cdHZhciBhbnNpID0gMzBcblx0XHQrICgoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyKVxuXHRcdHwgKE1hdGgucm91bmQoZyAvIDI1NSkgPDwgMSlcblx0XHR8IE1hdGgucm91bmQociAvIDI1NSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gMikge1xuXHRcdGFuc2kgKz0gNjA7XG5cdH1cblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIG9wdGltaXphdGlvbiBoZXJlOyB3ZSBhbHJlYWR5IGtub3cgdGhlIHZhbHVlIGFuZCBkb24ndCBuZWVkIHRvIGdldFxuXHQvLyBpdCBjb252ZXJ0ZWQgZm9yIHVzLlxuXHRyZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblxuXHQvLyB3ZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0aWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuXHRcdGlmIChyIDwgOCkge1xuXHRcdFx0cmV0dXJuIDE2O1xuXHRcdH1cblxuXHRcdGlmIChyID4gMjQ4KSB7XG5cdFx0XHRyZXR1cm4gMjMxO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnJvdW5kKCgociAtIDgpIC8gMjQ3KSAqIDI0KSArIDIzMjtcblx0fVxuXG5cdHZhciBhbnNpID0gMTZcblx0XHQrICgzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpKVxuXHRcdCsgKDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSlcblx0XHQrIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5hbnNpMTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGNvbG9yID0gYXJncyAlIDEwO1xuXG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGNvbG9yID09PSAwIHx8IGNvbG9yID09PSA3KSB7XG5cdFx0aWYgKGFyZ3MgPiA1MCkge1xuXHRcdFx0Y29sb3IgKz0gMy41O1xuXHRcdH1cblxuXHRcdGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuXG5cdFx0cmV0dXJuIFtjb2xvciwgY29sb3IsIGNvbG9yXTtcblx0fVxuXG5cdHZhciBtdWx0ID0gKH5+KGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcblx0dmFyIHIgPSAoKGNvbG9yICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGcgPSAoKChjb2xvciA+PiAxKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBiID0gKCgoY29sb3IgPj4gMikgJiAxKSAqIG11bHQpICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoYXJncyA+PSAyMzIpIHtcblx0XHR2YXIgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcblx0XHRyZXR1cm4gW2MsIGMsIGNdO1xuXHR9XG5cblx0YXJncyAtPSAxNjtcblxuXHR2YXIgcmVtO1xuXHR2YXIgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG5cdHZhciBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcblx0dmFyIGIgPSAocmVtICUgNikgLyA1ICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDB4RkYpIDw8IDE2KVxuXHRcdCsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMHhGRikgPDwgOClcblx0XHQrIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cdGlmICghbWF0Y2gpIHtcblx0XHRyZXR1cm4gWzAsIDAsIDBdO1xuXHR9XG5cblx0dmFyIGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cblx0aWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuXHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcikge1xuXHRcdFx0cmV0dXJuIGNoYXIgKyBjaGFyO1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0dmFyIGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuXHR2YXIgciA9IChpbnRlZ2VyID4+IDE2KSAmIDB4RkY7XG5cdHZhciBnID0gKGludGVnZXIgPj4gOCkgJiAweEZGO1xuXHR2YXIgYiA9IGludGVnZXIgJiAweEZGO1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG5cdHZhciBjaHJvbWEgPSAobWF4IC0gbWluKTtcblx0dmFyIGdyYXlzY2FsZTtcblx0dmFyIGh1ZTtcblxuXHRpZiAoY2hyb21hIDwgMSkge1xuXHRcdGdyYXlzY2FsZSA9IG1pbiAvICgxIC0gY2hyb21hKTtcblx0fSBlbHNlIHtcblx0XHRncmF5c2NhbGUgPSAwO1xuXHR9XG5cblx0aWYgKGNocm9tYSA8PSAwKSB7XG5cdFx0aHVlID0gMDtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IHIpIHtcblx0XHRodWUgPSAoKGcgLSBiKSAvIGNocm9tYSkgJSA2O1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gZykge1xuXHRcdGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuXHR9IGVsc2Uge1xuXHRcdGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hICsgNDtcblx0fVxuXG5cdGh1ZSAvPSA2O1xuXHRodWUgJT0gMTtcblxuXHRyZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xufTtcblxuY29udmVydC5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBjID0gMTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0YyA9IDIuMCAqIHMgKiBsO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSAyLjAgKiBzICogKDEuMCAtIGwpO1xuXHR9XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKGwgLSAwLjUgKiBjKSAvICgxLjAgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXG5cdHZhciBjID0gcyAqIHY7XG5cdHZhciBmID0gMDtcblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGggPSBoY2dbMF0gLyAzNjA7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRpZiAoYyA9PT0gMC4wKSB7XG5cdFx0cmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcblx0fVxuXG5cdHZhciBwdXJlID0gWzAsIDAsIDBdO1xuXHR2YXIgaGkgPSAoaCAlIDEpICogNjtcblx0dmFyIHYgPSBoaSAlIDE7XG5cdHZhciB3ID0gMSAtIHY7XG5cdHZhciBtZyA9IDA7XG5cblx0c3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gdjsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMTpcblx0XHRcdHB1cmVbMF0gPSB3OyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gdzsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGNhc2UgNDpcblx0XHRcdHB1cmVbMF0gPSB2OyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSB3O1xuXHR9XG5cblx0bWcgPSAoMS4wIC0gYykgKiBnO1xuXG5cdHJldHVybiBbXG5cdFx0KGMgKiBwdXJlWzBdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcblx0XTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHZhciBmID0gMDtcblxuXHRpZiAodiA+IDAuMCkge1xuXHRcdGYgPSBjIC8gdjtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzbCA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG5cdHZhciBzID0gMDtcblxuXHRpZiAobCA+IDAuMCAmJiBsIDwgMC41KSB7XG5cdFx0cyA9IGMgLyAoMiAqIGwpO1xuXHR9IGVsc2Vcblx0aWYgKGwgPj0gMC41ICYmIGwgPCAxLjApIHtcblx0XHRzID0gYyAvICgyICogKDEgLSBsKSk7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0cmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xufTtcblxuY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgdyA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGIgPSBod2JbMl0gLyAxMDA7XG5cdHZhciB2ID0gMSAtIGI7XG5cdHZhciBjID0gdiAtIHc7XG5cdHZhciBnID0gMDtcblxuXHRpZiAoYyA8IDEpIHtcblx0XHRnID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuXHRyZXR1cm4gWyhhcHBsZVswXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzFdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMl0gLyA2NTUzNSkgKiAyNTVdO1xufTtcblxuY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiBbKHJnYlswXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsxXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsyXSAvIDI1NSkgKiA2NTUzNV07XG59O1xuXG5jb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oc2wgPSBjb252ZXJ0LmdyYXkuaHN2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFswLCAwLCBhcmdzWzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuY215ayA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuXHR2YXIgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDB4RkY7XG5cdHZhciBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcblx0cmV0dXJuIFt2YWwgLyAyNTUgKiAxMDBdO1xufTtcbn0pO1xudmFyIGNvbnZlcnNpb25zXzEgPSBjb252ZXJzaW9ucy5yZ2I7XG52YXIgY29udmVyc2lvbnNfMiA9IGNvbnZlcnNpb25zLmhzbDtcbnZhciBjb252ZXJzaW9uc18zID0gY29udmVyc2lvbnMuaHN2O1xudmFyIGNvbnZlcnNpb25zXzQgPSBjb252ZXJzaW9ucy5od2I7XG52YXIgY29udmVyc2lvbnNfNSA9IGNvbnZlcnNpb25zLmNteWs7XG52YXIgY29udmVyc2lvbnNfNiA9IGNvbnZlcnNpb25zLnh5ejtcbnZhciBjb252ZXJzaW9uc183ID0gY29udmVyc2lvbnMubGFiO1xudmFyIGNvbnZlcnNpb25zXzggPSBjb252ZXJzaW9ucy5sY2g7XG52YXIgY29udmVyc2lvbnNfOSA9IGNvbnZlcnNpb25zLmhleDtcbnZhciBjb252ZXJzaW9uc18xMCA9IGNvbnZlcnNpb25zLmtleXdvcmQ7XG52YXIgY29udmVyc2lvbnNfMTEgPSBjb252ZXJzaW9ucy5hbnNpMTY7XG52YXIgY29udmVyc2lvbnNfMTIgPSBjb252ZXJzaW9ucy5hbnNpMjU2O1xudmFyIGNvbnZlcnNpb25zXzEzID0gY29udmVyc2lvbnMuaGNnO1xudmFyIGNvbnZlcnNpb25zXzE0ID0gY29udmVyc2lvbnMuYXBwbGU7XG52YXIgY29udmVyc2lvbnNfMTUgPSBjb252ZXJzaW9ucy5ncmF5O1xuXG4vKlxuXHR0aGlzIGZ1bmN0aW9uIHJvdXRlcyBhIG1vZGVsIHRvIGFsbCBvdGhlciBtb2RlbHMuXG5cblx0YWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByb3V0ZWQgaGF2ZSBhIHByb3BlcnR5IGAuY29udmVyc2lvbmAgYXR0YWNoZWRcblx0dG8gdGhlIHJldHVybmVkIHN5bnRoZXRpYyBmdW5jdGlvbi4gVGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuXHRvZiBzdHJpbmdzLCBlYWNoIHdpdGggdGhlIHN0ZXBzIGluIGJldHdlZW4gdGhlICdmcm9tJyBhbmQgJ3RvJ1xuXHRjb2xvciBtb2RlbHMgKGluY2x1c2l2ZSkuXG5cblx0Y29udmVyc2lvbnMgdGhhdCBhcmUgbm90IHBvc3NpYmxlIHNpbXBseSBhcmUgbm90IGluY2x1ZGVkLlxuKi9cblxuZnVuY3Rpb24gYnVpbGRHcmFwaCgpIHtcblx0dmFyIGdyYXBoID0ge307XG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9vYmplY3Qta2V5cy12cy1mb3ItaW4td2l0aC1jbG9zdXJlLzNcblx0dmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuXHRmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Z3JhcGhbbW9kZWxzW2ldXSA9IHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcblx0XHRcdC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuXHRcdFx0ZGlzdGFuY2U6IC0xLFxuXHRcdFx0cGFyZW50OiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcbmZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcblx0dmFyIGdyYXBoID0gYnVpbGRHcmFwaCgpO1xuXHR2YXIgcXVldWUgPSBbZnJvbU1vZGVsXTsgLy8gdW5zaGlmdCAtPiBxdWV1ZSAtPiBwb3BcblxuXHRncmFwaFtmcm9tTW9kZWxdLmRpc3RhbmNlID0gMDtcblxuXHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcblx0XHR2YXIgYWRqYWNlbnRzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnNbY3VycmVudF0pO1xuXG5cdFx0Zm9yICh2YXIgbGVuID0gYWRqYWNlbnRzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGFkamFjZW50ID0gYWRqYWNlbnRzW2ldO1xuXHRcdFx0dmFyIG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cblx0XHRcdGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuXHRcdFx0XHRub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuXHRcdFx0XHRub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRyZXR1cm4gdG8oZnJvbShhcmdzKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG5cdHZhciBwYXRoID0gW2dyYXBoW3RvTW9kZWxdLnBhcmVudCwgdG9Nb2RlbF07XG5cdHZhciBmbiA9IGNvbnZlcnNpb25zW2dyYXBoW3RvTW9kZWxdLnBhcmVudF1bdG9Nb2RlbF07XG5cblx0dmFyIGN1ciA9IGdyYXBoW3RvTW9kZWxdLnBhcmVudDtcblx0d2hpbGUgKGdyYXBoW2N1cl0ucGFyZW50KSB7XG5cdFx0cGF0aC51bnNoaWZ0KGdyYXBoW2N1cl0ucGFyZW50KTtcblx0XHRmbiA9IGxpbmsoY29udmVyc2lvbnNbZ3JhcGhbY3VyXS5wYXJlbnRdW2N1cl0sIGZuKTtcblx0XHRjdXIgPSBncmFwaFtjdXJdLnBhcmVudDtcblx0fVxuXG5cdGZuLmNvbnZlcnNpb24gPSBwYXRoO1xuXHRyZXR1cm4gZm47XG59XG5cbnZhciByb3V0ZSA9IGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0dmFyIGdyYXBoID0gZGVyaXZlQkZTKGZyb21Nb2RlbCk7XG5cdHZhciBjb252ZXJzaW9uID0ge307XG5cblx0dmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciB0b01vZGVsID0gbW9kZWxzW2ldO1xuXHRcdHZhciBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG5cblx0XHRpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdC8vIG5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKTtcblx0fVxuXG5cdHJldHVybiBjb252ZXJzaW9uO1xufTtcblxudmFyIGNvbnZlcnQgPSB7fTtcblxudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKGFyZ3MpO1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxuZnVuY3Rpb24gd3JhcFJvdW5kZWQoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSBmbihhcmdzKTtcblxuXHRcdC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSByZXN1bHQgaXMgYW4gYXJyYXkgaGVyZS5cblx0XHQvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG5cdFx0Ly8gaW4gY29udmVyc2lvbiBmdW5jdGlvbnMuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBsZW4gPSByZXN1bHQubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxubW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHR2YXIgcm91dGVzID0gcm91dGUoZnJvbU1vZGVsKTtcblx0dmFyIHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuXHRyb3V0ZU1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uICh0b01vZGVsKSB7XG5cdFx0dmFyIGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcblx0fSk7XG59KTtcblxudmFyIGNvbG9yQ29udmVydCA9IGNvbnZlcnQ7XG5cbnZhciBjb2xvck5hbWUkMSA9IHtcclxuXHRcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXHJcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxyXG5cdFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXHJcblx0XCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXHJcblx0XCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXHJcblx0XCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxyXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxyXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxyXG5cdFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcclxuXHRcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXHJcblx0XCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxyXG5cdFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcclxuXHRcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcclxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcclxuXHRcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcclxuXHRcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxyXG5cdFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxyXG5cdFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxyXG5cdFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxyXG5cdFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXHJcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxyXG5cdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcclxuXHRcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcclxuXHRcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXHJcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxyXG5cdFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcclxuXHRcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcclxuXHRcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXHJcblx0XCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxyXG5cdFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXHJcblx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxyXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxyXG5cdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcclxuXHRcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcclxuXHRcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxyXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcclxuXHRcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxyXG5cdFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXHJcblx0XCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXHJcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxyXG5cdFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcclxuXHRcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxyXG5cdFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxyXG5cdFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxyXG5cdFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJncmVlblwiOiBbMCwgMTI4LCAwXSxcclxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxyXG5cdFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXHJcblx0XCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcclxuXHRcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxyXG5cdFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcclxuXHRcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcclxuXHRcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcclxuXHRcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcclxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxyXG5cdFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXHJcblx0XCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxyXG5cdFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcclxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxyXG5cdFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcclxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcclxuXHRcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcclxuXHRcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxyXG5cdFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxyXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcclxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXHJcblx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXHJcblx0XCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXHJcblx0XCJsaW1lXCI6IFswLCAyNTUsIDBdLFxyXG5cdFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXHJcblx0XCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXHJcblx0XCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXHJcblx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcclxuXHRcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXHJcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXHJcblx0XCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxyXG5cdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXHJcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxyXG5cdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcclxuXHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcclxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcclxuXHRcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxyXG5cdFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcclxuXHRcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXHJcblx0XCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXHJcblx0XCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXHJcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxyXG5cdFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXHJcblx0XCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxyXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxyXG5cdFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXHJcblx0XCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxyXG5cdFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcclxuXHRcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxyXG5cdFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcclxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxyXG5cdFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXHJcblx0XCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcclxuXHRcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXHJcblx0XCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxyXG5cdFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXHJcblx0XCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcclxuXHRcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxyXG5cdFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXHJcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxyXG5cdFwicmVkXCI6IFsyNTUsIDAsIDBdLFxyXG5cdFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcclxuXHRcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcclxuXHRcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXHJcblx0XCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxyXG5cdFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcclxuXHRcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXHJcblx0XCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXHJcblx0XCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcclxuXHRcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXHJcblx0XCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcclxuXHRcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcclxuXHRcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXHJcblx0XCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxyXG5cdFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxyXG5cdFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcclxuXHRcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcclxuXHRcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxyXG5cdFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXHJcblx0XCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXHJcblx0XCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxyXG5cdFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxyXG5cdFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxyXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXHJcblx0XCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcclxuXHRcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXHJcbn07XG5cbi8qIE1JVCBsaWNlbnNlICovXG5cblxudmFyIGNvbG9yU3RyaW5nID0ge1xuICAgZ2V0UmdiYTogZ2V0UmdiYSxcbiAgIGdldEhzbGE6IGdldEhzbGEsXG4gICBnZXRSZ2I6IGdldFJnYixcbiAgIGdldEhzbDogZ2V0SHNsLFxuICAgZ2V0SHdiOiBnZXRId2IsXG4gICBnZXRBbHBoYTogZ2V0QWxwaGEsXG5cbiAgIGhleFN0cmluZzogaGV4U3RyaW5nLFxuICAgcmdiU3RyaW5nOiByZ2JTdHJpbmcsXG4gICByZ2JhU3RyaW5nOiByZ2JhU3RyaW5nLFxuICAgcGVyY2VudFN0cmluZzogcGVyY2VudFN0cmluZyxcbiAgIHBlcmNlbnRhU3RyaW5nOiBwZXJjZW50YVN0cmluZyxcbiAgIGhzbFN0cmluZzogaHNsU3RyaW5nLFxuICAgaHNsYVN0cmluZzogaHNsYVN0cmluZyxcbiAgIGh3YlN0cmluZzogaHdiU3RyaW5nLFxuICAga2V5d29yZDoga2V5d29yZFxufTtcblxuZnVuY3Rpb24gZ2V0UmdiYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgYWJiciA9ICAvXiMoW2EtZkEtRjAtOV17Myw0fSkkL2ksXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fShbYS1mQS1GMC05XXsyfSk/KSQvaSxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBrZXl3b3JkID0gLyhcXHcrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJiciksXG4gICAgICAgaGV4QWxwaGEgPSBcIlwiO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFszXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG4gICAgICB9XG4gICAgICBpZiAoaGV4QWxwaGEpIHtcbiAgICAgICAgIGEgPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSArIGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbMl07XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICAgICBpZiAoaGV4QWxwaGEpIHtcbiAgICAgICAgIGEgPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2kgKyAxXSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gPT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcmdiID0gY29sb3JOYW1lJDFbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiYSwgYSkge1xuICAgdmFyIGEgPSAoYSAhPT0gdW5kZWZpbmVkICYmIHJnYmEubGVuZ3RoID09PSAzKSA/IGEgOiByZ2JhWzNdO1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pIFxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzJdKVxuICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgKGEgPj0gMCAmJiBhIDwgMSlcbiAgICAgICAgICAgICAgICAgPyBoZXhEb3VibGUoTWF0aC5yb3VuZChhICogMjU1KSlcbiAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUkMSkge1xuICAgcmV2ZXJzZU5hbWVzW2NvbG9yTmFtZSQxW25hbWVdXSA9IG5hbWU7XG59XG5cbi8qIE1JVCBsaWNlbnNlICovXG5cblxuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmIChvYmogaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbG9yKSkge1xuXHRcdHJldHVybiBuZXcgQ29sb3Iob2JqKTtcblx0fVxuXG5cdHRoaXMudmFsaWQgPSBmYWxzZTtcblx0dGhpcy52YWx1ZXMgPSB7XG5cdFx0cmdiOiBbMCwgMCwgMF0sXG5cdFx0aHNsOiBbMCwgMCwgMF0sXG5cdFx0aHN2OiBbMCwgMCwgMF0sXG5cdFx0aHdiOiBbMCwgMCwgMF0sXG5cdFx0Y215azogWzAsIDAsIDAsIDBdLFxuXHRcdGFscGhhOiAxXG5cdH07XG5cblx0Ly8gcGFyc2UgQ29sb3IoKSBhcmd1bWVudFxuXHR2YXIgdmFscztcblx0aWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0dmFscyA9IGNvbG9yU3RyaW5nLmdldFJnYmEob2JqKTtcblx0XHRpZiAodmFscykge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IGNvbG9yU3RyaW5nLmdldEhzbGEob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IGNvbG9yU3RyaW5nLmdldEh3YihvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG5cdFx0dmFscyA9IG9iajtcblx0XHRpZiAodmFscy5yICE9PSB1bmRlZmluZWQgfHwgdmFscy5yZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5sICE9PSB1bmRlZmluZWQgfHwgdmFscy5saWdodG5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy52ICE9PSB1bmRlZmluZWQgfHwgdmFscy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHN2JywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLncgIT09IHVuZGVmaW5lZCB8fCB2YWxzLndoaXRlbmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmMgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmN5YW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2NteWsnLCB2YWxzKTtcblx0XHR9XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbGlkO1xuXHR9LFxuXHRyZ2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgncmdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHNsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzbCcsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzdjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc3YnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRod2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0Y215azogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdjbXlrJywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRyZ2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5yZ2I7XG5cdH0sXG5cdGhzbEFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzbDtcblx0fSxcblx0aHN2QXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHN2O1xuXHR9LFxuXHRod2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzLmh3Yi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVzLmh3Yjtcblx0fSxcblx0Y215a0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmNteWs7XG5cdH0sXG5cdHJnYmFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLnJnYi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRoc2xhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5oc2wuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0YWxwaGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgdmFsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZWQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAwLCB2YWwpO1xuXHR9LFxuXHRncmVlbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAyLCB2YWwpO1xuXHR9LFxuXHRodWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsKSB7XG5cdFx0XHR2YWwgJT0gMzYwO1xuXHRcdFx0dmFsID0gdmFsIDwgMCA/IDM2MCArIHZhbCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMCwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDEsIHZhbCk7XG5cdH0sXG5cdGxpZ2h0bmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDIsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb252OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMSwgdmFsKTtcblx0fSxcblx0d2hpdGVuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMSwgdmFsKTtcblx0fSxcblx0YmxhY2tuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMiwgdmFsKTtcblx0fSxcblx0dmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAyLCB2YWwpO1xuXHR9LFxuXHRjeWFuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDAsIHZhbCk7XG5cdH0sXG5cdG1hZ2VudGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMSwgdmFsKTtcblx0fSxcblx0eWVsbG93OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDIsIHZhbCk7XG5cdH0sXG5cdGJsYWNrOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDMsIHZhbCk7XG5cdH0sXG5cblx0aGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuXHR9LFxuXHRyZ2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRyZ2JhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYmFTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHBlcmNlbnRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbFN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xhU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRod2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmtleXdvcmQodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cblx0cmdiTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHRyZXR1cm4gKHJnYlswXSA8PCAxNikgfCAocmdiWzFdIDw8IDgpIHwgcmdiWzJdO1xuXHR9LFxuXG5cdGx1bWlub3NpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgbHVtID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjaGFuID0gcmdiW2ldIC8gMjU1O1xuXHRcdFx0bHVtW2ldID0gKGNoYW4gPD0gMC4wMzkyOCkgPyBjaGFuIC8gMTIuOTIgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG5cdFx0dmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHR2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cdFx0aWYgKGx1bTEgPiBsdW0yKSB7XG5cdFx0XHRyZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSk7XG5cdFx0fVxuXHRcdHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcblx0fSxcblxuXHRsZXZlbDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuXHRcdGlmIChjb250cmFzdFJhdGlvID49IDcuMSkge1xuXHRcdFx0cmV0dXJuICdBQUEnO1xuXHRcdH1cblxuXHRcdHJldHVybiAoY29udHJhc3RSYXRpbyA+PSA0LjUpID8gJ0FBJyA6ICcnO1xuXHR9LFxuXG5cdGRhcms6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuXHRcdHJldHVybiB5aXEgPCAxMjg7XG5cdH0sXG5cblx0bGlnaHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuZGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gMjU1IC0gdGhpcy52YWx1ZXMucmdiW2ldO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgcmdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsaWdodGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSArPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkYXJrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdIC09IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSArPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZXNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSAtPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3aGl0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzFdICs9IGh3YlsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGJsYWNrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzJdICs9IGh3YlsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdyZXlzY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcblx0XHR2YXIgdmFsID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIFt2YWwsIHZhbCwgdmFsXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xlYXJlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgLSAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9wYXF1ZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhICsgKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHR2YXIgaHVlID0gKGhzbFswXSArIGRlZ3JlZXMpICUgMzYwO1xuXHRcdGhzbFswXSA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvcnRlZCBmcm9tIHNhc3MgaW1wbGVtZW50YXRpb24gaW4gQ1xuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0ICovXG5cdG1peDogZnVuY3Rpb24gKG1peGluQ29sb3IsIHdlaWdodCkge1xuXHRcdHZhciBjb2xvcjEgPSB0aGlzO1xuXHRcdHZhciBjb2xvcjIgPSBtaXhpbkNvbG9yO1xuXHRcdHZhciBwID0gd2VpZ2h0ID09PSB1bmRlZmluZWQgPyAwLjUgOiB3ZWlnaHQ7XG5cblx0XHR2YXIgdyA9IDIgKiBwIC0gMTtcblx0XHR2YXIgYSA9IGNvbG9yMS5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cblx0XHR2YXIgdzEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHR2YXIgdzIgPSAxIC0gdzE7XG5cblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0LnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKVxuXHRcdFx0KVxuXHRcdFx0LmFscGhhKGNvbG9yMS5hbHBoYSgpICogcCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSBwKSk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmdiKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBOT1RFKFNCKTogdXNpbmcgbm9kZS1jbG9uZSBjcmVhdGVzIGEgZGVwZW5kZW5jeSB0byBCdWZmZXIgd2hlbiB1c2luZyBicm93c2VyaWZ5LFxuXHRcdC8vIG1ha2luZyB0aGUgZmluYWwgYnVpbGQgd2F5IHRvIGJpZyB0byBlbWJlZCBpbiBDaGFydC5qcy4gU28gbGV0J3MgZG8gaXQgbWFudWFsbHksXG5cdFx0Ly8gYXNzdW1pbmcgdGhhdCB2YWx1ZXMgdG8gY2xvbmUgYXJlIDEgZGltZW5zaW9uIGFycmF5cyBjb250YWluaW5nIG9ubHkgbnVtYmVycyxcblx0XHQvLyBleGNlcHQgJ2FscGhhJyB3aGljaCBpcyBhIG51bWJlci5cblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbG9yKCk7XG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMudmFsdWVzO1xuXHRcdHZhciB0YXJnZXQgPSByZXN1bHQudmFsdWVzO1xuXHRcdHZhciB2YWx1ZSwgdHlwZTtcblxuXHRcdGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHZhbHVlID0gc291cmNlW3Byb3BdO1xuXHRcdFx0XHR0eXBlID0gKHt9KS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZS5zbGljZSgwKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ3VuZXhwZWN0ZWQgY29sb3IgdmFsdWU6JywgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlLnNwYWNlcyA9IHtcblx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0aHN2OiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ3ZhbHVlJ10sXG5cdGh3YjogWydodWUnLCAnd2hpdGVuZXNzJywgJ2JsYWNrbmVzcyddLFxuXHRjbXlrOiBbJ2N5YW4nLCAnbWFnZW50YScsICd5ZWxsb3cnLCAnYmxhY2snXVxufTtcblxuQ29sb3IucHJvdG90eXBlLm1heGVzID0ge1xuXHRyZ2I6IFsyNTUsIDI1NSwgMjU1XSxcblx0aHNsOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGhzdjogWzM2MCwgMTAwLCAxMDBdLFxuXHRod2I6IFszNjAsIDEwMCwgMTAwXSxcblx0Y215azogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgdmFscyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHR2YWxzW3NwYWNlLmNoYXJBdChpKV0gPSB2YWx1ZXNbc3BhY2VdW2ldO1xuXHR9XG5cblx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdHZhbHMuYSA9IHZhbHVlcy5hbHBoYTtcblx0fVxuXG5cdC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG5cdHJldHVybiB2YWxzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSwgdmFscykge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciBzcGFjZXMgPSB0aGlzLnNwYWNlcztcblx0dmFyIG1heGVzID0gdGhpcy5tYXhlcztcblx0dmFyIGFscGhhID0gMTtcblx0dmFyIGk7XG5cblx0dGhpcy52YWxpZCA9IHRydWU7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0YWxwaGEgPSB2YWxzO1xuXHR9IGVsc2UgaWYgKHZhbHMubGVuZ3RoKSB7XG5cdFx0Ly8gWzEwLCAxMCwgMTBdXG5cdFx0dmFsdWVzW3NwYWNlXSA9IHZhbHMuc2xpY2UoMCwgc3BhY2UubGVuZ3RoKTtcblx0XHRhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlLmNoYXJBdCgwKV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbc3BhY2UuY2hhckF0KGkpXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlc1tzcGFjZV1bMF1dICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cblx0XHR2YXIgY2hhbnMgPSBzcGFjZXNbc3BhY2VdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tjaGFuc1tpXV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmFscGhhO1xuXHR9XG5cblx0dmFsdWVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGFscGhhID09PSB1bmRlZmluZWQgPyB2YWx1ZXMuYWxwaGEgOiBhbHBoYSkpKTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgY2FwcGVkO1xuXG5cdC8vIGNhcCB2YWx1ZXMgb2YgdGhlIHNwYWNlIHByaW9yIGNvbnZlcnRpbmcgYWxsIHZhbHVlc1xuXHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHZhbHVlc1tzcGFjZV1baV0pKTtcblx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuXHR9XG5cblx0Ly8gY29udmVydCB0byBhbGwgdGhlIG90aGVyIGNvbG9yIHNwYWNlc1xuXHRmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcblx0XHRpZiAoc25hbWUgIT09IHNwYWNlKSB7XG5cdFx0XHR2YWx1ZXNbc25hbWVdID0gY29sb3JDb252ZXJ0W3NwYWNlXVtzbmFtZV0odmFsdWVzW3NwYWNlXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0U3BhY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGFyZ3MpIHtcblx0dmFyIHZhbHMgPSBhcmdzWzBdO1xuXG5cdGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZ2IoKVxuXHRcdHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG5cdH1cblxuXHQvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcblx0aWYgKHR5cGVvZiB2YWxzID09PSAnbnVtYmVyJykge1xuXHRcdHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblx0fVxuXG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWxzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIChzcGFjZSwgaW5kZXgsIHZhbCkge1xuXHR2YXIgc3ZhbHVlcyA9IHRoaXMudmFsdWVzW3NwYWNlXTtcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmVkKClcblx0XHRyZXR1cm4gc3ZhbHVlc1tpbmRleF07XG5cdH0gZWxzZSBpZiAodmFsID09PSBzdmFsdWVzW2luZGV4XSkge1xuXHRcdC8vIGNvbG9yLnJlZChjb2xvci5yZWQoKSlcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGNvbG9yLnJlZCgxMDApXG5cdHN2YWx1ZXNbaW5kZXhdID0gdmFsO1xuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgc3ZhbHVlcyk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNvbG9yID0gQ29sb3I7XG59XG5cbnZhciBjaGFydGpzQ29sb3IgPSBDb2xvcjtcblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuXHRyZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xyXG4gKi9cclxudmFyIGhlbHBlcnMgPSB7XHJcblx0LyoqXHJcblx0ICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cclxuXHQgKi9cclxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHR1aWQ6IChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBpZCA9IDA7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBpZCsrO1xyXG5cdFx0fTtcclxuXHR9KCkpLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRpc051bGxPclVuZGVmOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcclxuXHRcdGlmICh0eXBlLnN1YnN0cigwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc3Vic3RyKC02KSA9PT0gJ0FycmF5XScpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0aXNPYmplY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlICAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdGlzRmluaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxyXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHZhbHVlIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIGFycmF5IGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGluIGB2YWx1ZWAgdG8gbG9va3VwIGZvciB2YWx1ZS5cclxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlW2luZGV4XWAgaXMgdW5kZWZpbmVkLlxyXG5cdCAqIEByZXR1cm5zIHsqfVxyXG5cdCAqL1xyXG5cdHZhbHVlQXRJbmRleE9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXHJcblx0ICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZHxudWxsfSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cclxuXHQgKiBAcmV0dXJucyB7Kn1cclxuXHQgKi9cclxuXHRjYWxsYmFjazogZnVuY3Rpb24oZm4sIGFyZ3MsIHRoaXNBcmcpIHtcclxuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXHJcblx0ICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2VcclxuXHQgKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXHJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxyXG5cdCAqL1xyXG5cdGVhY2g6IGZ1bmN0aW9uKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xyXG5cdFx0dmFyIGksIGxlbiwga2V5cztcclxuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobG9vcGFibGUpKSB7XHJcblx0XHRcdGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcclxuXHRcdFx0aWYgKHJldmVyc2UpIHtcclxuXHRcdFx0XHRmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XHJcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XHJcblx0XHRcdGxlbiA9IGtleXMubGVuZ3RoO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXHJcblx0ICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ4NTM5NzRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdGFycmF5RXF1YWxzOiBmdW5jdGlvbihhMCwgYTEpIHtcclxuXHRcdHZhciBpLCBpbGVuLCB2MCwgdjE7XHJcblxyXG5cdFx0aWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0djAgPSBhMFtpXTtcclxuXHRcdFx0djEgPSBhMVtpXTtcclxuXHJcblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0XHRpZiAoIWhlbHBlcnMuYXJyYXlFcXVhbHModjAsIHYxKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh2MCAhPT0gdjEpIHtcclxuXHRcdFx0XHQvLyBOT1RFOiB0d28gZGlmZmVyZW50IG9iamVjdCBpbnN0YW5jZXMgd2lsbCBuZXZlciBiZSBlcXVhbDoge3g6MjB9ICE9IHt4OjIwfVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxyXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxyXG5cdCAqIEByZXR1cm5zIHsqfVxyXG5cdCAqL1xyXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkoc291cmNlKSkge1xyXG5cdFx0XHRyZXR1cm4gc291cmNlLm1hcChoZWxwZXJzLmNsb25lKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaGVscGVycy5pc09iamVjdChzb3VyY2UpKSB7XHJcblx0XHRcdHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKHNvdXJjZSk7XHJcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuXHRcdFx0dmFyIGtsZW4gPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0dmFyIGsgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICg7IGsgPCBrbGVuOyArK2spIHtcclxuXHRcdFx0XHR0YXJnZXRba2V5c1trXV0gPSBoZWxwZXJzLmNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXHJcblx0ICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9tZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcblx0XHRcdC8vIFdlIHdhbnQgdG8gZW5zdXJlIHdlIGRvIG5vdCBjb3B5IHByb3RvdHlwZXMgb3ZlclxyXG5cdFx0XHQvLyBhcyB0aGlzIGNhbiBwb2xsdXRlIGdsb2JhbCBuYW1lc3BhY2VzXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xyXG5cdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcclxuXHJcblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XHJcblx0XHRcdGhlbHBlcnMubWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XHJcblx0XHRpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG5cdFx0XHQvLyBXZSB3YW50IHRvIGVuc3VyZSB3ZSBkbyBub3QgY29weSBwcm90b3R5cGVzIG92ZXJcclxuXHRcdFx0Ly8gYXMgdGhpcyBjYW4gcG9sbHV0ZSBnbG9iYWwgbmFtZXNwYWNlc1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcclxuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xyXG5cdFx0XHRoZWxwZXJzLm1lcmdlSWYodHZhbCwgc3ZhbCk7XHJcblx0XHR9IGVsc2UgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cclxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cclxuXHQgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdG1lcmdlOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNvdXJjZXMgPSBoZWxwZXJzLmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xyXG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcclxuXHRcdHZhciBtZXJnZSwgaSwga2V5cywga2xlbiwgaztcclxuXHJcblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0bWVyZ2UgPSBvcHRpb25zLm1lcmdlciB8fCBoZWxwZXJzLl9tZXJnZXI7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xyXG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuXHRcdFx0Zm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XHJcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cclxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cclxuXHQgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cclxuXHQgKi9cclxuXHRtZXJnZUlmOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xyXG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQXBwbGllcyB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBvYmplY3RzIGFyZSBtZXJnZWQgaW50by5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ04gLSBBZGRpdGlvbmFsIG9iamVjdHMgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluIHRhcmdldC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGV4dGVuZDogT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRhcmdldCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCB7XHJcblx0XHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCBkc3QsIHNyYykge1xyXG5cdFx0XHRcdGRzdFtrZXldID0gc3JjW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJhc2ljIGphdmFzY3JpcHQgaW5oZXJpdGFuY2UgYmFzZWQgb24gdGhlIG1vZGVsIGNyZWF0ZWQgaW4gQmFja2JvbmUuanNcclxuXHQgKi9cclxuXHRpbmhlcml0czogZnVuY3Rpb24oZXh0ZW5zaW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBDaGFydEVsZW1lbnQgPSAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSA/IGV4dGVuc2lvbnMuY29uc3RydWN0b3IgOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIG1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IENoYXJ0RWxlbWVudDtcclxuXHRcdH07XHJcblxyXG5cdFx0U3Vycm9nYXRlLnByb3RvdHlwZSA9IG1lLnByb3RvdHlwZTtcclxuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XHJcblx0XHRDaGFydEVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcclxuXHJcblx0XHRpZiAoZXh0ZW5zaW9ucykge1xyXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChDaGFydEVsZW1lbnQucHJvdG90eXBlLCBleHRlbnNpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRDaGFydEVsZW1lbnQuX19zdXBlcl9fID0gbWUucHJvdG90eXBlO1xyXG5cdFx0cmV0dXJuIENoYXJ0RWxlbWVudDtcclxuXHR9LFxyXG5cclxuXHRfZGVwcmVjYXRlZDogZnVuY3Rpb24oc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xyXG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xyXG5cdFx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnZhciBoZWxwZXJzX2NvcmUgPSBoZWxwZXJzO1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmNhbGxDYWxsYmFja1xyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXHJcbiAqIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmluZGV4T2ZcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbUluZGV4KSB7XHJcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIGl0ZW0sIGZyb21JbmRleCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHRcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG4vKipcclxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXHJcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cclxuICovXHJcbnZhciBlZmZlY3RzID0ge1xyXG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQ7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQgKiB0O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogdDtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQ7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XHJcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dFF1aW50OiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcclxuXHRcdH1cclxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluU2luZTogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIC1NYXRoLmNvcyh0ICogKE1hdGguUEkgLyAyKSkgKyAxO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRTaW5lOiBmdW5jdGlvbih0KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0RXhwbzogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHQgPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKHQgPj0gMSkge1xyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHRcdH1cclxuXHRcdHJldHVybiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XHJcblx0fSxcclxuXHJcblx0ZWFzZU91dENpcmM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcblx0XHRcdHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdHZhciBzID0gMS43MDE1ODtcclxuXHRcdHZhciBwID0gMDtcclxuXHRcdHZhciBhID0gMTtcclxuXHRcdGlmICh0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHQgPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoIXApIHtcclxuXHRcdFx0cCA9IDAuMztcclxuXHRcdH1cclxuXHRcdGlmIChhIDwgMSkge1xyXG5cdFx0XHRhID0gMTtcclxuXHRcdFx0cyA9IHAgLyA0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XHJcblx0XHR2YXIgcyA9IDEuNzAxNTg7XHJcblx0XHR2YXIgcCA9IDA7XHJcblx0XHR2YXIgYSA9IDE7XHJcblx0XHRpZiAodCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHRcdGlmICh0ID09PSAxKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFwKSB7XHJcblx0XHRcdHAgPSAwLjM7XHJcblx0XHR9XHJcblx0XHRpZiAoYSA8IDEpIHtcclxuXHRcdFx0YSA9IDE7XHJcblx0XHRcdHMgPSBwIC8gNDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XHJcblx0fSxcclxuXHJcblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0dmFyIHAgPSAwO1xyXG5cdFx0dmFyIGEgPSAxO1xyXG5cdFx0aWYgKHQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0XHRpZiAoKHQgLz0gMC41KSA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICghcCkge1xyXG5cdFx0XHRwID0gMC40NTtcclxuXHRcdH1cclxuXHRcdGlmIChhIDwgMSkge1xyXG5cdFx0XHRhID0gMTtcclxuXHRcdFx0cyA9IHAgLyA0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcclxuXHRcdH1cclxuXHRcdGlmICh0IDwgMSkge1xyXG5cdFx0XHRyZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XHJcblx0fSxcclxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XHJcblx0XHR2YXIgcyA9IDEuNzAxNTg7XHJcblx0XHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcclxuXHR9LFxyXG5cclxuXHRlYXNlT3V0QmFjazogZnVuY3Rpb24odCkge1xyXG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xyXG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcclxuXHR9LFxyXG5cclxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XHJcblx0XHR2YXIgcyA9IDEuNzAxNTg7XHJcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xyXG5cdFx0cmV0dXJuIDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xyXG5cdH0sXHJcblxyXG5cdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlmICh0IDwgKDEgLyAyLjc1KSkge1xyXG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XHJcblx0XHR9XHJcblx0XHRpZiAodCA8ICgyIC8gMi43NSkpIHtcclxuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcclxuXHRcdH1cclxuXHRcdGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XHJcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1O1xyXG5cdH0sXHJcblxyXG5cdGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24odCkge1xyXG5cdFx0aWYgKHQgPCAwLjUpIHtcclxuXHRcdFx0cmV0dXJuIGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgaGVscGVyc19lYXNpbmcgPSB7XHJcblx0ZWZmZWN0czogZWZmZWN0c1xyXG59O1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzIGluc3RlYWQuXHJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzX2NvcmUuZWFzaW5nRWZmZWN0cyA9IGVmZmVjdHM7XG5cbnZhciBQSSA9IE1hdGguUEk7XHJcbnZhciBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xyXG52YXIgRE9VQkxFX1BJID0gUEkgKiAyO1xyXG52YXIgSEFMRl9QSSA9IFBJIC8gMjtcclxudmFyIFFVQVJURVJfUEkgPSBQSSAvIDQ7XHJcbnZhciBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2FudmFzXHJcbiAqL1xyXG52YXIgZXhwb3J0cyQxID0ge1xyXG5cdC8qKlxyXG5cdCAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcyBhc3NvY2lhdGVkIHRvIHRoZSBnaXZlbiBgY2hhcnRgLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxyXG5cdCAqL1xyXG5cdGNsZWFyOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgXCJwYXRoXCIgZm9yIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIGF0IHBvc2l0aW9uICh4LCB5KSB3aXRoIGFcclxuXHQgKiBnaXZlbiBzaXplICh3aWR0aCwgaGVpZ2h0KSBhbmQgdGhlIHNhbWUgYHJhZGl1c2AgZm9yIGFsbCBjb3JuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZWN0YW5nbGUncyBoZWlnaHQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByb3VuZGVkIGFtb3VudCAoaW4gcGl4ZWxzKSBmb3IgdGhlIGZvdXIgY29ybmVycy5cclxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XHJcblx0ICovXHJcblx0cm91bmRlZFJlY3Q6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XHJcblx0XHRpZiAocmFkaXVzKSB7XHJcblx0XHRcdHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpO1xyXG5cdFx0XHR2YXIgbGVmdCA9IHggKyByO1xyXG5cdFx0XHR2YXIgdG9wID0geSArIHI7XHJcblx0XHRcdHZhciByaWdodCA9IHggKyB3aWR0aCAtIHI7XHJcblx0XHRcdHZhciBib3R0b20gPSB5ICsgaGVpZ2h0IC0gcjtcclxuXHJcblx0XHRcdGN0eC5tb3ZlVG8oeCwgdG9wKTtcclxuXHRcdFx0aWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcclxuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAtSEFMRl9QSSk7XHJcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XHJcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgYm90dG9tLCByLCAwLCBIQUxGX1BJKTtcclxuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgUEkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xyXG5cdFx0XHRcdGN0eC5tb3ZlVG8obGVmdCwgeSk7XHJcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIFBJICsgSEFMRl9QSSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgMCk7XHJcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIFBJKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCBQSSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKSB7XHJcblx0XHR2YXIgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xyXG5cdFx0dmFyIHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xyXG5cclxuXHRcdGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcblx0XHRcdFx0Y3R4LnJvdGF0ZShyYWQpO1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdFx0c3dpdGNoIChzdHlsZSkge1xyXG5cdFx0Ly8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBET1VCTEVfUEkpO1xyXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAndHJpYW5nbGUnOlxyXG5cdFx0XHRjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XHJcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XHJcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdyZWN0Um91bmRlZCc6XHJcblx0XHRcdC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxyXG5cdFx0XHQvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xyXG5cdFx0XHQvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XHJcblx0XHRcdC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXHJcblx0XHRcdC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XHJcblx0XHRcdGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xyXG5cdFx0XHRzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xyXG5cdFx0XHRjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XHJcblx0XHRcdGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XHJcblx0XHRcdGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XHJcblx0XHRcdGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcclxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3JlY3QnOlxyXG5cdFx0XHRpZiAoIXJvdGF0aW9uKSB7XHJcblx0XHRcdFx0c2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcclxuXHRcdFx0XHRjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XHJcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHRcdGNhc2UgJ3JlY3RSb3QnOlxyXG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2Nyb3NzUm90JzpcclxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XHJcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHRcdGNhc2UgJ2Nyb3NzJzpcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnc3Rhcic6XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcclxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xyXG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnbGluZSc6XHJcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xyXG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnZGFzaCc6XHJcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XHJcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmZpbGwoKTtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJlYSAtIFRoZSByZWN0YW5nbGVcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9pc1BvaW50SW5BcmVhOiBmdW5jdGlvbihwb2ludCwgYXJlYSkge1xyXG5cdFx0dmFyIGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gZXBzaWxvbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIGVwc2lsb24gJiZcclxuXHRcdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gZXBzaWxvbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBlcHNpbG9uO1xyXG5cdH0sXHJcblxyXG5cdGNsaXBBcmVhOiBmdW5jdGlvbihjdHgsIGFyZWEpIHtcclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcclxuXHRcdGN0eC5jbGlwKCk7XHJcblx0fSxcclxuXHJcblx0dW5jbGlwQXJlYTogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH0sXHJcblxyXG5cdGxpbmVUbzogZnVuY3Rpb24oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XHJcblx0XHR2YXIgc3RlcHBlZCA9IHRhcmdldC5zdGVwcGVkTGluZTtcclxuXHRcdGlmIChzdGVwcGVkKSB7XHJcblx0XHRcdGlmIChzdGVwcGVkID09PSAnbWlkZGxlJykge1xyXG5cdFx0XHRcdHZhciBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyB0YXJnZXQueSA6IHByZXZpb3VzLnkpO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyBwcmV2aW91cy55IDogdGFyZ2V0LnkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKChzdGVwcGVkID09PSAnYWZ0ZXInICYmICFmbGlwKSB8fCAoc3RlcHBlZCAhPT0gJ2FmdGVyJyAmJiBmbGlwKSkge1xyXG5cdFx0XHRcdGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGFyZ2V0LnRlbnNpb24pIHtcclxuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmJlemllckN1cnZlVG8oXHJcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1ggOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WCxcclxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWSA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRZLFxyXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRYIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWCxcclxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WSA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1ksXHJcblx0XHRcdHRhcmdldC54LFxyXG5cdFx0XHR0YXJnZXQueSk7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnNfY2FudmFzID0gZXhwb3J0cyQxO1xyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5jbGVhciBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2xlYXJcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzX2NvcmUuY2xlYXIgPSBleHBvcnRzJDEuY2xlYXI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5yb3VuZGVkUmVjdCBpbnN0ZWFkLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZHJhd1JvdW5kZWRSZWN0YW5nbGVcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzX2NvcmUuZHJhd1JvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0ZXhwb3J0cyQxLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMkMSwgYXJndW1lbnRzKTtcclxufTtcblxudmFyIGRlZmF1bHRzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3NldDogZnVuY3Rpb24oc2NvcGUsIHZhbHVlcykge1xyXG5cdFx0cmV0dXJuIGhlbHBlcnNfY29yZS5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyh2Myk6IHJlbW92ZSAnZ2xvYmFsJyBmcm9tIG5hbWVzcGFjZS4gIGFsbCBkZWZhdWx0IGFyZSBnbG9iYWwgYW5kXHJcbi8vIHRoZXJlJ3MgaW5jb25zaXN0ZW5jeSBhcm91bmQgd2hpY2ggb3B0aW9ucyBhcmUgdW5kZXIgJ2dsb2JhbCdcclxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGRlZmF1bHRDb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXHJcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxyXG5cdGRlZmF1bHRGb250RmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXHJcblx0ZGVmYXVsdEZvbnRTaXplOiAxMixcclxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcclxuXHRkZWZhdWx0TGluZUhlaWdodDogMS4yLFxyXG5cdHNob3dMaW5lczogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBjb3JlX2RlZmF1bHRzID0gZGVmYXVsdHM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnNfY29yZS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cclxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcclxuXHRpZiAoIWZvbnQgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxyXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxyXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xyXG5cdFx0KyBmb250LmZhbWlseTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGhlbHBlcnNfb3B0aW9ucyA9IHtcclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXHJcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXHJcblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHR0b0xpbmVIZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBzaXplKSB7XHJcblx0XHR2YXIgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XHJcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcclxuXHRcdFx0cmV0dXJuIHNpemUgKiAxLjI7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFsdWUgPSArbWF0Y2hlc1syXTtcclxuXHJcblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcclxuXHRcdGNhc2UgJ3B4JzpcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0Y2FzZSAnJSc6XHJcblx0XHRcdHZhbHVlIC89IDEwMDtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxyXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0dG9QYWRkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dmFyIHQsIHIsIGIsIGw7XHJcblxyXG5cdFx0aWYgKGhlbHBlcnNfY29yZS5pc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcclxuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xyXG5cdFx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xyXG5cdFx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0b3A6IHQsXHJcblx0XHRcdHJpZ2h0OiByLFxyXG5cdFx0XHRib3R0b206IGIsXHJcblx0XHRcdGxlZnQ6IGwsXHJcblx0XHRcdGhlaWdodDogdCArIGIsXHJcblx0XHRcdHdpZHRoOiBsICsgclxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBmb250IG9iamVjdC5cclxuXHQgKiBAdG9kbyBTdXBwb3J0IGZvbnQuKiBvcHRpb25zIGFuZCByZW5hbWVkIHRvIHRvRm9udCgpLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3BhcnNlRm9udDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XHJcblx0XHR2YXIgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XHJcblx0XHR2YXIgZm9udCA9IHtcclxuXHRcdFx0ZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcclxuXHRcdFx0bGluZUhlaWdodDogaGVscGVyc19jb3JlLm9wdGlvbnMudG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdExpbmVIZWlnaHQpLCBzaXplKSxcclxuXHRcdFx0c2l6ZTogc2l6ZSxcclxuXHRcdFx0c3R5bGU6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcclxuXHRcdFx0d2VpZ2h0OiBudWxsLFxyXG5cdFx0XHRzdHJpbmc6ICcnXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xyXG5cdFx0cmV0dXJuIGZvbnQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxyXG5cdCAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXHJcblx0ICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2luZm9dIC0gb2JqZWN0IHRvIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCByZXNvbHV0aW9uIGluXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5mby5jYWNoZWFibGVdIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cclxuXHQgKiBAc2luY2UgMi43LjBcclxuXHQgKi9cclxuXHRyZXNvbHZlOiBmdW5jdGlvbihpbnB1dHMsIGNvbnRleHQsIGluZGV4LCBpbmZvKSB7XHJcblx0XHR2YXIgY2FjaGVhYmxlID0gdHJ1ZTtcclxuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcclxuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoY29udGV4dCk7XHJcblx0XHRcdFx0Y2FjaGVhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaGVscGVyc19jb3JlLmlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtpbmRleF07XHJcblx0XHRcdFx0Y2FjaGVhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XHJcblx0XHRcdFx0XHRpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XG5cbi8qKlxyXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5tYXRoXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBleHBvcnRzJDIgPSB7XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWN0b3JzIHNvcnRlZCBmcm9tIDEgdG8gc3FydCh2YWx1ZSlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9mYWN0b3JpemU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHR2YXIgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XHJcblx0XHR2YXIgaTtcclxuXHJcblx0XHRmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XHJcblx0XHRcdGlmICh2YWx1ZSAlIGkgPT09IDApIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpKTtcclxuXHRcdFx0XHRyZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkgeyAvLyBpZiB2YWx1ZSBpcyBhIHNxdWFyZSBudW1iZXJcclxuXHRcdFx0cmVzdWx0LnB1c2goc3FydCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmVzdWx0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRyZXR1cm4gYSAtIGI7XHJcblx0XHR9KS5wb3AoKTtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0bG9nMTA6IE1hdGgubG9nMTAgfHwgZnVuY3Rpb24oeCkge1xyXG5cdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTsgLy8gTWF0aC5MT0cxMEUgPSAxIC8gTWF0aC5MTjEwLlxyXG5cdFx0Ly8gQ2hlY2sgZm9yIHdob2xlIHBvd2VycyBvZiAxMCxcclxuXHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxyXG5cdFx0dmFyIHBvd2VyT2YxMCA9IE1hdGgucm91bmQoZXhwb25lbnQpO1xyXG5cdFx0dmFyIGlzUG93ZXJPZjEwID0geCA9PT0gTWF0aC5wb3coMTAsIHBvd2VyT2YxMCk7XHJcblxyXG5cdFx0cmV0dXJuIGlzUG93ZXJPZjEwID8gcG93ZXJPZjEwIDogZXhwb25lbnQ7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnNfbWF0aCA9IGV4cG9ydHMkMjtcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5tYXRoLmxvZzEwIGluc3RlYWQuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5sb2cxMFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOS4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmhlbHBlcnNfY29yZS5sb2cxMCA9IGV4cG9ydHMkMi5sb2cxMDtcblxudmFyIGdldFJ0bEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcclxuXHRcdH0sXHJcblx0XHRzZXRXaWR0aDogZnVuY3Rpb24odykge1xyXG5cdFx0XHR3aWR0aCA9IHc7XHJcblx0XHR9LFxyXG5cdFx0dGV4dEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xyXG5cdFx0XHRpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFsaWduO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcblx0XHR9LFxyXG5cdFx0eFBsdXM6IGZ1bmN0aW9uKHgsIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiB4IC0gdmFsdWU7XHJcblx0XHR9LFxyXG5cdFx0bGVmdEZvckx0cjogZnVuY3Rpb24oeCwgaXRlbVdpZHRoKSB7XHJcblx0XHRcdHJldHVybiB4IC0gaXRlbVdpZHRoO1xyXG5cdFx0fSxcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIGdldEx0ckFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH0sXHJcblx0XHRzZXRXaWR0aDogZnVuY3Rpb24odykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHR9LFxyXG5cdFx0dGV4dEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xyXG5cdFx0XHRyZXR1cm4gYWxpZ247XHJcblx0XHR9LFxyXG5cdFx0eFBsdXM6IGZ1bmN0aW9uKHgsIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiB4ICsgdmFsdWU7XHJcblx0XHR9LFxyXG5cdFx0bGVmdEZvckx0cjogZnVuY3Rpb24oeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHRcdHJldHVybiB4O1xyXG5cdFx0fSxcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIGdldEFkYXB0ZXIgPSBmdW5jdGlvbihydGwsIHJlY3RYLCB3aWR0aCkge1xyXG5cdHJldHVybiBydGwgPyBnZXRSdGxBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMdHJBZGFwdGVyKCk7XHJcbn07XHJcblxyXG52YXIgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uID0gZnVuY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcclxuXHR2YXIgc3R5bGUsIG9yaWdpbmFsO1xyXG5cdGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuXHRcdHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcclxuXHRcdG9yaWdpbmFsID0gW1xyXG5cdFx0XHRzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcclxuXHRcdFx0c3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXHJcblx0XHRdO1xyXG5cclxuXHRcdHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcclxuXHRcdGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xyXG5cdH1cclxufTtcclxuXHJcbnZhciByZXN0b3JlVGV4dERpcmVjdGlvbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdHZhciBvcmlnaW5hbCA9IGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcclxuXHRpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZGVsZXRlIGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcclxuXHRcdGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XHJcblx0fVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnNfcnRsID0ge1xyXG5cdGdldFJ0bEFkYXB0ZXI6IGdldEFkYXB0ZXIsXHJcblx0b3ZlcnJpZGVUZXh0RGlyZWN0aW9uOiBvdmVycmlkZVRleHREaXJlY3Rpb24sXHJcblx0cmVzdG9yZVRleHREaXJlY3Rpb246IHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxyXG59O1xuXG52YXIgaGVscGVycyQxID0gaGVscGVyc19jb3JlO1xyXG52YXIgZWFzaW5nID0gaGVscGVyc19lYXNpbmc7XHJcbnZhciBjYW52YXMgPSBoZWxwZXJzX2NhbnZhcztcclxudmFyIG9wdGlvbnMgPSBoZWxwZXJzX29wdGlvbnM7XHJcbnZhciBtYXRoID0gaGVscGVyc19tYXRoO1xyXG52YXIgcnRsID0gaGVscGVyc19ydGw7XG5oZWxwZXJzJDEuZWFzaW5nID0gZWFzaW5nO1xuaGVscGVycyQxLmNhbnZhcyA9IGNhbnZhcztcbmhlbHBlcnMkMS5vcHRpb25zID0gb3B0aW9ucztcbmhlbHBlcnMkMS5tYXRoID0gbWF0aDtcbmhlbHBlcnMkMS5ydGwgPSBydGw7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSkge1xyXG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9kZWwpO1xyXG5cdHZhciBpLCBpbGVuLCBrZXksIGFjdHVhbCwgb3JpZ2luLCB0YXJnZXQsIHR5cGUsIGMwLCBjMTtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRrZXkgPSBrZXlzW2ldO1xyXG5cclxuXHRcdHRhcmdldCA9IG1vZGVsW2tleV07XHJcblxyXG5cdFx0Ly8gaWYgYSB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgbW9kZWwgYWZ0ZXIgcGl2b3QoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB2aWV3XHJcblx0XHQvLyBkb2Vzbid0IGNvbnRhaW4gaXQsIHNvIGxldCdzIGluaXRpYWxpemUgdGhlIHZpZXcgdG8gdGhlIHRhcmdldCB2YWx1ZS5cclxuXHRcdGlmICghdmlldy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdHZpZXdba2V5XSA9IHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRhY3R1YWwgPSB2aWV3W2tleV07XHJcblxyXG5cdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3RhcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRzdGFydFtrZXldID0gYWN0dWFsO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9yaWdpbiA9IHN0YXJ0W2tleV07XHJcblxyXG5cdFx0dHlwZSA9IHR5cGVvZiB0YXJnZXQ7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09IHR5cGVvZiBvcmlnaW4pIHtcclxuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0YzAgPSBjaGFydGpzQ29sb3Iob3JpZ2luKTtcclxuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcclxuXHRcdFx0XHRcdGMxID0gY2hhcnRqc0NvbG9yKHRhcmdldCk7XHJcblx0XHRcdFx0XHRpZiAoYzEudmFsaWQpIHtcclxuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0Zpbml0ZShvcmlnaW4pICYmIGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XHJcblx0XHRcdFx0dmlld1trZXldID0gb3JpZ2luICsgKHRhcmdldCAtIG9yaWdpbikgKiBlYXNlO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmlld1trZXldID0gdGFyZ2V0O1xyXG5cdH1cclxufVxyXG5cclxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XHJcblx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcclxuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmhlbHBlcnMkMS5leHRlbmQoRWxlbWVudC5wcm90b3R5cGUsIHtcclxuXHRfdHlwZTogdW5kZWZpbmVkLFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0cGl2b3Q6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmICghbWUuX3ZpZXcpIHtcclxuXHRcdFx0bWUuX3ZpZXcgPSBoZWxwZXJzJDEuZXh0ZW5kKHt9LCBtZS5fbW9kZWwpO1xyXG5cdFx0fVxyXG5cdFx0bWUuX3N0YXJ0ID0ge307XHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcclxuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcclxuXHRcdHZhciB2aWV3ID0gbWUuX3ZpZXc7XHJcblxyXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cclxuXHRcdGlmICghbW9kZWwgfHwgZWFzZSA9PT0gMSkge1xyXG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5leHRlbmQoe30sIG1vZGVsKTtcclxuXHRcdFx0bWUuX3N0YXJ0ID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIG1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdmlldykge1xyXG5cdFx0XHR2aWV3ID0gbWUuX3ZpZXcgPSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN0YXJ0KSB7XHJcblx0XHRcdHN0YXJ0ID0gbWUuX3N0YXJ0ID0ge307XHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJwb2xhdGUoc3RhcnQsIHZpZXcsIG1vZGVsLCBlYXNlKTtcclxuXHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXHJcblx0XHRcdHk6IHRoaXMuX21vZGVsLnlcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aGFzVmFsdWU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XHJcblx0fVxyXG59KTtcclxuXHJcbkVsZW1lbnQuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xyXG5cclxudmFyIGNvcmVfZWxlbWVudCA9IEVsZW1lbnQ7XG5cbnZhciBleHBvcnRzJDMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRjaGFydDogbnVsbCwgLy8gdGhlIGFuaW1hdGlvbiBhc3NvY2lhdGVkIGNoYXJ0IGluc3RhbmNlXHJcblx0Y3VycmVudFN0ZXA6IDAsIC8vIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGVwXHJcblx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xyXG5cdGVhc2luZzogJycsIC8vIHRoZSBlYXNpbmcgdG8gdXNlIGZvciB0aGlzIGFuaW1hdGlvblxyXG5cdHJlbmRlcjogbnVsbCwgLy8gcmVuZGVyIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGFuaW1hdGlvbiBzZXJ2aWNlXHJcblxyXG5cdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgb24gZWFjaCBzdGVwIG9mIHRoZSBhbmltYXRpb25cclxuXHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlc1xyXG59KTtcclxuXHJcbnZhciBjb3JlX2FuaW1hdGlvbiA9IGV4cG9ydHMkMztcclxuXHJcbi8vIERFUFJFQ0FUSU9OU1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uIGluc3RlYWRcclxuICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2FuaW1hdGlvbk9iamVjdFxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDMucHJvdG90eXBlLCAnYW5pbWF0aW9uT2JqZWN0Jywge1xyXG5cdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcclxuICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0SW5zdGFuY2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQzLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XHJcblx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0O1xyXG5cdH0sXHJcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0dGhpcy5jaGFydCA9IHZhbHVlO1xyXG5cdH1cclxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGFuaW1hdGlvbjoge1xyXG5cdFx0ZHVyYXRpb246IDEwMDAsXHJcblx0XHRlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxyXG5cdFx0b25Qcm9ncmVzczogaGVscGVycyQxLm5vb3AsXHJcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzJDEubm9vcFxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29yZV9hbmltYXRpb25zID0ge1xyXG5cdGFuaW1hdGlvbnM6IFtdLFxyXG5cdHJlcXVlc3Q6IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXHJcblx0ICogQHBhcmFtIHtDaGFydC5BbmltYXRpb259IGFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdGhhdCB3ZSB3aWxsIGFuaW1hdGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtcy5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcclxuXHQgKi9cclxuXHRhZGRBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb24sIGR1cmF0aW9uLCBsYXp5KSB7XHJcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xyXG5cdFx0YW5pbWF0aW9uLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuXHJcblx0XHRpZiAoIWxhenkpIHtcclxuXHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XHJcblx0XHRcdFx0YW5pbWF0aW9uc1tpXSA9IGFuaW1hdGlvbjtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcclxuXHJcblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBxdWV1ZWQsIG1hbnVhbGx5IGtpY2tzdGFydCBhIGRpZ2VzdCwgZm9yIGxhY2sgb2YgYSBiZXR0ZXIgd29yZFxyXG5cdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2FuY2VsQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGluZGV4ID0gaGVscGVycyQxLmZpbmRJbmRleCh0aGlzLmFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uLmNoYXJ0ID09PSBjaGFydDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0dGhpcy5hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcclxuXHRcdFx0Ly8gU2tpcCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdHMgdW50aWwgdGhlIGFjdGl2ZSBvbmUgaXMgZXhlY3V0ZWQuXHJcblx0XHRcdC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHByb2Nlc3NpbmcgbW91c2UgZXZlbnRzLCBlLmcuICdtb3VzZW1vdmUnXHJcblx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cclxuXHRcdFx0bWUucmVxdWVzdCA9IGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRtZS5yZXF1ZXN0ID0gbnVsbDtcclxuXHRcdFx0XHRtZS5zdGFydERpZ2VzdCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHN0YXJ0RGlnZXN0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0bWUuYWR2YW5jZSgpO1xyXG5cclxuXHRcdC8vIERvIHdlIGhhdmUgbW9yZSBzdHVmZiB0byBhbmltYXRlP1xyXG5cdFx0aWYgKG1lLmFuaW1hdGlvbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGFkdmFuY2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XHJcblx0XHR2YXIgYW5pbWF0aW9uLCBjaGFydCwgbnVtU3RlcHMsIG5leHRTdGVwO1xyXG5cdFx0dmFyIGkgPSAwO1xyXG5cclxuXHRcdC8vIDEgYW5pbWF0aW9uIHBlciBjaGFydCwgc28gd2UgYXJlIGxvb3BpbmcgY2hhcnRzIGhlcmVcclxuXHRcdHdoaWxlIChpIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcclxuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uc1tpXTtcclxuXHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XHJcblx0XHRcdG51bVN0ZXBzID0gYW5pbWF0aW9uLm51bVN0ZXBzO1xyXG5cclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY3VycmVudFN0ZXAgc3RhcnRzIGF0IDFcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYxMDRcclxuXHRcdFx0bmV4dFN0ZXAgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gYW5pbWF0aW9uLnN0YXJ0VGltZSkgLyBhbmltYXRpb24uZHVyYXRpb24gKiBudW1TdGVwcykgKyAxO1xyXG5cdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihuZXh0U3RlcCwgbnVtU3RlcHMpO1xyXG5cclxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5yZW5kZXIsIFtjaGFydCwgYW5pbWF0aW9uXSwgY2hhcnQpO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XHJcblxyXG5cdFx0XHRpZiAoYW5pbWF0aW9uLmN1cnJlbnRTdGVwID49IG51bVN0ZXBzKSB7XHJcblx0XHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xyXG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdGFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCsraTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcblxudmFyIHJlc29sdmUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xyXG5cclxudmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xyXG5cclxuLyoqXHJcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXHJcbiAqICd1bnNoaWZ0JykgYW5kIG5vdGlmeSB0aGUgbGlzdGVuZXIgQUZURVIgdGhlIGFycmF5IGhhcyBiZWVuIGFsdGVyZWQuIExpc3RlbmVycyBhcmVcclxuICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcclxuXHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcclxuXHRcdGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xyXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXHJcblx0XHR2YWx1ZToge1xyXG5cdFx0XHRsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuXHRcdHZhciBtZXRob2QgPSAnb25EYXRhJyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcclxuXHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdFx0XHRcdHZhciByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cclxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRvYmplY3RbbWV0aG9kXS5hcHBseShvYmplY3QsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGFycmF5IGV2ZW50IGxpc3RlbmVyIGFuZCBjbGVhbnVwIGV4dHJhIGF0dGFjaGVkIHByb3BlcnRpZXMgKHN1Y2ggYXNcclxuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cclxuICovXHJcbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XHJcblx0dmFyIHN0dWIgPSBhcnJheS5fY2hhcnRqcztcclxuXHRpZiAoIXN0dWIpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcclxuXHR2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcblx0aWYgKGluZGV4ICE9PSAtMSkge1xyXG5cdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0fVxyXG5cclxuXHRpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRkZWxldGUgYXJyYXlba2V5XTtcclxuXHR9KTtcclxuXHJcblx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xyXG59XHJcblxyXG4vLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXHJcbnZhciBEYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcclxuXHR0aGlzLmluaXRpYWxpemUoY2hhcnQsIGRhdGFzZXRJbmRleCk7XHJcbn07XHJcblxyXG5oZWxwZXJzJDEuZXh0ZW5kKERhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHQvKipcclxuXHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmUpLlxyXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XHJcblx0ICovXHJcblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50KS5cclxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxyXG5cdCAqL1xyXG5cdGRhdGFFbGVtZW50VHlwZTogbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogRGF0YXNldCBlbGVtZW50IG9wdGlvbiBrZXlzIHRvIGJlIHJlc29sdmVkIGluIF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zLlxyXG5cdCAqIEEgZGVyaXZlZCBjb250cm9sbGVyIG1heSBvdmVycmlkZSB0aGlzIHRvIHJlc29sdmUgY29udHJvbGxlci1zcGVjaWZpYyBvcHRpb25zLlxyXG5cdCAqIFRoZSBrZXlzIGRlZmluZWQgaGVyZSBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGxlZ2VuZCBzdHlsZXMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YXNldEVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDYXBTdHlsZScsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlckRhc2gnLFxyXG5cdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxyXG5cdFx0J2JvcmRlckpvaW5TdHlsZScsXHJcblx0XHQnYm9yZGVyV2lkdGgnXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogRGF0YSBlbGVtZW50IG9wdGlvbiBrZXlzIHRvIGJlIHJlc29sdmVkIGluIF9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLlxyXG5cdCAqIEEgZGVyaXZlZCBjb250cm9sbGVyIG1heSBvdmVycmlkZSB0aGlzIHRvIHJlc29sdmUgY29udHJvbGxlci1zcGVjaWZpYyBvcHRpb25zLlxyXG5cdCAqIFRoZSBrZXlzIGRlZmluZWQgaGVyZSBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGxlZ2VuZCBzdHlsZXMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J3BvaW50U3R5bGUnXHJcblx0XSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY2hhcnQsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLmNoYXJ0ID0gY2hhcnQ7XHJcblx0XHRtZS5pbmRleCA9IGRhdGFzZXRJbmRleDtcclxuXHRcdG1lLmxpbmtTY2FsZXMoKTtcclxuXHRcdG1lLmFkZEVsZW1lbnRzKCk7XHJcblx0XHRtZS5fdHlwZSA9IG1lLmdldE1ldGEoKS50eXBlO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUluZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XHJcblx0fSxcclxuXHJcblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBzY2FsZXNPcHRzID0gY2hhcnQub3B0aW9ucy5zY2FsZXM7XHJcblxyXG5cdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbnVsbCB8fCAhKG1ldGEueEF4aXNJRCBpbiBzY2FsZXMpIHx8IGRhdGFzZXQueEF4aXNJRCkge1xyXG5cdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgc2NhbGVzT3B0cy54QXhlc1swXS5pZDtcclxuXHRcdH1cclxuXHRcdGlmIChtZXRhLnlBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnlBeGlzSUQgaW4gc2NhbGVzKSB8fCBkYXRhc2V0LnlBeGlzSUQpIHtcclxuXHRcdFx0bWV0YS55QXhpc0lEID0gZGF0YXNldC55QXhpc0lEIHx8IHNjYWxlc09wdHMueUF4ZXNbMF0uaWQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdGdldE1ldGE6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVGb3JJZDogZnVuY3Rpb24oc2NhbGVJRCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldFZhbHVlU2NhbGVJZCgpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRJbmRleFNjYWxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5fZ2V0SW5kZXhTY2FsZUlkKCkpO1xyXG5cdH0sXHJcblxyXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZSh0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHRoaXMuX2RhdGEpIHtcclxuXHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjcmVhdGVNZXRhRGF0YXNldDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XHJcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XHJcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXHJcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVNZXRhRGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFFbGVtZW50VHlwZTtcclxuXHRcdHJldHVybiB0eXBlICYmIG5ldyB0eXBlKHtcclxuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcclxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdF9pbmRleDogaW5kZXhcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGFkZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGEgfHwgW107XHJcblx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWV0YURhdGFbaV0gPSBtZXRhRGF0YVtpXSB8fCBtZS5jcmVhdGVNZXRhRGF0YShpKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLmRhdGFzZXQgPSBtZXRhLmRhdGFzZXQgfHwgbWUuY3JlYXRlTWV0YURhdGFzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlTWV0YURhdGEoaW5kZXgpO1xyXG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xyXG5cdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRidWlsZE9yVXBkYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcclxuXHJcblx0XHQvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbiB0aHVzIHNpbXVsYXRlXHJcblx0XHQvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcclxuXHRcdC8vIHRoZSBpbnRlcm5hbCBtZXRhIGRhdGEgYWNjb3JkaW5nbHkuXHJcblx0XHRpZiAobWUuX2RhdGEgIT09IGRhdGEpIHtcclxuXHRcdFx0aWYgKG1lLl9kYXRhKSB7XHJcblx0XHRcdFx0Ly8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cclxuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKG1lLl9kYXRhLCBtZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcclxuXHRcdFx0XHRsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCBtZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXHJcblx0XHQvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxyXG5cdFx0bWUucmVzeW5jRWxlbWVudHMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBtZXJnZWQgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdG1lLl9jb25maWcgPSBoZWxwZXJzJDEubWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xyXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmRhdGFzZXRzW21lLl90eXBlXSxcclxuXHRcdFx0bWUuZ2V0RGF0YXNldCgpLFxyXG5cdFx0XSwge1xyXG5cdFx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcclxuXHRcdFx0XHRpZiAoa2V5ICE9PSAnX21ldGEnICYmIGtleSAhPT0gJ2RhdGEnKSB7XHJcblx0XHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0bWUuX2NvbmZpZ3VyZSgpO1xyXG5cdFx0bWUuX2NhY2hlZERhdGFPcHRzID0gbnVsbDtcclxuXHRcdG1lLnVwZGF0ZShyZXNldCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRlbGVtZW50c1tpXS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XHJcblx0XHRcdG1ldGEuZGF0YXNldC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XHJcblx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XHJcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZWxlbWVudHNbaV0uZHJhdygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XHJcblx0ICogb3IgdGhlIGRhdGEgaWYgdGhlIGluZGV4IGlzIHNwZWNpZmllZFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcclxuXHQgKiBAcmV0dXJuIHtJU3R5bGVJbnRlcmZhY2V9IHN0eWxlIG9iamVjdFxyXG5cdCAqL1xyXG5cdGdldFN0eWxlOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XHJcblx0XHR2YXIgc3R5bGU7XHJcblxyXG5cdFx0bWUuX2NvbmZpZ3VyZSgpO1xyXG5cdFx0aWYgKGRhdGFzZXQgJiYgaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzdHlsZSA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGRhdGFzZXQgfHwge30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5kZXggPSBpbmRleCB8fCAwO1xyXG5cdFx0XHRzdHlsZSA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKG1ldGEuZGF0YVtpbmRleF0gfHwge30sIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3R5bGUuZmlsbCA9PT0gZmFsc2UgfHwgc3R5bGUuZmlsbCA9PT0gbnVsbCkge1xyXG5cdFx0XHRzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZS5ib3JkZXJDb2xvcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3R5bGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaG92ZXIpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkYXRhc2V0T3B0cyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHNbbWUuZGF0YXNldEVsZW1lbnRUeXBlLnByb3RvdHlwZS5fdHlwZV0gfHwge307XHJcblx0XHR2YXIgZWxlbWVudE9wdGlvbnMgPSBtZS5fZGF0YXNldEVsZW1lbnRPcHRpb25zO1xyXG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xyXG5cdFx0dmFyIGksIGlsZW4sIGtleSwgcmVhZEtleTtcclxuXHJcblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcclxuXHRcdHZhciBjb250ZXh0ID0ge1xyXG5cdFx0XHRjaGFydDogY2hhcnQsXHJcblx0XHRcdGRhdGFzZXQ6IG1lLmdldERhdGFzZXQoKSxcclxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleCxcclxuXHRcdFx0aG92ZXI6IGhvdmVyXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50T3B0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0a2V5ID0gZWxlbWVudE9wdGlvbnNbaV07XHJcblx0XHRcdHJlYWRLZXkgPSBob3ZlciA/ICdob3ZlcicgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkgOiBrZXk7XHJcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZShbXHJcblx0XHRcdFx0Y3VzdG9tW3JlYWRLZXldLFxyXG5cdFx0XHRcdGRhdGFzZXRPcHRzW3JlYWRLZXldLFxyXG5cdFx0XHRcdG9wdGlvbnNbcmVhZEtleV1cclxuXHRcdFx0XSwgY29udGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50ICYmIGVsZW1lbnQuY3VzdG9tO1xyXG5cdFx0dmFyIGNhY2hlZCA9IG1lLl9jYWNoZWREYXRhT3B0cztcclxuXHRcdGlmIChjYWNoZWQgJiYgIWN1c3RvbSkge1xyXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldE9wdHMgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzW21lLmRhdGFFbGVtZW50VHlwZS5wcm90b3R5cGUuX3R5cGVdIHx8IHt9O1xyXG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gbWUuX2RhdGFFbGVtZW50T3B0aW9ucztcclxuXHRcdHZhciB2YWx1ZXMgPSB7fTtcclxuXHJcblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcclxuXHRcdHZhciBjb250ZXh0ID0ge1xyXG5cdFx0XHRjaGFydDogY2hhcnQsXHJcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXHJcblx0XHRcdGRhdGFzZXQ6IG1lLmdldERhdGFzZXQoKSxcclxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBgcmVzb2x2ZWAgc2V0cyBjYWNoZWFibGUgdG8gYGZhbHNlYCBpZiBhbnkgb3B0aW9uIGlzIGluZGV4ZWQgb3Igc2NyaXB0ZWRcclxuXHRcdHZhciBpbmZvID0ge2NhY2hlYWJsZTogIWN1c3RvbX07XHJcblxyXG5cdFx0dmFyIGtleXMsIGksIGlsZW4sIGtleTtcclxuXHJcblx0XHRjdXN0b20gPSBjdXN0b20gfHwge307XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGVsZW1lbnRPcHRpb25zKSkge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudE9wdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0a2V5ID0gZWxlbWVudE9wdGlvbnNbaV07XHJcblx0XHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlKFtcclxuXHRcdFx0XHRcdGN1c3RvbVtrZXldLFxyXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNba2V5XSxcclxuXHRcdFx0XHRcdG9wdGlvbnNba2V5XVxyXG5cdFx0XHRcdF0sIGNvbnRleHQsIGluZGV4LCBpbmZvKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnRPcHRpb25zKTtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcclxuXHRcdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUoW1xyXG5cdFx0XHRcdFx0Y3VzdG9tW2tleV0sXHJcblx0XHRcdFx0XHRkYXRhc2V0T3B0c1tlbGVtZW50T3B0aW9uc1trZXldXSxcclxuXHRcdFx0XHRcdGRhdGFzZXRPcHRzW2tleV0sXHJcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cclxuXHRcdFx0XHRdLCBjb250ZXh0LCBpbmRleCwgaW5mbyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW5mby5jYWNoZWFibGUpIHtcclxuXHRcdFx0bWUuX2NhY2hlZERhdGFPcHRzID0gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdFx0aGVscGVycyQxLm1lcmdlKGVsZW1lbnQuX21vZGVsLCBlbGVtZW50LiRwcmV2aW91c1N0eWxlIHx8IHt9KTtcclxuXHRcdGRlbGV0ZSBlbGVtZW50LiRwcmV2aW91c1N0eWxlO1xyXG5cdH0sXHJcblxyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF07XHJcblx0XHR2YXIgaW5kZXggPSBlbGVtZW50Ll9pbmRleDtcclxuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcclxuXHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGhcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yLCBkYXRhc2V0LmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IsIGRhdGFzZXQuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGgsIGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgbW9kZWwuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0TWV0YSgpLmRhdGFzZXQ7XHJcblxyXG5cdFx0aWYgKGVsZW1lbnQpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3NldERhdGFzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRNZXRhKCkuZGF0YXNldDtcclxuXHRcdHZhciBwcmV2ID0ge307XHJcblx0XHR2YXIgaSwgaWxlbiwga2V5LCBrZXlzLCBob3Zlck9wdGlvbnMsIG1vZGVsO1xyXG5cclxuXHRcdGlmICghZWxlbWVudCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcclxuXHRcdGhvdmVyT3B0aW9ucyA9IHRoaXMuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMoZWxlbWVudCwgdHJ1ZSk7XHJcblxyXG5cdFx0a2V5cyA9IE9iamVjdC5rZXlzKGhvdmVyT3B0aW9ucyk7XHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0a2V5ID0ga2V5c1tpXTtcclxuXHRcdFx0cHJldltrZXldID0gbW9kZWxba2V5XTtcclxuXHRcdFx0bW9kZWxba2V5XSA9IGhvdmVyT3B0aW9uc1trZXldO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgPSBwcmV2O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVzeW5jRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YTtcclxuXHRcdHZhciBudW1NZXRhID0gbWV0YS5kYXRhLmxlbmd0aDtcclxuXHRcdHZhciBudW1EYXRhID0gZGF0YS5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKG51bURhdGEgPCBudW1NZXRhKSB7XHJcblx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xyXG5cdFx0fSBlbHNlIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xyXG5cdFx0XHRtZS5pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuXHRcdFx0dGhpcy5hZGRFbGVtZW50QW5kUmVzZXQoc3RhcnQgKyBpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHModGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25EYXRhUG9wOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNoaWZ0KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvbkRhdGFTcGxpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xyXG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcclxuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cygwLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xyXG5cclxudmFyIGNvcmVfZGF0YXNldENvbnRyb2xsZXIgPSBEYXRhc2V0Q29udHJvbGxlcjtcblxudmFyIFRBVSA9IE1hdGguUEkgKiAyO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0ZWxlbWVudHM6IHtcclxuXHRcdGFyYzoge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6ICcjZmZmJyxcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXHJcblx0XHRcdGJvcmRlckFsaWduOiAnY2VudGVyJ1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgYXJjKSB7XHJcblx0dmFyIHN0YXJ0QW5nbGUgPSBhcmMuc3RhcnRBbmdsZTtcclxuXHR2YXIgZW5kQW5nbGUgPSBhcmMuZW5kQW5nbGU7XHJcblx0dmFyIHBpeGVsTWFyZ2luID0gYXJjLnBpeGVsTWFyZ2luO1xyXG5cdHZhciBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gYXJjLm91dGVyUmFkaXVzO1xyXG5cdHZhciB4ID0gYXJjLng7XHJcblx0dmFyIHkgPSBhcmMueTtcclxuXHJcblx0Ly8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxyXG5cdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXHJcblx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdGN0eC5hcmMoeCwgeSwgYXJjLm91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xyXG5cdGlmIChhcmMuaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xyXG5cdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGFyYy5pbm5lclJhZGl1cztcclxuXHRcdGN0eC5hcmMoeCwgeSwgYXJjLmlubmVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgTWF0aC5QSSAvIDIsIHN0YXJ0QW5nbGUgLSBNYXRoLlBJIC8gMik7XHJcblx0fVxyXG5cdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRjdHguY2xpcCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCB2bSwgYXJjLCBpbm5lcikge1xyXG5cdHZhciBlbmRBbmdsZSA9IGFyYy5lbmRBbmdsZTtcclxuXHR2YXIgaTtcclxuXHJcblx0aWYgKGlubmVyKSB7XHJcblx0XHRhcmMuZW5kQW5nbGUgPSBhcmMuc3RhcnRBbmdsZSArIFRBVTtcclxuXHRcdGNsaXBBcmMoY3R4LCBhcmMpO1xyXG5cdFx0YXJjLmVuZEFuZ2xlID0gZW5kQW5nbGU7XHJcblx0XHRpZiAoYXJjLmVuZEFuZ2xlID09PSBhcmMuc3RhcnRBbmdsZSAmJiBhcmMuZnVsbENpcmNsZXMpIHtcclxuXHRcdFx0YXJjLmVuZEFuZ2xlICs9IFRBVTtcclxuXHRcdFx0YXJjLmZ1bGxDaXJjbGVzLS07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLnN0YXJ0QW5nbGUgKyBUQVUsIGFyYy5zdGFydEFuZ2xlLCB0cnVlKTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgYXJjLmZ1bGxDaXJjbGVzOyArK2kpIHtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHR9XHJcblxyXG5cdGN0eC5iZWdpblBhdGgoKTtcclxuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgdm0ub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSArIFRBVSk7XHJcblx0Zm9yIChpID0gMDsgaSA8IGFyYy5mdWxsQ2lyY2xlczsgKytpKSB7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgdm0sIGFyYykge1xyXG5cdHZhciBpbm5lciA9IHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xyXG5cclxuXHRpZiAoaW5uZXIpIHtcclxuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aCAqIDI7XHJcblx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XHJcblx0XHRjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xyXG5cdH1cclxuXHJcblx0aWYgKGFyYy5mdWxsQ2lyY2xlcykge1xyXG5cdFx0ZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgdm0sIGFyYywgaW5uZXIpO1xyXG5cdH1cclxuXHJcblx0aWYgKGlubmVyKSB7XHJcblx0XHRjbGlwQXJjKGN0eCwgYXJjKTtcclxuXHR9XHJcblxyXG5cdGN0eC5iZWdpblBhdGgoKTtcclxuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgdm0ub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuZW5kQW5nbGUpO1xyXG5cdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5lbmRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUsIHRydWUpO1xyXG5cdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRjdHguc3Ryb2tlKCk7XHJcbn1cclxuXHJcbnZhciBlbGVtZW50X2FyYyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xyXG5cdF90eXBlOiAnYXJjJyxcclxuXHJcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblxyXG5cdFx0aWYgKHZtKSB7XHJcblx0XHRcdHJldHVybiAoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5ob3ZlclJhZGl1cywgMikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cclxuXHRcdGlmICh2bSkge1xyXG5cdFx0XHR2YXIgcG9pbnRSZWxhdGl2ZVBvc2l0aW9uID0gaGVscGVycyQxLmdldEFuZ2xlRnJvbVBvaW50KHZtLCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcclxuXHRcdFx0dmFyIGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xyXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uZGlzdGFuY2U7XHJcblxyXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxyXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHZtLnN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBlbmRBbmdsZSA9IHZtLmVuZEFuZ2xlO1xyXG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XHJcblx0XHRcdFx0ZW5kQW5nbGUgKz0gVEFVO1xyXG5cdFx0XHR9XHJcblx0XHRcdHdoaWxlIChhbmdsZSA+IGVuZEFuZ2xlKSB7XHJcblx0XHRcdFx0YW5nbGUgLT0gVEFVO1xyXG5cdFx0XHR9XHJcblx0XHRcdHdoaWxlIChhbmdsZSA8IHN0YXJ0QW5nbGUpIHtcclxuXHRcdFx0XHRhbmdsZSArPSBUQVU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENoZWNrIGlmIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG9wZW4vY2xvc2UgYW5nbGVcclxuXHRcdFx0dmFyIGJldHdlZW5BbmdsZXMgPSAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSk7XHJcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xyXG5cclxuXHRcdFx0cmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XHJcblx0XHR2YXIgaGFsZlJhZGl1cyA9ICh2bS5pbm5lclJhZGl1cyArIHZtLm91dGVyUmFkaXVzKSAvIDI7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXHJcblx0XHRcdHk6IHZtLnkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRyZXR1cm4gTWF0aC5QSSAqICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSkpICogKE1hdGgucG93KHZtLm91dGVyUmFkaXVzLCAyKSAtIE1hdGgucG93KHZtLmlubmVyUmFkaXVzLCAyKSk7XHJcblx0fSxcclxuXHJcblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XHJcblx0XHR2YXIgcmFuZ2VGcm9tQ2VudHJlID0gKHZtLm91dGVyUmFkaXVzIC0gdm0uaW5uZXJSYWRpdXMpIC8gMiArIHZtLmlubmVyUmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLnggKyAoTWF0aC5jb3MoY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKSxcclxuXHRcdFx0eTogdm0ueSArIChNYXRoLnNpbihjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHR2YXIgcGl4ZWxNYXJnaW4gPSAodm0uYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XHJcblx0XHR2YXIgYXJjID0ge1xyXG5cdFx0XHR4OiB2bS54LFxyXG5cdFx0XHR5OiB2bS55LFxyXG5cdFx0XHRpbm5lclJhZGl1czogdm0uaW5uZXJSYWRpdXMsXHJcblx0XHRcdG91dGVyUmFkaXVzOiBNYXRoLm1heCh2bS5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKSxcclxuXHRcdFx0cGl4ZWxNYXJnaW46IHBpeGVsTWFyZ2luLFxyXG5cdFx0XHRzdGFydEFuZ2xlOiB2bS5zdGFydEFuZ2xlLFxyXG5cdFx0XHRlbmRBbmdsZTogdm0uZW5kQW5nbGUsXHJcblx0XHRcdGZ1bGxDaXJjbGVzOiBNYXRoLmZsb29yKHZtLmNpcmN1bWZlcmVuY2UgLyBUQVUpXHJcblx0XHR9O1xyXG5cdFx0dmFyIGk7XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHJcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XHJcblxyXG5cdFx0aWYgKGFyYy5mdWxsQ2lyY2xlcykge1xyXG5cdFx0XHRhcmMuZW5kQW5nbGUgPSBhcmMuc3RhcnRBbmdsZSArIFRBVTtcclxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRjdHguYXJjKGFyYy54LCBhcmMueSwgYXJjLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLmVuZEFuZ2xlKTtcclxuXHRcdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLmVuZEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGFyYy5mdWxsQ2lyY2xlczsgKytpKSB7XHJcblx0XHRcdFx0Y3R4LmZpbGwoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhcmMuZW5kQW5nbGUgPSBhcmMuc3RhcnRBbmdsZSArIHZtLmNpcmN1bWZlcmVuY2UgJSBUQVU7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5vdXRlclJhZGl1cywgYXJjLnN0YXJ0QW5nbGUsIGFyYy5lbmRBbmdsZSk7XHJcblx0XHRjdHguYXJjKGFyYy54LCBhcmMueSwgYXJjLmlubmVyUmFkaXVzLCBhcmMuZW5kQW5nbGUsIGFyYy5zdGFydEFuZ2xlLCB0cnVlKTtcclxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdGN0eC5maWxsKCk7XHJcblxyXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoKSB7XHJcblx0XHRcdGRyYXdCb3JkZXIoY3R4LCB2bSwgYXJjKTtcclxuXHRcdH1cclxuXHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH1cclxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxudmFyIGRlZmF1bHRDb2xvciA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRsaW5lOiB7XHJcblx0XHRcdHRlbnNpb246IDAuNCxcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IsXHJcblx0XHRcdGJvcmRlcldpZHRoOiAzLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yLFxyXG5cdFx0XHRib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxyXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcclxuXHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wLFxyXG5cdFx0XHRib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXHJcblx0XHRcdGNhcEJlemllclBvaW50czogdHJ1ZSxcclxuXHRcdFx0ZmlsbDogdHJ1ZSwgLy8gZG8gd2UgZmlsbCBpbiB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBsaW5lIGFuZCBpdHMgYmFzZSBheGlzXHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBlbGVtZW50X2xpbmUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRfdHlwZTogJ2xpbmUnLFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcclxuXHRcdHZhciBjdHggPSBtZS5fY2hhcnQuY3R4O1xyXG5cdFx0dmFyIHNwYW5HYXBzID0gdm0uc3BhbkdhcHM7XHJcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XHJcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcclxuXHRcdHZhciBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xyXG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XHJcblx0XHR2YXIgY2xvc2VQYXRoID0gbWUuX2xvb3A7XHJcblx0XHR2YXIgaW5kZXgsIHByZXZpb3VzLCBjdXJyZW50Vk07XHJcblxyXG5cdFx0aWYgKCFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWUuX2xvb3ApIHtcclxuXHRcdFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xyXG5cdFx0XHRcdHByZXZpb3VzID0gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcclxuXHRcdFx0XHQvLyBJZiB0aGUgbGluZSBoYXMgYW4gb3BlbiBwYXRoLCBzaGlmdCB0aGUgcG9pbnQgYXJyYXlcclxuXHRcdFx0XHRpZiAoIXBvaW50c1tpbmRleF0uX3ZpZXcuc2tpcCAmJiBwcmV2aW91cy5fdmlldy5za2lwKSB7XHJcblx0XHRcdFx0XHRwb2ludHMgPSBwb2ludHMuc2xpY2UoaW5kZXgpLmNvbmNhdChwb2ludHMuc2xpY2UoMCwgaW5kZXgpKTtcclxuXHRcdFx0XHRcdGNsb3NlUGF0aCA9IHNwYW5HYXBzO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIElmIHRoZSBsaW5lIGhhcyBhIGNsb3NlIHBhdGgsIGFkZCB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cclxuXHRcdFx0aWYgKGNsb3NlUGF0aCkge1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cclxuXHRcdC8vIFN0cm9rZSBMaW5lIE9wdGlvbnNcclxuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xyXG5cclxuXHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxyXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xyXG5cdFx0XHRjdHguc2V0TGluZURhc2godm0uYm9yZGVyRGFzaCB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJEYXNoT2Zmc2V0LCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaE9mZnNldCk7XHJcblx0XHRjdHgubGluZUpvaW4gPSB2bS5ib3JkZXJKb2luU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckpvaW5TdHlsZTtcclxuXHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGgpO1xyXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xyXG5cclxuXHRcdC8vIFN0cm9rZSBMaW5lXHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblxyXG5cdFx0Ly8gRmlyc3QgcG9pbnQgbW92ZXMgdG8gaXQncyBzdGFydGluZyBwb3NpdGlvbiBubyBtYXR0ZXIgd2hhdFxyXG5cdFx0Y3VycmVudFZNID0gcG9pbnRzWzBdLl92aWV3O1xyXG5cdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xyXG5cdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XHJcblx0XHRcdGxhc3REcmF3bkluZGV4ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGluZGV4ID0gMTsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XHJcblx0XHRcdGN1cnJlbnRWTSA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XHJcblx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KSA6IHBvaW50c1tsYXN0RHJhd25JbmRleF07XHJcblxyXG5cdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XHJcblx0XHRcdFx0aWYgKChsYXN0RHJhd25JbmRleCAhPT0gKGluZGV4IC0gMSkgJiYgIXNwYW5HYXBzKSB8fCBsYXN0RHJhd25JbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdC8vIFRoZXJlIHdhcyBhIGdhcCBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgcG9pbnQgYWZ0ZXIgdGhlIGdhcFxyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBMaW5lIHRvIG5leHQgcG9pbnRcclxuXHRcdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgcHJldmlvdXMuX3ZpZXcsIGN1cnJlbnRWTSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY2xvc2VQYXRoKSB7XHJcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH1cclxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQyID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxudmFyIGRlZmF1bHRDb2xvciQxID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0ZWxlbWVudHM6IHtcclxuXHRcdHBvaW50OiB7XHJcblx0XHRcdHJhZGl1czogMyxcclxuXHRcdFx0cG9pbnRTdHlsZTogJ2NpcmNsZScsXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDEsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMSxcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IDEsXHJcblx0XHRcdC8vIEhvdmVyXHJcblx0XHRcdGhpdFJhZGl1czogMSxcclxuXHRcdFx0aG92ZXJSYWRpdXM6IDQsXHJcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24geFJhbmdlKG1vdXNlWCkge1xyXG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWCAtIHZtLngpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB5UmFuZ2UobW91c2VZKSB7XHJcblx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VZIC0gdm0ueSkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XHJcbn1cclxuXHJcbnZhciBlbGVtZW50X3BvaW50ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0X3R5cGU6ICdwb2ludCcsXHJcblxyXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIHZtID8gKChNYXRoLnBvdyhtb3VzZVggLSB2bS54LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHZtLnksIDIpKSA8IE1hdGgucG93KHZtLmhpdFJhZGl1cyArIHZtLnJhZGl1cywgMikpIDogZmFsc2U7XHJcblx0fSxcclxuXHJcblx0aW5MYWJlbFJhbmdlOiB4UmFuZ2UsXHJcblx0aW5YUmFuZ2U6IHhSYW5nZSxcclxuXHRpbllSYW5nZTogeVJhbmdlLFxyXG5cclxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogdm0ueCxcclxuXHRcdFx0eTogdm0ueVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xyXG5cdH0sXHJcblxyXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0eDogdm0ueCxcclxuXHRcdFx0eTogdm0ueSxcclxuXHRcdFx0cGFkZGluZzogdm0ucmFkaXVzICsgdm0uYm9yZGVyV2lkdGhcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcclxuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcclxuXHRcdHZhciByb3RhdGlvbiA9IHZtLnJvdGF0aW9uO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHZtLnJhZGl1cztcclxuXHRcdHZhciB4ID0gdm0ueDtcclxuXHRcdHZhciB5ID0gdm0ueTtcclxuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xyXG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcclxuXHJcblx0XHRpZiAodm0uc2tpcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2xpcHBpbmcgZm9yIFBvaW50cy5cclxuXHRcdGlmIChjaGFydEFyZWEgPT09IHVuZGVmaW5lZCB8fCBoZWxwZXJzJDEuY2FudmFzLl9pc1BvaW50SW5BcmVhKHZtLCBjaGFydEFyZWEpKSB7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGRlZmF1bHRDb2xvcjtcclxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDIodm0uYm9yZGVyV2lkdGgsIGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0Q29sb3I7XHJcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuZHJhd1BvaW50KGN0eCwgcG9pbnRTdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbik7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcblxudmFyIGRlZmF1bHRDb2xvciQyID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0ZWxlbWVudHM6IHtcclxuXHRcdHJlY3RhbmdsZToge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDIsXHJcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogMFxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKHZtKSB7XHJcblx0cmV0dXJuIHZtICYmIHZtLndpZHRoICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxyXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxyXG4gKiBAcmV0dXJuIHtCb3VuZHN9IGJvdW5kcyBvZiB0aGUgYmFyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHModm0pIHtcclxuXHR2YXIgeDEsIHgyLCB5MSwgeTIsIGhhbGY7XHJcblxyXG5cdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xyXG5cdFx0aGFsZiA9IHZtLndpZHRoIC8gMjtcclxuXHRcdHgxID0gdm0ueCAtIGhhbGY7XHJcblx0XHR4MiA9IHZtLnggKyBoYWxmO1xyXG5cdFx0eTEgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcclxuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGhhbGYgPSB2bS5oZWlnaHQgLyAyO1xyXG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcclxuXHRcdHgyID0gTWF0aC5tYXgodm0ueCwgdm0uYmFzZSk7XHJcblx0XHR5MSA9IHZtLnkgLSBoYWxmO1xyXG5cdFx0eTIgPSB2bS55ICsgaGFsZjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRsZWZ0OiB4MSxcclxuXHRcdHRvcDogeTEsXHJcblx0XHRyaWdodDogeDIsXHJcblx0XHRib3R0b206IHkyXHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcclxuXHRyZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUJvcmRlclNraXBwZWQodm0pIHtcclxuXHR2YXIgZWRnZSA9IHZtLmJvcmRlclNraXBwZWQ7XHJcblx0dmFyIHJlcyA9IHt9O1xyXG5cclxuXHRpZiAoIWVkZ2UpIHtcclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cclxuXHRpZiAodm0uaG9yaXpvbnRhbCkge1xyXG5cdFx0aWYgKHZtLmJhc2UgPiB2bS54KSB7XHJcblx0XHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdsZWZ0JywgJ3JpZ2h0Jyk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh2bS5iYXNlIDwgdm0ueSkge1xyXG5cdFx0ZWRnZSA9IHN3YXAoZWRnZSwgJ2JvdHRvbScsICd0b3AnKTtcclxuXHR9XHJcblxyXG5cdHJlc1tlZGdlXSA9IHRydWU7XHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aCh2bSwgbWF4VywgbWF4SCkge1xyXG5cdHZhciB2YWx1ZSA9IHZtLmJvcmRlcldpZHRoO1xyXG5cdHZhciBza2lwID0gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKTtcclxuXHR2YXIgdCwgciwgYiwgbDtcclxuXHJcblx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XHJcblx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XHJcblx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xyXG5cdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XHJcblx0fSBlbHNlIHtcclxuXHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0OiBza2lwLnRvcCB8fCAodCA8IDApID8gMCA6IHQgPiBtYXhIID8gbWF4SCA6IHQsXHJcblx0XHRyOiBza2lwLnJpZ2h0IHx8IChyIDwgMCkgPyAwIDogciA+IG1heFcgPyBtYXhXIDogcixcclxuXHRcdGI6IHNraXAuYm90dG9tIHx8IChiIDwgMCkgPyAwIDogYiA+IG1heEggPyBtYXhIIDogYixcclxuXHRcdGw6IHNraXAubGVmdCB8fCAobCA8IDApID8gMCA6IGwgPiBtYXhXID8gbWF4VyA6IGxcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKHZtKSB7XHJcblx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh2bSk7XHJcblx0dmFyIHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XHJcblx0dmFyIGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xyXG5cdHZhciBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKHZtLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0b3V0ZXI6IHtcclxuXHRcdFx0eDogYm91bmRzLmxlZnQsXHJcblx0XHRcdHk6IGJvdW5kcy50b3AsXHJcblx0XHRcdHc6IHdpZHRoLFxyXG5cdFx0XHRoOiBoZWlnaHRcclxuXHRcdH0sXHJcblx0XHRpbm5lcjoge1xyXG5cdFx0XHR4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxyXG5cdFx0XHR5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXHJcblx0XHRcdHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcclxuXHRcdFx0aDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYlxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluUmFuZ2Uodm0sIHgsIHkpIHtcclxuXHR2YXIgc2tpcFggPSB4ID09PSBudWxsO1xyXG5cdHZhciBza2lwWSA9IHkgPT09IG51bGw7XHJcblx0dmFyIGJvdW5kcyA9ICF2bSB8fCAoc2tpcFggJiYgc2tpcFkpID8gZmFsc2UgOiBnZXRCYXJCb3VuZHModm0pO1xyXG5cclxuXHRyZXR1cm4gYm91bmRzXHJcblx0XHQmJiAoc2tpcFggfHwgeCA+PSBib3VuZHMubGVmdCAmJiB4IDw9IGJvdW5kcy5yaWdodClcclxuXHRcdCYmIChza2lwWSB8fCB5ID49IGJvdW5kcy50b3AgJiYgeSA8PSBib3VuZHMuYm90dG9tKTtcclxufVxyXG5cclxudmFyIGVsZW1lbnRfcmVjdGFuZ2xlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblx0X3R5cGU6ICdyZWN0YW5nbGUnLFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIHJlY3RzID0gYm91bmRpbmdSZWN0cyh2bSk7XHJcblx0XHR2YXIgb3V0ZXIgPSByZWN0cy5vdXRlcjtcclxuXHRcdHZhciBpbm5lciA9IHJlY3RzLmlubmVyO1xyXG5cclxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRjdHguZmlsbFJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XHJcblxyXG5cdFx0aWYgKG91dGVyLncgPT09IGlubmVyLncgJiYgb3V0ZXIuaCA9PT0gaW5uZXIuaCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGN0eC5yZWN0KG91dGVyLngsIG91dGVyLnksIG91dGVyLncsIG91dGVyLmgpO1xyXG5cdFx0Y3R4LmNsaXAoKTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcclxuXHRcdGN0eC5yZWN0KGlubmVyLngsIGlubmVyLnksIGlubmVyLncsIGlubmVyLmgpO1xyXG5cdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0fSxcclxuXHJcblx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XHJcblx0fSxcclxuXHJcblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcclxuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbW91c2VZKTtcclxuXHR9LFxyXG5cclxuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXHJcblx0XHRcdD8gaW5SYW5nZSh2bSwgbW91c2VYLCBudWxsKVxyXG5cdFx0XHQ6IGluUmFuZ2Uodm0sIG51bGwsIG1vdXNlWSk7XHJcblx0fSxcclxuXHJcblx0aW5YUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xyXG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XHJcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBudWxsLCBtb3VzZVkpO1xyXG5cdH0sXHJcblxyXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHR2YXIgeCwgeTtcclxuXHRcdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xyXG5cdFx0XHR4ID0gdm0ueDtcclxuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9ICh2bS54ICsgdm0uYmFzZSkgLyAyO1xyXG5cdFx0XHR5ID0gdm0ueTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xyXG5cdH0sXHJcblxyXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcclxuXHRcdFx0PyB2bS53aWR0aCAqIE1hdGguYWJzKHZtLnkgLSB2bS5iYXNlKVxyXG5cdFx0XHQ6IHZtLmhlaWdodCAqIE1hdGguYWJzKHZtLnggLSB2bS5iYXNlKTtcclxuXHR9LFxyXG5cclxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnlcclxuXHRcdH07XHJcblx0fVxyXG59KTtcblxudmFyIGVsZW1lbnRzID0ge307XHJcbnZhciBBcmMgPSBlbGVtZW50X2FyYztcclxudmFyIExpbmUgPSBlbGVtZW50X2xpbmU7XHJcbnZhciBQb2ludCA9IGVsZW1lbnRfcG9pbnQ7XHJcbnZhciBSZWN0YW5nbGUgPSBlbGVtZW50X3JlY3RhbmdsZTtcbmVsZW1lbnRzLkFyYyA9IEFyYztcbmVsZW1lbnRzLkxpbmUgPSBMaW5lO1xuZWxlbWVudHMuUG9pbnQgPSBQb2ludDtcbmVsZW1lbnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcblxudmFyIGRlcHJlY2F0ZWQgPSBoZWxwZXJzJDEuX2RlcHJlY2F0ZWQ7XHJcbnZhciB2YWx1ZU9yRGVmYXVsdCQzID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdiYXInLCB7XHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdsYWJlbCdcclxuXHR9LFxyXG5cclxuXHRzY2FsZXM6IHtcclxuXHRcdHhBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxyXG5cdFx0XHRvZmZzZXQ6IHRydWUsXHJcblx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHR9XSxcclxuXHJcblx0XHR5QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2xpbmVhcidcclxuXHRcdH1dXHJcblx0fVxyXG59KTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGRhdGFzZXRzOiB7XHJcblx0XHRiYXI6IHtcclxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXHJcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XHJcblx0dmFyIG1pbiA9IHNjYWxlLl9sZW5ndGg7XHJcblx0dmFyIHByZXYsIGN1cnIsIGksIGlsZW47XHJcblxyXG5cdGZvciAoaSA9IDEsIGlsZW4gPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKHBpeGVsc1tpXSAtIHBpeGVsc1tpIC0gMV0pKTtcclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS5nZXRUaWNrcygpLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0Y3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcclxuXHRcdG1pbiA9IGkgPiAwID8gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikpIDogbWluO1xyXG5cdFx0cHJldiA9IGN1cnI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWluO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcclxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcclxuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcclxuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XHJcblx0dmFyIGNvdW50ID0gcnVsZXIuc3RhY2tDb3VudDtcclxuXHR2YXIgY3VyciA9IHJ1bGVyLnBpeGVsc1tpbmRleF07XHJcblx0dmFyIG1pbiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcylcclxuXHRcdD8gY29tcHV0ZU1pblNhbXBsZVNpemUocnVsZXIuc2NhbGUsIHJ1bGVyLnBpeGVscylcclxuXHRcdDogLTE7XHJcblx0dmFyIHNpemUsIHJhdGlvO1xyXG5cclxuXHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xyXG5cdFx0c2l6ZSA9IG1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xyXG5cdFx0cmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cclxuXHRcdC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxyXG5cdFx0Ly8gYW5kIGRlcHJlY2F0ZSBiYXJQZXJjZW50YWdlIHNpbmNlIHRoaXMgdmFsdWUgaXMgaWdub3JlZCB3aGVuIHRoaWNrbmVzcyBpcyBhYnNvbHV0ZS5cclxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcclxuXHRcdHJhdGlvID0gMTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRjaHVuazogc2l6ZSAvIGNvdW50LFxyXG5cdFx0cmF0aW86IHJhdGlvLFxyXG5cdFx0c3RhcnQ6IGN1cnIgLSAoc2l6ZSAvIDIpXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXHJcbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxyXG4gKiBnZW5lcmF0ZXMgYmFycyB3aXRoIGRpZmZlcmVudCB3aWR0aHMgd2hlbiBkYXRhIGFyZSBub3QgZXZlbmx5IHNwYWNlZC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XHJcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcclxuXHR2YXIgY3VyciA9IHBpeGVsc1tpbmRleF07XHJcblx0dmFyIHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XHJcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xyXG5cdHZhciBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XHJcblx0dmFyIHN0YXJ0LCBzaXplO1xyXG5cclxuXHRpZiAocHJldiA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxyXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cclxuXHRcdHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcclxuXHR9XHJcblxyXG5cdGlmIChuZXh0ID09PSBudWxsKSB7XHJcblx0XHQvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cclxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XHJcblx0fVxyXG5cclxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xyXG5cdHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGNodW5rOiBzaXplIC8gcnVsZXIuc3RhY2tDb3VudCxcclxuXHRcdHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXHJcblx0XHRzdGFydDogc3RhcnRcclxuXHR9O1xyXG59XHJcblxyXG52YXIgY29udHJvbGxlcl9iYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblxyXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IFtcclxuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJTa2lwcGVkJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnYmFyUGVyY2VudGFnZScsXHJcblx0XHQnYmFyVGhpY2tuZXNzJyxcclxuXHRcdCdjYXRlZ29yeVBlcmNlbnRhZ2UnLFxyXG5cdFx0J21heEJhclRoaWNrbmVzcycsXHJcblx0XHQnbWluQmFyTGVuZ3RoJ1xyXG5cdF0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhLCBzY2FsZU9wdHM7XHJcblxyXG5cdFx0Y29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0bWV0YS5zdGFjayA9IG1lLmdldERhdGFzZXQoKS5zdGFjaztcclxuXHRcdG1ldGEuYmFyID0gdHJ1ZTtcclxuXHJcblx0XHRzY2FsZU9wdHMgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpLm9wdGlvbnM7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBzY2FsZU9wdHMuYmFyUGVyY2VudGFnZSwgJ3NjYWxlcy5beC95XUF4ZXMuYmFyUGVyY2VudGFnZScsICdkYXRhc2V0LmJhclBlcmNlbnRhZ2UnKTtcclxuXHRcdGRlcHJlY2F0ZWQoJ2JhciBjaGFydCcsIHNjYWxlT3B0cy5iYXJUaGlja25lc3MsICdzY2FsZXMuW3gveV1BeGVzLmJhclRoaWNrbmVzcycsICdkYXRhc2V0LmJhclRoaWNrbmVzcycpO1xyXG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmNhdGVnb3J5UGVyY2VudGFnZSwgJ3NjYWxlcy5beC95XUF4ZXMuY2F0ZWdvcnlQZXJjZW50YWdlJywgJ2RhdGFzZXQuY2F0ZWdvcnlQZXJjZW50YWdlJyk7XHJcblx0XHRkZXByZWNhdGVkKCdiYXIgY2hhcnQnLCBtZS5fZ2V0VmFsdWVTY2FsZSgpLm9wdGlvbnMubWluQmFyTGVuZ3RoLCAnc2NhbGVzLlt4L3ldQXhlcy5taW5CYXJMZW5ndGgnLCAnZGF0YXNldC5taW5CYXJMZW5ndGgnKTtcclxuXHRcdGRlcHJlY2F0ZWQoJ2JhciBjaGFydCcsIHNjYWxlT3B0cy5tYXhCYXJUaGlja25lc3MsICdzY2FsZXMuW3gveV1BeGVzLm1heEJhclRoaWNrbmVzcycsICdkYXRhc2V0Lm1heEJhclRoaWNrbmVzcycpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHJlY3RzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhyZWN0YW5nbGUsIGluZGV4KTtcclxuXHJcblx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcclxuXHRcdHJlY3RhbmdsZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xyXG5cdFx0cmVjdGFuZ2xlLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcclxuXHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcclxuXHRcdHJlY3RhbmdsZS5fbW9kZWwgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJTa2lwcGVkOiBvcHRpb25zLmJvcmRlclNraXBwZWQsXHJcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXHJcblx0XHRcdGxhYmVsOiBtZS5jaGFydC5kYXRhLmxhYmVsc1tpbmRleF1cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFzZXQuZGF0YVtpbmRleF0pKSB7XHJcblx0XHRcdHJlY3RhbmdsZS5fbW9kZWwuYm9yZGVyU2tpcHBlZCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeShyZWN0YW5nbGUsIGluZGV4LCByZXNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XHJcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcclxuXHRcdHZhciBiYXNlID0gdnNjYWxlLmdldEJhc2VQaXhlbCgpO1xyXG5cdFx0dmFyIGhvcml6b250YWwgPSB2c2NhbGUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcclxuXHRcdHZhciB2cGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMobWUuaW5kZXgsIGluZGV4LCBvcHRpb25zKTtcclxuXHRcdHZhciBpcGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMobWUuaW5kZXgsIGluZGV4LCBydWxlciwgb3B0aW9ucyk7XHJcblxyXG5cdFx0bW9kZWwuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XHJcblx0XHRtb2RlbC5iYXNlID0gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5iYXNlO1xyXG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcclxuXHRcdG1vZGVsLnkgPSBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQ7XHJcblx0XHRtb2RlbC5oZWlnaHQgPSBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogdW5kZWZpbmVkO1xyXG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldEluZGV4U2NhbGUoKTtcclxuXHRcdHZhciBtZXRhc2V0cyA9IHNjYWxlLl9nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhtZS5fdHlwZSk7XHJcblx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcclxuXHRcdHZhciBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xyXG5cdFx0dmFyIHN0YWNrcyA9IFtdO1xyXG5cdFx0dmFyIGksIG1ldGE7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZXRhID0gbWV0YXNldHNbaV07XHJcblx0XHRcdC8vIHN0YWNrZWQgICB8IG1ldGEuc3RhY2tcclxuXHRcdFx0Ly8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcclxuXHRcdFx0Ly8gZmFsc2UgICAgIHwgICB4ICAgfCAgICAgeCAgICAgfCAgICAgeFxyXG5cdFx0XHQvLyB0cnVlICAgICAgfCAgICAgICB8ICAgICB4ICAgICB8XHJcblx0XHRcdC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcclxuXHRcdFx0aWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxyXG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xyXG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3RhY2tzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRTdGFja3MoKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdGFjayBpbmRleFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0U3RhY2tJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBuYW1lKSB7XHJcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCk7XHJcblx0XHR2YXIgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHQ/IHN0YWNrcy5pbmRleE9mKG5hbWUpXHJcblx0XHRcdDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XHJcblxyXG5cdFx0cmV0dXJuIChpbmRleCA9PT0gLTEpXHJcblx0XHRcdD8gc3RhY2tzLmxlbmd0aCAtIDFcclxuXHRcdFx0OiBpbmRleDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFJ1bGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xyXG5cdFx0dmFyIHBpeGVscyA9IFtdO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRwaXhlbHMucHVzaChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKG51bGwsIGksIG1lLmluZGV4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0cGl4ZWxzOiBwaXhlbHMsXHJcblx0XHRcdHN0YXJ0OiBzY2FsZS5fc3RhcnRQaXhlbCxcclxuXHRcdFx0ZW5kOiBzY2FsZS5fZW5kUGl4ZWwsXHJcblx0XHRcdHN0YWNrQ291bnQ6IG1lLmdldFN0YWNrQ291bnQoKSxcclxuXHRcdFx0c2NhbGU6IHNjYWxlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVCYXJWYWx1ZVBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgbWV0YXNldHMgPSBzY2FsZS5fZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMobWUuX3R5cGUpO1xyXG5cdFx0dmFyIHZhbHVlID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XHJcblx0XHR2YXIgbWluQmFyTGVuZ3RoID0gb3B0aW9ucy5taW5CYXJMZW5ndGg7XHJcblx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcclxuXHRcdHZhciBzdGFjayA9IG1lLmdldE1ldGEoKS5zdGFjaztcclxuXHRcdHZhciBzdGFydCA9IHZhbHVlLnN0YXJ0ID09PSB1bmRlZmluZWQgPyAwIDogdmFsdWUubWF4ID49IDAgJiYgdmFsdWUubWluID49IDAgPyB2YWx1ZS5taW4gOiB2YWx1ZS5tYXg7XHJcblx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuc3RhcnQgPT09IHVuZGVmaW5lZCA/IHZhbHVlLmVuZCA6IHZhbHVlLm1heCA+PSAwICYmIHZhbHVlLm1pbiA+PSAwID8gdmFsdWUubWF4IC0gdmFsdWUubWluIDogdmFsdWUubWluIC0gdmFsdWUubWF4O1xyXG5cdFx0dmFyIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XHJcblx0XHR2YXIgaSwgaW1ldGEsIGl2YWx1ZSwgYmFzZSwgaGVhZCwgc2l6ZSwgc3RhY2tMZW5ndGg7XHJcblxyXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0aW1ldGEgPSBtZXRhc2V0c1tpXTtcclxuXHJcblx0XHRcdFx0aWYgKGltZXRhLmluZGV4ID09PSBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGltZXRhLnN0YWNrID09PSBzdGFjaykge1xyXG5cdFx0XHRcdFx0c3RhY2tMZW5ndGggPSBzY2FsZS5fcGFyc2VWYWx1ZShkYXRhc2V0c1tpbWV0YS5pbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdFx0XHRcdFx0aXZhbHVlID0gc3RhY2tMZW5ndGguc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YWNrTGVuZ3RoLmVuZCA6IHN0YWNrTGVuZ3RoLm1pbiA+PSAwICYmIHN0YWNrTGVuZ3RoLm1heCA+PSAwID8gc3RhY2tMZW5ndGgubWF4IDogc3RhY2tMZW5ndGgubWluO1xyXG5cclxuXHRcdFx0XHRcdGlmICgodmFsdWUubWluIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUubWF4ID49IDAgJiYgaXZhbHVlID4gMCkpIHtcclxuXHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcclxuXHRcdGhlYWQgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcclxuXHRcdHNpemUgPSBoZWFkIC0gYmFzZTtcclxuXHJcblx0XHRpZiAobWluQmFyTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcclxuXHRcdFx0c2l6ZSA9IG1pbkJhckxlbmd0aDtcclxuXHRcdFx0aWYgKGxlbmd0aCA+PSAwICYmICFpc0hvcml6b250YWwgfHwgbGVuZ3RoIDwgMCAmJiBpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHRoZWFkID0gYmFzZSAtIG1pbkJhckxlbmd0aDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRoZWFkID0gYmFzZSArIG1pbkJhckxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHNpemU6IHNpemUsXHJcblx0XHRcdGJhc2U6IGJhc2UsXHJcblx0XHRcdGhlYWQ6IGhlYWQsXHJcblx0XHRcdGNlbnRlcjogaGVhZCArIHNpemUgLyAyXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xyXG5cdFx0XHQ/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKVxyXG5cdFx0XHQ6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBzdGFja0luZGV4ID0gbWUuZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG1lLmdldE1ldGEoKS5zdGFjayk7XHJcblx0XHR2YXIgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xyXG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcclxuXHRcdFx0dmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpLFxyXG5cdFx0XHRyYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcclxuXHRcdFx0aGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHRzaXplOiBzaXplXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcclxuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgaWxlbiA9IHJlY3RzLmxlbmd0aDtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcclxuXHJcblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR2YXIgdmFsID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldC5kYXRhW2ldKTtcclxuXHRcdFx0aWYgKCFpc05hTih2YWwubWluKSAmJiAhaXNOYU4odmFsLm1heCkpIHtcclxuXHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdmFsdWVzID0gaGVscGVycyQxLmV4dGVuZCh7fSwgY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cykpO1xyXG5cdFx0dmFyIGluZGV4T3B0cyA9IG1lLl9nZXRJbmRleFNjYWxlKCkub3B0aW9ucztcclxuXHRcdHZhciB2YWx1ZU9wdHMgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpLm9wdGlvbnM7XHJcblxyXG5cdFx0dmFsdWVzLmJhclBlcmNlbnRhZ2UgPSB2YWx1ZU9yRGVmYXVsdCQzKGluZGV4T3B0cy5iYXJQZXJjZW50YWdlLCB2YWx1ZXMuYmFyUGVyY2VudGFnZSk7XHJcblx0XHR2YWx1ZXMuYmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQkMyhpbmRleE9wdHMuYmFyVGhpY2tuZXNzLCB2YWx1ZXMuYmFyVGhpY2tuZXNzKTtcclxuXHRcdHZhbHVlcy5jYXRlZ29yeVBlcmNlbnRhZ2UgPSB2YWx1ZU9yRGVmYXVsdCQzKGluZGV4T3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UsIHZhbHVlcy5jYXRlZ29yeVBlcmNlbnRhZ2UpO1xyXG5cdFx0dmFsdWVzLm1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLm1heEJhclRoaWNrbmVzcywgdmFsdWVzLm1heEJhclRoaWNrbmVzcyk7XHJcblx0XHR2YWx1ZXMubWluQmFyTGVuZ3RoID0gdmFsdWVPckRlZmF1bHQkMyh2YWx1ZU9wdHMubWluQmFyTGVuZ3RoLCB2YWx1ZXMubWluQmFyTGVuZ3RoKTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHJlc29sdmUkMSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2J1YmJsZScsIHtcclxuXHRob3Zlcjoge1xyXG5cdFx0bW9kZTogJ3NpbmdsZSdcclxuXHR9LFxyXG5cclxuXHRzY2FsZXM6IHtcclxuXHRcdHhBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnbGluZWFyJywgLy8gYnViYmxlIHNob3VsZCBwcm9iYWJseSB1c2UgYSBsaW5lYXIgc2NhbGUgYnkgZGVmYXVsdFxyXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXHJcblx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcclxuXHRcdH1dLFxyXG5cdFx0eUF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xyXG5cdFx0fV1cclxuXHR9LFxyXG5cclxuXHR0b29sdGlwczoge1xyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XHJcblx0XHRcdFx0dmFyIGRhdGFzZXRMYWJlbCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xyXG5cdFx0XHRcdHZhciBkYXRhUG9pbnQgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5kYXRhW2l0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBjb250cm9sbGVyX2J1YmJsZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICovXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyV2lkdGgnLFxyXG5cdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcclxuXHRcdCdob3ZlclJhZGl1cycsXHJcblx0XHQnaGl0UmFkaXVzJyxcclxuXHRcdCdwb2ludFN0eWxlJyxcclxuXHRcdCdyb3RhdGlvbidcclxuXHRdLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICovXHJcblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcclxuXHJcblx0XHQvLyBVcGRhdGUgUG9pbnRzXHJcblx0XHRoZWxwZXJzJDEuZWFjaChwb2ludHMsIGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpbmRleCwgcmVzZXQpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xyXG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcclxuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGFbaW5kZXhdO1xyXG5cdFx0dmFyIGRzSW5kZXggPSBtZS5pbmRleDtcclxuXHJcblx0XHR2YXIgeCA9IHJlc2V0ID8geFNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogeFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YSA6IE5hTiwgaW5kZXgsIGRzSW5kZXgpO1xyXG5cdFx0dmFyIHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGRhdGEsIGluZGV4LCBkc0luZGV4KTtcclxuXHJcblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xyXG5cdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcclxuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkc0luZGV4O1xyXG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XHJcblx0XHRwb2ludC5fbW9kZWwgPSB7XHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1cyxcclxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxyXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcclxuXHRcdFx0cmFkaXVzOiByZXNldCA/IDAgOiBvcHRpb25zLnJhZGl1cyxcclxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXHJcblx0XHRcdHg6IHgsXHJcblx0XHRcdHk6IHksXHJcblx0XHR9O1xyXG5cclxuXHRcdHBvaW50LnBpdm90KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0XHRtb2RlbC5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaG92ZXJSYWRpdXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgZGF0YSA9IGRhdGFzZXQuZGF0YVtpbmRleF0gfHwge307XHJcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY29udGV4dCA9IHtcclxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxyXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxyXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEluIGNhc2UgdmFsdWVzIHdlcmUgY2FjaGVkIChhbmQgdGh1cyBmcm96ZW4pLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB2YWx1ZXNcclxuXHRcdGlmIChtZS5fY2FjaGVkRGF0YU9wdHMgPT09IHZhbHVlcykge1xyXG5cdFx0XHR2YWx1ZXMgPSBoZWxwZXJzJDEuZXh0ZW5kKHt9LCB2YWx1ZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxyXG5cdFx0dmFsdWVzLnJhZGl1cyA9IHJlc29sdmUkMShbXHJcblx0XHRcdGN1c3RvbS5yYWRpdXMsXHJcblx0XHRcdGRhdGEucixcclxuXHRcdFx0bWUuX2NvbmZpZy5yYWRpdXMsXHJcblx0XHRcdGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQucmFkaXVzXHJcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbnZhciBQSSQxID0gTWF0aC5QSTtcclxudmFyIERPVUJMRV9QSSQxID0gUEkkMSAqIDI7XHJcbnZhciBIQUxGX1BJJDEgPSBQSSQxIC8gMjtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZG91Z2hudXQnLCB7XHJcblx0YW5pbWF0aW9uOiB7XHJcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcclxuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXHJcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxyXG5cdFx0YW5pbWF0ZVNjYWxlOiBmYWxzZVxyXG5cdH0sXHJcblx0aG92ZXI6IHtcclxuXHRcdG1vZGU6ICdzaW5nbGUnXHJcblx0fSxcclxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcclxuXHJcblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XHJcblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGxpc3RJdGVtID0gbGlzdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpKTtcclxuXHRcdFx0XHRsaXN0SXRlbVNwYW4gPSBsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xyXG5cdFx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV07XHJcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xyXG5cdFx0XHRcdFx0bGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWxzW2ldKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Qub3V0ZXJIVE1MO1xyXG5cdH0sXHJcblx0bGVnZW5kOiB7XHJcblx0XHRsYWJlbHM6IHtcclxuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcclxuXHRcdFx0XHRcdFx0dmFyIHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcclxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRhdGEuZGF0YXNldHNbMF0uZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gW107XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xyXG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xyXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcclxuXHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRcdC8vIHRvZ2dsZSB2aXNpYmlsaXR5IG9mIGluZGV4IGlmIGV4aXN0c1xyXG5cdFx0XHRcdGlmIChtZXRhLmRhdGFbaW5kZXhdKSB7XHJcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cclxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcclxuXHJcblx0Ly8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cclxuXHRyb3RhdGlvbjogLUhBTEZfUEkkMSxcclxuXHJcblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxyXG5cdGNpcmN1bWZlcmVuY2U6IERPVUJMRV9QSSQxLFxyXG5cclxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcclxuXHR0b29sdGlwczoge1xyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xyXG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gJzogJyArIGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcclxuXHJcblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFMYWJlbCkpIHtcclxuXHRcdFx0XHRcdC8vIHNob3cgdmFsdWUgb24gZmlyc3QgbGluZSBvZiBtdWx0aWxpbmUgbGFiZWxcclxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2xvbmUgYmVjYXVzZSB3ZSBhcmUgY2hhbmdpbmcgdGhlIHZhbHVlXHJcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcclxuXHRcdFx0XHRcdGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29udHJvbGxlcl9kb3VnaG51dCA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHJcblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXHJcblxyXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IFtcclxuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2JvcmRlckNvbG9yJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnYm9yZGVyQWxpZ24nLFxyXG5cdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcclxuXHRdLFxyXG5cclxuXHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxyXG5cdGdldFJpbmdJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgcmluZ0luZGV4ID0gMDtcclxuXHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFzZXRJbmRleDsgKytqKSB7XHJcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaikpIHtcclxuXHRcdFx0XHQrK3JpbmdJbmRleDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByaW5nSW5kZXg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciByYXRpb1ggPSAxO1xyXG5cdFx0dmFyIHJhdGlvWSA9IDE7XHJcblx0XHR2YXIgb2Zmc2V0WCA9IDA7XHJcblx0XHR2YXIgb2Zmc2V0WSA9IDA7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xyXG5cdFx0dmFyIGN1dG91dCA9IG9wdHMuY3V0b3V0UGVyY2VudGFnZSAvIDEwMCB8fCAwO1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XHJcblx0XHR2YXIgY2hhcnRXZWlnaHQgPSBtZS5fZ2V0UmluZ1dlaWdodChtZS5pbmRleCk7XHJcblx0XHR2YXIgbWF4V2lkdGgsIG1heEhlaWdodCwgaSwgaWxlbjtcclxuXHJcblx0XHQvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXHJcblx0XHRpZiAoY2lyY3VtZmVyZW5jZSA8IERPVUJMRV9QSSQxKSB7XHJcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbiAlIERPVUJMRV9QSSQxO1xyXG5cdFx0XHRzdGFydEFuZ2xlICs9IHN0YXJ0QW5nbGUgPj0gUEkkMSA/IC1ET1VCTEVfUEkkMSA6IHN0YXJ0QW5nbGUgPCAtUEkkMSA/IERPVUJMRV9QSSQxIDogMDtcclxuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XHJcblx0XHRcdHZhciBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcclxuXHRcdFx0dmFyIHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xyXG5cdFx0XHR2YXIgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcclxuXHRcdFx0dmFyIGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XHJcblx0XHRcdHZhciBjb250YWluczAgPSAoc3RhcnRBbmdsZSA8PSAwICYmIGVuZEFuZ2xlID49IDApIHx8IGVuZEFuZ2xlID49IERPVUJMRV9QSSQxO1xyXG5cdFx0XHR2YXIgY29udGFpbnM5MCA9IChzdGFydEFuZ2xlIDw9IEhBTEZfUEkkMSAmJiBlbmRBbmdsZSA+PSBIQUxGX1BJJDEpIHx8IGVuZEFuZ2xlID49IERPVUJMRV9QSSQxICsgSEFMRl9QSSQxO1xyXG5cdFx0XHR2YXIgY29udGFpbnMxODAgPSBzdGFydEFuZ2xlID09PSAtUEkkMSB8fCBlbmRBbmdsZSA+PSBQSSQxO1xyXG5cdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtSEFMRl9QSSQxICYmIGVuZEFuZ2xlID49IC1IQUxGX1BJJDEpIHx8IGVuZEFuZ2xlID49IFBJJDEgKyBIQUxGX1BJJDE7XHJcblx0XHRcdHZhciBtaW5YID0gY29udGFpbnMxODAgPyAtMSA6IE1hdGgubWluKHN0YXJ0WCwgc3RhcnRYICogY3V0b3V0LCBlbmRYLCBlbmRYICogY3V0b3V0KTtcclxuXHRcdFx0dmFyIG1pblkgPSBjb250YWluczI3MCA/IC0xIDogTWF0aC5taW4oc3RhcnRZLCBzdGFydFkgKiBjdXRvdXQsIGVuZFksIGVuZFkgKiBjdXRvdXQpO1xyXG5cdFx0XHR2YXIgbWF4WCA9IGNvbnRhaW5zMCA/IDEgOiBNYXRoLm1heChzdGFydFgsIHN0YXJ0WCAqIGN1dG91dCwgZW5kWCwgZW5kWCAqIGN1dG91dCk7XHJcblx0XHRcdHZhciBtYXhZID0gY29udGFpbnM5MCA/IDEgOiBNYXRoLm1heChzdGFydFksIHN0YXJ0WSAqIGN1dG91dCwgZW5kWSwgZW5kWSAqIGN1dG91dCk7XHJcblx0XHRcdHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xyXG5cdFx0XHRyYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcclxuXHRcdFx0b2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcclxuXHRcdFx0b2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKTtcclxuXHRcdG1heFdpZHRoID0gKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0IC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gcmF0aW9YO1xyXG5cdFx0bWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gcmF0aW9ZO1xyXG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xyXG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjaGFydC5vdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XHJcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyAobWUuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB8fCAxKTtcclxuXHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXRYICogY2hhcnQub3V0ZXJSYWRpdXM7XHJcblx0XHRjaGFydC5vZmZzZXRZID0gb2Zmc2V0WSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xyXG5cclxuXHRcdG1ldGEudG90YWwgPSBtZS5jYWxjdWxhdGVUb3RhbCgpO1xyXG5cclxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5fZ2V0UmluZ1dlaWdodE9mZnNldChtZS5pbmRleCk7XHJcblx0XHRtZS5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyY3NbaV0sIGksIHJlc2V0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XHJcblx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xyXG5cdFx0dmFyIGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcclxuXHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxyXG5cdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IDAgOiBhcmMuaGlkZGVuID8gMCA6IG1lLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UoZGF0YXNldC5kYXRhW2luZGV4XSkgKiAob3B0cy5jaXJjdW1mZXJlbmNlIC8gRE9VQkxFX1BJJDEpO1xyXG5cdFx0dmFyIGlubmVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUuaW5uZXJSYWRpdXM7XHJcblx0XHR2YXIgb3V0ZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5vdXRlclJhZGl1cztcclxuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XHJcblx0XHRcdC8vIFV0aWxpdHlcclxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdF9pbmRleDogaW5kZXgsXHJcblxyXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0XHRfbW9kZWw6IHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxyXG5cdFx0XHRcdHg6IGNlbnRlclggKyBjaGFydC5vZmZzZXRYLFxyXG5cdFx0XHRcdHk6IGNlbnRlclkgKyBjaGFydC5vZmZzZXRZLFxyXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXHJcblx0XHRcdFx0ZW5kQW5nbGU6IGVuZEFuZ2xlLFxyXG5cdFx0XHRcdGNpcmN1bWZlcmVuY2U6IGNpcmN1bWZlcmVuY2UsXHJcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG5cdFx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmxhYmVsLCBpbmRleCwgY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdKVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xyXG5cclxuXHRcdC8vIFNldCBjb3JyZWN0IGFuZ2xlcyBpZiBub3QgcmVzZXR0aW5nXHJcblx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcclxuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XHJcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG1lLmdldE1ldGEoKS5kYXRhW2luZGV4IC0gMV0uX21vZGVsLmVuZEFuZ2xlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtb2RlbC5lbmRBbmdsZSA9IG1vZGVsLnN0YXJ0QW5nbGUgKyBtb2RlbC5jaXJjdW1mZXJlbmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFyYy5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdGNhbGN1bGF0ZVRvdGFsOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIHRvdGFsID0gMDtcclxuXHRcdHZhciB2YWx1ZTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcblx0XHRcdHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcclxuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XHJcblx0XHRcdFx0dG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvKiBpZiAodG90YWwgPT09IDApIHtcclxuXHRcdFx0dG90YWwgPSBOYU47XHJcblx0XHR9Ki9cclxuXHJcblx0XHRyZXR1cm4gdG90YWw7XHJcblx0fSxcclxuXHJcblx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHZhciB0b3RhbCA9IHRoaXMuZ2V0TWV0YSgpLnRvdGFsO1xyXG5cdFx0aWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBET1VCTEVfUEkkMSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9LFxyXG5cclxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcclxuXHRnZXRNYXhCb3JkZXJXaWR0aDogZnVuY3Rpb24oYXJjcykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtYXggPSAwO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgaSwgaWxlbiwgbWV0YSwgYXJjLCBjb250cm9sbGVyLCBvcHRpb25zLCBib3JkZXJXaWR0aCwgaG92ZXJXaWR0aDtcclxuXHJcblx0XHRpZiAoIWFyY3MpIHtcclxuXHRcdFx0Ly8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XHJcblx0XHRcdFx0XHRpZiAoaSAhPT0gbWUuaW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0Y29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYXJjcykge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0YXJjID0gYXJjc1tpXTtcclxuXHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcclxuXHRcdFx0XHRjb250cm9sbGVyLl9jb25maWd1cmUoKTtcclxuXHRcdFx0XHRvcHRpb25zID0gY29udHJvbGxlci5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmMsIGkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcclxuXHRcdFx0XHRib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XHJcblx0XHRcdFx0aG92ZXJXaWR0aCA9IG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aDtcclxuXHJcblx0XHRcdFx0bWF4ID0gYm9yZGVyV2lkdGggPiBtYXggPyBib3JkZXJXaWR0aCA6IG1heDtcclxuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1heDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICovXHJcblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XHJcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XHJcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xyXG5cclxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFJpbmdXZWlnaHRPZmZzZXQ6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcclxuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xyXG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFJpbmdXZWlnaHQ6IGZ1bmN0aW9uKGRhdGFTZXRJbmRleCkge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0JDUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFTZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpO1xyXG5cdH1cclxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcclxuXHRob3Zlcjoge1xyXG5cdFx0bW9kZTogJ2luZGV4JyxcclxuXHRcdGF4aXM6ICd5J1xyXG5cdH0sXHJcblxyXG5cdHNjYWxlczoge1xyXG5cdFx0eEF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcclxuXHRcdH1dLFxyXG5cclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxyXG5cdFx0XHRvZmZzZXQ6IHRydWUsXHJcblx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHR9XVxyXG5cdH0sXHJcblxyXG5cdGVsZW1lbnRzOiB7XHJcblx0XHRyZWN0YW5nbGU6IHtcclxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogJ2xlZnQnXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdG1vZGU6ICdpbmRleCcsXHJcblx0XHRheGlzOiAneSdcclxuXHR9XHJcbn0pO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0ZGF0YXNldHM6IHtcclxuXHRcdGhvcml6b250YWxCYXI6IHtcclxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXHJcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgY29udHJvbGxlcl9ob3Jpem9udGFsQmFyID0gY29udHJvbGxlcl9iYXIuZXh0ZW5kKHtcclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xyXG5cdH1cclxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG52YXIgcmVzb2x2ZSQyID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcclxudmFyIGlzUG9pbnRJbkFyZWEgPSBoZWxwZXJzJDEuY2FudmFzLl9pc1BvaW50SW5BcmVhO1xyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdsaW5lJywge1xyXG5cdHNob3dMaW5lczogdHJ1ZSxcclxuXHRzcGFuR2FwczogZmFsc2UsXHJcblxyXG5cdGhvdmVyOiB7XHJcblx0XHRtb2RlOiAnbGFiZWwnXHJcblx0fSxcclxuXHJcblx0c2NhbGVzOiB7XHJcblx0XHR4QXhlczogW3tcclxuXHRcdFx0dHlwZTogJ2NhdGVnb3J5JyxcclxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcclxuXHRcdH1dLFxyXG5cdFx0eUF4ZXM6IFt7XHJcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xyXG5cdFx0fV1cclxuXHR9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpIHtcclxuXHR2YXIgdGlja09wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnRpY2tzIHx8IHt9O1xyXG5cdHZhciByZXZlcnNlID0gdGlja09wdHMucmV2ZXJzZTtcclxuXHR2YXIgbWluID0gdGlja09wdHMubWluID09PSB1bmRlZmluZWQgPyBoYWxmQm9yZGVyV2lkdGggOiAwO1xyXG5cdHZhciBtYXggPSB0aWNrT3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGhhbGZCb3JkZXJXaWR0aCA6IDA7XHJcblx0cmV0dXJuIHtcclxuXHRcdHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxyXG5cdFx0ZW5kOiByZXZlcnNlID8gbWluIDogbWF4XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGJvcmRlcldpZHRoKSB7XHJcblx0dmFyIGhhbGZCb3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcclxuXHR2YXIgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGhhbGZCb3JkZXJXaWR0aCk7XHJcblx0dmFyIHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dG9wOiB5LmVuZCxcclxuXHRcdHJpZ2h0OiB4LmVuZCxcclxuXHRcdGJvdHRvbTogeS5zdGFydCxcclxuXHRcdGxlZnQ6IHguc3RhcnRcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcclxuXHR2YXIgdCwgciwgYiwgbDtcclxuXHJcblx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdHQgPSB2YWx1ZS50b3A7XHJcblx0XHRyID0gdmFsdWUucmlnaHQ7XHJcblx0XHRiID0gdmFsdWUuYm90dG9tO1xyXG5cdFx0bCA9IHZhbHVlLmxlZnQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0b3A6IHQsXHJcblx0XHRyaWdodDogcixcclxuXHRcdGJvdHRvbTogYixcclxuXHRcdGxlZnQ6IGxcclxuXHR9O1xyXG59XHJcblxyXG5cclxudmFyIGNvbnRyb2xsZXJfbGluZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHJcblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxyXG5cclxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhc2V0RWxlbWVudE9wdGlvbnM6IFtcclxuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2JvcmRlckNhcFN0eWxlJyxcclxuXHRcdCdib3JkZXJDb2xvcicsXHJcblx0XHQnYm9yZGVyRGFzaCcsXHJcblx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXHJcblx0XHQnYm9yZGVySm9pblN0eWxlJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnY3ViaWNJbnRlcnBvbGF0aW9uTW9kZScsXHJcblx0XHQnZmlsbCdcclxuXHRdLFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IHtcclxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcclxuXHRcdGJvcmRlckNvbG9yOiAncG9pbnRCb3JkZXJDb2xvcicsXHJcblx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxyXG5cdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxyXG5cdFx0aG92ZXJCYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yJyxcclxuXHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxyXG5cdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXHJcblx0XHRob3ZlclJhZGl1czogJ3BvaW50SG92ZXJSYWRpdXMnLFxyXG5cdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxyXG5cdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxyXG5cdFx0cm90YXRpb246ICdwb2ludFJvdGF0aW9uJ1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xyXG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xyXG5cdFx0dmFyIHNob3dMaW5lID0gbWUuX3Nob3dMaW5lID0gdmFsdWVPckRlZmF1bHQkNihjb25maWcuc2hvd0xpbmUsIG9wdGlvbnMuc2hvd0xpbmVzKTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdG1lLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XHJcblx0XHRtZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaW5lXHJcblx0XHRpZiAoc2hvd0xpbmUpIHtcclxuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xyXG5cdFx0XHRpZiAoY29uZmlnLnRlbnNpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbmZpZy5saW5lVGVuc2lvbiA9IGNvbmZpZy50ZW5zaW9uO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVdGlsaXR5XHJcblx0XHRcdGxpbmUuX3NjYWxlID0gbWUuX3lTY2FsZTtcclxuXHRcdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHRcdC8vIERhdGFcclxuXHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XHJcblx0XHRcdC8vIE1vZGVsXHJcblx0XHRcdGxpbmUuX21vZGVsID0gbWUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobGluZSk7XHJcblxyXG5cdFx0XHRsaW5lLnBpdm90KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludHNbaV0sIGksIHJlc2V0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2hvd0xpbmUgJiYgbGluZS5fbW9kZWwudGVuc2lvbiAhPT0gMCkge1xyXG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRwb2ludHNbaV0ucGl2b3QoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xyXG5cdFx0dmFyIHhTY2FsZSA9IG1lLl94U2NhbGU7XHJcblx0XHR2YXIgeVNjYWxlID0gbWUuX3lTY2FsZTtcclxuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xyXG5cdFx0dmFyIHgsIHk7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xyXG5cclxuXHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xyXG5cdFx0eSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogbWUuY2FsY3VsYXRlUG9pbnRZKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KTtcclxuXHJcblx0XHQvLyBVdGlsaXR5XHJcblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xyXG5cdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcclxuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkYXRhc2V0SW5kZXg7XHJcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcclxuXHJcblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0cG9pbnQuX21vZGVsID0ge1xyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5LFxyXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcclxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxyXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxyXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXHJcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDYoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXHJcblx0XHRcdHN0ZXBwZWRMaW5lOiBsaW5lTW9kZWwgPyBsaW5lTW9kZWwuc3RlcHBlZExpbmUgOiBmYWxzZSxcclxuXHRcdFx0Ly8gVG9vbHRpcFxyXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcclxuXHRcdHZhciBvcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciBsaW5lT3B0aW9ucyA9IG9wdGlvbnMuZWxlbWVudHMubGluZTtcclxuXHRcdHZhciB2YWx1ZXMgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciBvZiBsaW5lcyBpcyB0byBicmVhayBhdCBudWxsIHZhbHVlcywgYWNjb3JkaW5nXHJcblx0XHQvLyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQzNSNpc3N1ZWNvbW1lbnQtMjE2NzE4MTU4XHJcblx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcclxuXHRcdHZhbHVlcy5zcGFuR2FwcyA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLnNwYW5HYXBzLCBvcHRpb25zLnNwYW5HYXBzKTtcclxuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNihjb25maWcubGluZVRlbnNpb24sIGxpbmVPcHRpb25zLnRlbnNpb24pO1xyXG5cdFx0dmFsdWVzLnN0ZXBwZWRMaW5lID0gcmVzb2x2ZSQyKFtjdXN0b20uc3RlcHBlZExpbmUsIGNvbmZpZy5zdGVwcGVkTGluZSwgbGluZU9wdGlvbnMuc3RlcHBlZF0pO1xyXG5cdFx0dmFsdWVzLmNsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQkNihjb25maWcuY2xpcCwgZGVmYXVsdENsaXAobWUuX3hTY2FsZSwgbWUuX3lTY2FsZSwgdmFsdWVzLmJvcmRlcldpZHRoKSkpO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fSxcclxuXHJcblx0Y2FsY3VsYXRlUG9pbnRZOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIHlTY2FsZSA9IG1lLl95U2NhbGU7XHJcblx0XHR2YXIgc3VtUG9zID0gMDtcclxuXHRcdHZhciBzdW1OZWcgPSAwO1xyXG5cdFx0dmFyIGksIGRzLCBkc01ldGEsIHN0YWNrZWRSaWdodFZhbHVlLCByaWdodFZhbHVlLCBtZXRhc2V0cywgaWxlbjtcclxuXHJcblx0XHRpZiAoeVNjYWxlLm9wdGlvbnMuc3RhY2tlZCkge1xyXG5cdFx0XHRyaWdodFZhbHVlID0gK3lTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcclxuXHRcdFx0bWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xyXG5cdFx0XHRpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGRzTWV0YSA9IG1ldGFzZXRzW2ldO1xyXG5cdFx0XHRcdGlmIChkc01ldGEuaW5kZXggPT09IGRhdGFzZXRJbmRleCkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZHNNZXRhLmluZGV4XTtcclxuXHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkKSB7XHJcblx0XHRcdFx0XHRzdGFja2VkUmlnaHRWYWx1ZSA9ICt5U2NhbGUuZ2V0UmlnaHRWYWx1ZShkcy5kYXRhW2luZGV4XSk7XHJcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XHJcblx0XHRcdFx0XHRcdHN1bU5lZyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcclxuXHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtTmVnICsgcmlnaHRWYWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1ldGEuZGF0YXNldC5fbW9kZWw7XHJcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XHJcblxyXG5cdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcclxuXHRcdGlmIChsaW5lTW9kZWwuc3BhbkdhcHMpIHtcclxuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xyXG5cdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xyXG5cdFx0XHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XHJcblx0XHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZShcclxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXHJcblx0XHRcdFx0XHRtb2RlbCxcclxuXHRcdFx0XHRcdGhlbHBlcnMkMS5uZXh0SXRlbShwb2ludHMsIGkpLl9tb2RlbCxcclxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XHJcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xyXG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY29udHJvbFBvaW50cy5uZXh0Lng7XHJcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xyXG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xyXG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGlzUG9pbnRJbkFyZWEocG9pbnRzW2kgLSAxXS5fbW9kZWwsIGFyZWEpKSB7XHJcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1gsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XHJcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxICYmIGlzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXS5fbW9kZWwsIGFyZWEpKSB7XHJcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xyXG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcclxuXHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xyXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciBpbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHRcdHZhciBjbGlwO1xyXG5cclxuXHRcdGlmIChtZS5fc2hvd0xpbmUpIHtcclxuXHRcdFx0Y2xpcCA9IG1ldGEuZGF0YXNldC5fbW9kZWwuY2xpcDtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCB7XHJcblx0XHRcdFx0bGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXHJcblx0XHRcdFx0cmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gY2FudmFzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXHJcblx0XHRcdFx0dG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcclxuXHRcdFx0XHRib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IGNhbnZhcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERyYXcgdGhlIHBvaW50c1xyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cG9pbnRzW2ldLmRyYXcoYXJlYSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqL1xyXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XHJcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xyXG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcclxuXHJcblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcclxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xyXG5cdFx0fTtcclxuXHJcblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcclxuXHR9LFxyXG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BvbGFyQXJlYScsIHtcclxuXHRzY2FsZToge1xyXG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcicsXHJcblx0XHRhbmdsZUxpbmVzOiB7XHJcblx0XHRcdGRpc3BsYXk6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0Z3JpZExpbmVzOiB7XHJcblx0XHRcdGNpcmN1bGFyOiB0cnVlXHJcblx0XHR9LFxyXG5cdFx0cG9pbnRMYWJlbHM6IHtcclxuXHRcdFx0ZGlzcGxheTogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR0aWNrczoge1xyXG5cdFx0XHRiZWdpbkF0WmVybzogdHJ1ZVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydFxyXG5cdGFuaW1hdGlvbjoge1xyXG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcclxuXHRcdGFuaW1hdGVTY2FsZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdHN0YXJ0QW5nbGU6IC0wLjUgKiBNYXRoLlBJLFxyXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xyXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcclxuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcclxuXHRcdHZhciBpLCBpbGVuLCBsaXN0SXRlbSwgbGlzdEl0ZW1TcGFuO1xyXG5cclxuXHRcdGxpc3Quc2V0QXR0cmlidXRlKCdjbGFzcycsIGNoYXJ0LmlkICsgJy1sZWdlbmQnKTtcclxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdFx0bGlzdEl0ZW0gPSBsaXN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJykpO1xyXG5cdFx0XHRcdGxpc3RJdGVtU3BhbiA9IGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XHJcblx0XHRcdFx0bGlzdEl0ZW1TcGFuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXTtcclxuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XHJcblx0XHRcdFx0XHRsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbHNbaV0pKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGlzdC5vdXRlckhUTUw7XHJcblx0fSxcclxuXHRsZWdlbmQ6IHtcclxuXHRcdGxhYmVsczoge1xyXG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XHJcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xyXG5cdFx0XHRcdFx0XHR2YXIgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxyXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcclxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZGF0YS5kYXRhc2V0c1swXS5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cclxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XHJcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XHJcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxyXG5cdHRvb2x0aXBzOiB7XHJcblx0XHRjYWxsYmFja3M6IHtcclxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAnJztcclxuXHRcdFx0fSxcclxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcclxuXHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHNbaXRlbS5pbmRleF0gKyAnOiAnICsgaXRlbS55TGFiZWw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfcG9sYXJBcmVhID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cclxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcclxuXHJcblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xyXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlcldpZHRoJyxcclxuXHRcdCdib3JkZXJBbGlnbicsXHJcblx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxyXG5cdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxyXG5cdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxyXG5cdF0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZS5pZDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcclxuXHRcdHZhciBzdGFydHMgPSBtZS5fc3RhcnRzID0gW107XHJcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xyXG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XHJcblx0XHR2YXIgaSwgaWxlbiwgYW5nbGU7XHJcblxyXG5cdFx0bWUuX3VwZGF0ZVJhZGl1cygpO1xyXG5cclxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0LmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xyXG5cdFx0XHRhbmdsZSA9IG1lLl9jb21wdXRlQW5nbGUoaSk7XHJcblx0XHRcdGFuZ2xlc1tpXSA9IGFuZ2xlO1xyXG5cdFx0XHRzdGFydCArPSBhbmdsZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xyXG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyY3NbaV0sIGksIHJlc2V0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF91cGRhdGVSYWRpdXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcclxuXHJcblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcclxuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XHJcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XHJcblxyXG5cdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIChjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5pbmRleCk7XHJcblx0XHRtZS5pbm5lclJhZGl1cyA9IG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XHJcblx0XHR2YXIgc2NhbGUgPSBjaGFydC5zY2FsZTtcclxuXHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcclxuXHJcblx0XHR2YXIgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XHJcblx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XHJcblxyXG5cdFx0Ly8gdmFyIG5lZ0hhbGZQSSA9IC0wLjUgKiBNYXRoLlBJO1xyXG5cdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xyXG5cdFx0dmFyIGRpc3RhbmNlID0gYXJjLmhpZGRlbiA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdHZhciBzdGFydEFuZ2xlID0gbWUuX3N0YXJ0c1tpbmRleF07XHJcblx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogbWUuX2FuZ2xlc1tpbmRleF0pO1xyXG5cclxuXHRcdHZhciByZXNldFJhZGl1cyA9IGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcclxuXHRcdFx0Ly8gVXRpbGl0eVxyXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcclxuXHRcdFx0X2luZGV4OiBpbmRleCxcclxuXHRcdFx0X3NjYWxlOiBzY2FsZSxcclxuXHJcblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXHJcblx0XHRcdF9tb2RlbDoge1xyXG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcblx0XHRcdFx0Ym9yZGVyQWxpZ246IG9wdGlvbnMuYm9yZGVyQWxpZ24sXHJcblx0XHRcdFx0eDogY2VudGVyWCxcclxuXHRcdFx0XHR5OiBjZW50ZXJZLFxyXG5cdFx0XHRcdGlubmVyUmFkaXVzOiAwLFxyXG5cdFx0XHRcdG91dGVyUmFkaXVzOiByZXNldCA/IHJlc2V0UmFkaXVzIDogZGlzdGFuY2UsXHJcblx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdGVuZEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IGVuZEFuZ2xlLFxyXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGxhYmVscywgaW5kZXgsIGxhYmVsc1tpbmRleF0pXHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGFyYy5waXZvdCgpO1xyXG5cdH0sXHJcblxyXG5cdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcblx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvdW50O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKi9cclxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcclxuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XHJcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcclxuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XHJcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXHJcblx0XHR9O1xyXG5cclxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcclxuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jb21wdXRlQW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNvdW50ID0gdGhpcy5nZXRNZXRhKCkuY291bnQ7XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xyXG5cclxuXHRcdGlmIChpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcclxuXHRcdHZhciBjb250ZXh0ID0ge1xyXG5cdFx0XHRjaGFydDogbWUuY2hhcnQsXHJcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXHJcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXHJcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHJlc29sdmUkMyhbXHJcblx0XHRcdG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjLmFuZ2xlLFxyXG5cdFx0XHQoMiAqIE1hdGguUEkpIC8gY291bnRcclxuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcclxuXHR9XHJcbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BpZScsIGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmRvdWdobnV0KSk7XHJcbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywge1xyXG5cdGN1dG91dFBlcmNlbnRhZ2U6IDBcclxufSk7XHJcblxyXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xyXG52YXIgY29udHJvbGxlcl9waWUgPSBjb250cm9sbGVyX2RvdWdobnV0O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XHJcblx0c3BhbkdhcHM6IGZhbHNlLFxyXG5cdHNjYWxlOiB7XHJcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xyXG5cdH0sXHJcblx0ZWxlbWVudHM6IHtcclxuXHRcdGxpbmU6IHtcclxuXHRcdFx0ZmlsbDogJ3N0YXJ0JyxcclxuXHRcdFx0dGVuc2lvbjogMCAvLyBubyBiZXppZXIgaW4gcmFkYXJcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2xsZXJfcmFkYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XHJcblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxyXG5cclxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxyXG5cclxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YXNldEVsZW1lbnRPcHRpb25zOiBbXHJcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcclxuXHRcdCdib3JkZXJXaWR0aCcsXHJcblx0XHQnYm9yZGVyQ29sb3InLFxyXG5cdFx0J2JvcmRlckNhcFN0eWxlJyxcclxuXHRcdCdib3JkZXJEYXNoJyxcclxuXHRcdCdib3JkZXJEYXNoT2Zmc2V0JyxcclxuXHRcdCdib3JkZXJKb2luU3R5bGUnLFxyXG5cdFx0J2ZpbGwnXHJcblx0XSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiB7XHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXHJcblx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxyXG5cdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcclxuXHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcclxuXHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXHJcblx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcclxuXHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxyXG5cdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcclxuXHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcclxuXHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcclxuXHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xyXG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcclxuXHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xyXG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXHJcblx0XHRpZiAoY29uZmlnLnRlbnNpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRjb25maWcubGluZVRlbnNpb24gPSBjb25maWcudGVuc2lvbjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVdGlsaXR5XHJcblx0XHRsaW5lLl9zY2FsZSA9IHNjYWxlO1xyXG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHQvLyBEYXRhXHJcblx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcclxuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xyXG5cdFx0Ly8gTW9kZWxcclxuXHRcdGxpbmUuX21vZGVsID0gbWUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobGluZSk7XHJcblxyXG5cdFx0bGluZS5waXZvdCgpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGJlemllciBjb250cm9sIHBvaW50c1xyXG5cdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xyXG5cclxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XHJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xyXG5cdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xyXG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1lLmdldE1ldGEoKS5kYXRhc2V0Ll9tb2RlbDtcclxuXHRcdHZhciB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xyXG5cdFx0dmFyIHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XHJcblxyXG5cdFx0Ly8gVXRpbGl0eVxyXG5cdFx0cG9pbnQuX3NjYWxlID0gc2NhbGU7XHJcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XHJcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcclxuXHJcblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0cG9pbnQuX21vZGVsID0ge1xyXG5cdFx0XHR4OiB4LCAvLyB2YWx1ZSBub3QgdXNlZCBpbiBkYXRhc2V0IHNjYWxlLCBidXQgd2Ugd2FudCBhIGNvbnNpc3RlbnQgQVBJIGJldHdlZW4gc2NhbGVzXHJcblx0XHRcdHk6IHksXHJcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxyXG5cdFx0XHQvLyBBcHBlYXJhbmNlXHJcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXHJcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcclxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXHJcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcclxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNyhjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcclxuXHJcblx0XHRcdC8vIFRvb2x0aXBcclxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcclxuXHRcdHZhciBvcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucztcclxuXHRcdHZhciB2YWx1ZXMgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHJcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ3KGNvbmZpZy5zcGFuR2Fwcywgb3B0aW9ucy5zcGFuR2Fwcyk7XHJcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDcoY29uZmlnLmxpbmVUZW5zaW9uLCBvcHRpb25zLmVsZW1lbnRzLmxpbmUudGVuc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdHZhciBhcmVhID0gbWUuY2hhcnQuY2hhcnRBcmVhO1xyXG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcclxuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcclxuXHJcblx0XHQvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxyXG5cdFx0aWYgKG1ldGEuZGF0YXNldC5fbW9kZWwuc3BhbkdhcHMpIHtcclxuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xyXG5cdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcclxuXHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZShcclxuXHRcdFx0XHRoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaSwgdHJ1ZSkuX21vZGVsLFxyXG5cdFx0XHRcdG1vZGVsLFxyXG5cdFx0XHRcdGhlbHBlcnMkMS5uZXh0SXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcclxuXHRcdFx0XHRtb2RlbC50ZW5zaW9uXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IHRoZSBiZXppZXIgZ29pbmcgb3V0c2lkZSBvZiB0aGUgYm91bmRzIG9mIHRoZSBncmFwaFxyXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xyXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLm5leHQueCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcclxuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcclxuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XHJcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xyXG5cclxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcclxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxyXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXHJcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXHJcblx0XHR9O1xyXG5cclxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDcob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xyXG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XHJcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDcob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcclxuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDcob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xyXG5cdH1cclxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcclxuXHRob3Zlcjoge1xyXG5cdFx0bW9kZTogJ3NpbmdsZSdcclxuXHR9LFxyXG5cclxuXHRzY2FsZXM6IHtcclxuXHRcdHhBeGVzOiBbe1xyXG5cdFx0XHRpZDogJ3gtYXhpcy0xJywgICAgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxyXG5cdFx0XHR0eXBlOiAnbGluZWFyJywgICAgLy8gc2NhdHRlciBzaG91bGQgbm90IHVzZSBhIGNhdGVnb3J5IGF4aXNcclxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXHJcblx0XHR9XSxcclxuXHRcdHlBeGVzOiBbe1xyXG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcclxuXHRcdFx0dHlwZTogJ2xpbmVhcicsXHJcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCdcclxuXHRcdH1dXHJcblx0fSxcclxuXHJcblx0dG9vbHRpcHM6IHtcclxuXHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICcnOyAgICAgLy8gZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIGRhdGEgYXJlIGZvcm1hdHRlZCBhcyBhIHBvaW50XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0cmV0dXJuICcoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJyknO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGRhdGFzZXRzOiB7XHJcblx0XHRzY2F0dGVyOiB7XHJcblx0XHRcdHNob3dMaW5lOiBmYWxzZVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBTY2F0dGVyIGNoYXJ0cyB1c2UgbGluZSBjb250cm9sbGVyc1xyXG52YXIgY29udHJvbGxlcl9zY2F0dGVyID0gY29udHJvbGxlcl9saW5lO1xuXG4vLyBOT1RFIGV4cG9ydCBhIG1hcCBpbiB3aGljaCB0aGUga2V5IHJlcHJlc2VudHMgdGhlIGNvbnRyb2xsZXIgdHlwZSwgbm90XHJcbi8vIHRoZSBjbGFzcywgYW5kIHNvIG11c3QgYmUgQ2FtZWxDYXNlIGluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSByZXRyaWV2ZWRcclxuLy8gYnkgdGhlIGNvbnRyb2xsZXIgaW4gY29yZS5jb250cm9sbGVyLmpzIChgY29udHJvbGxlcnNbbWV0YS50eXBlXWApLlxyXG5cclxudmFyIGNvbnRyb2xsZXJzID0ge1xyXG5cdGJhcjogY29udHJvbGxlcl9iYXIsXHJcblx0YnViYmxlOiBjb250cm9sbGVyX2J1YmJsZSxcclxuXHRkb3VnaG51dDogY29udHJvbGxlcl9kb3VnaG51dCxcclxuXHRob3Jpem9udGFsQmFyOiBjb250cm9sbGVyX2hvcml6b250YWxCYXIsXHJcblx0bGluZTogY29udHJvbGxlcl9saW5lLFxyXG5cdHBvbGFyQXJlYTogY29udHJvbGxlcl9wb2xhckFyZWEsXHJcblx0cGllOiBjb250cm9sbGVyX3BpZSxcclxuXHRyYWRhcjogY29udHJvbGxlcl9yYWRhcixcclxuXHRzY2F0dGVyOiBjb250cm9sbGVyX3NjYXR0ZXJcclxufTtcblxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIGFuIGV2ZW50XHJcbiAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxyXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgZXZlbnQgcG9zaXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpIHtcclxuXHRpZiAoZS5uYXRpdmUpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IGUueCxcclxuXHRcdFx0eTogZS55XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB0cmF2ZXJzZSBhbGwgb2YgdGhlIHZpc2libGUgZWxlbWVudHMgaW4gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBoYW5kbGVyKSB7XHJcblx0dmFyIG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHR2YXIgbWV0YWRhdGEsIGksIGosIGlsZW4sIGpsZW4sIGVsZW1lbnQ7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdG1ldGFkYXRhID0gbWV0YXNldHNbaV0uZGF0YTtcclxuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuXHRcdFx0ZWxlbWVudCA9IG1ldGFkYXRhW2pdO1xyXG5cdFx0XHRpZiAoIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xyXG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cclxuICogQHBhcmFtIHtDaGFydEVsZW1lbnRbXX0gaXRlbXMgLSBlbGVtZW50cyB0byBmaWx0ZXJcclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cclxuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcclxuXHR2YXIgZWxlbWVudHMgPSBbXTtcclxuXHJcblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIGVsZW1lbnRzO1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGVoIGNoYXJ0XHJcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxyXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVyc2VjdCAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlTWV0cmljIC0gZnVuY3Rpb24gdG8gcHJvdmlkZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHNcclxuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBpbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKSB7XHJcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cdHZhciBuZWFyZXN0SXRlbXMgPSBbXTtcclxuXHJcblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQoKTtcclxuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xyXG5cdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0bmVhcmVzdEl0ZW1zID0gW2VsZW1lbnRdO1xyXG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG5cdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcclxuXHRcdFx0Ly8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcclxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBuZWFyZXN0SXRlbXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXHJcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xyXG5cdHZhciB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xyXG5cdHZhciB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcclxuXHRcdHZhciBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xyXG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleE1vZGUoY2hhcnQsIGUsIG9wdGlvbnMpIHtcclxuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHQvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcclxuXHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xyXG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xyXG5cdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XHJcblx0dmFyIGVsZW1lbnRzID0gW107XHJcblxyXG5cdGlmICghaXRlbXMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gW107XHJcblx0fVxyXG5cclxuXHRjaGFydC5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goZnVuY3Rpb24obWV0YSkge1xyXG5cdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbaXRlbXNbMF0uX2luZGV4XTtcclxuXHJcblx0XHQvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXHJcblx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XHJcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgSUludGVyYWN0aW9uT3B0aW9uc1xyXG4gKi9cclxuLyoqXHJcbiAqIElmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvaW50XHJcbiAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cclxuICogQHR5cGUgQm9vbGVhblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXHJcbiAqL1xyXG52YXIgY29yZV9pbnRlcmFjdGlvbiA9IHtcclxuXHQvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xyXG5cdG1vZGVzOiB7XHJcblx0XHRzaW5nbGU6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xyXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBbXTtcclxuXHJcblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xyXG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLnNsaWNlKDAsIDEpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbFxyXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMFxyXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0bGFiZWw6IGluZGV4TW9kZSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xyXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxyXG5cdFx0ICogQHNpbmNlIHYyLjQuMFxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXHJcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXHJcblx0XHQgKi9cclxuXHRcdGluZGV4OiBpbmRleE1vZGUsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xyXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxyXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxyXG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXHJcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXHJcblx0XHQgKi9cclxuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xyXG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcclxuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XHJcblx0XHRcdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XHJcblxyXG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGl0ZW1zID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uX2RhdGFzZXRJbmRleCkuZGF0YTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54LWF4aXNcclxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAuIFVzZSBpbmRleCBtb2RlIGFuZCBpbnRlcnNlY3QgPT0gdHJ1ZVxyXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0J3gtYXhpcyc6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XHJcblx0XHRcdHJldHVybiBpbmRleE1vZGUoY2hhcnQsIGUsIHtpbnRlcnNlY3Q6IGZhbHNlfSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxyXG5cdFx0ICogb2YgdGhlIGV2ZW50XHJcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXHJcblx0XHQgKi9cclxuXHRcdHBvaW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3RcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXHJcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXHJcblx0XHQgKi9cclxuXHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xyXG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcclxuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XHJcblx0XHRcdHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxyXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcclxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcclxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXHJcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXHJcblx0XHQgKi9cclxuXHRcdHg6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcclxuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XHJcblxyXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluWFJhbmdlKHBvc2l0aW9uLngpKSB7XHJcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xyXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXHJcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcclxuXHRcdFx0XHRpdGVtcyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBpdGVtcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcclxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XHJcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cclxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XHJcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxyXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICovXHJcblx0XHR5OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuXHRcdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudC5pbllSYW5nZShwb3NpdGlvbi55KSkge1xyXG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcclxuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcclxuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xyXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XHJcblx0XHRcdFx0aXRlbXMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaXRlbXM7XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgZXh0ZW5kID0gaGVscGVycyQxLmV4dGVuZDtcclxuXHJcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS53aGVyZShhcnJheSwgZnVuY3Rpb24odikge1xyXG5cdFx0cmV0dXJuIHYucG9zID09PSBwb3NpdGlvbjtcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XHJcblx0cmV0dXJuIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0dmFyIHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xyXG5cdFx0dmFyIHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xyXG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cclxuXHRcdFx0djAuaW5kZXggLSB2MS5pbmRleCA6XHJcblx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XHJcblx0dmFyIGxheW91dEJveGVzID0gW107XHJcblx0dmFyIGksIGlsZW4sIGJveDtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRib3ggPSBib3hlc1tpXTtcclxuXHRcdGxheW91dEJveGVzLnB1c2goe1xyXG5cdFx0XHRpbmRleDogaSxcclxuXHRcdFx0Ym94OiBib3gsXHJcblx0XHRcdHBvczogYm94LnBvc2l0aW9uLFxyXG5cdFx0XHRob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXHJcblx0XHRcdHdlaWdodDogYm94LndlaWdodFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHJldHVybiBsYXlvdXRCb3hlcztcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcclxuXHR2YXIgaSwgaWxlbiwgbGF5b3V0O1xyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0bGF5b3V0ID0gbGF5b3V0c1tpXTtcclxuXHRcdC8vIHN0b3JlIHdpZHRoIHVzZWQgaW5zdGVhZCBvZiBjaGFydEFyZWEudyBpbiBmaXRCb3hlc1xyXG5cdFx0bGF5b3V0LndpZHRoID0gbGF5b3V0Lmhvcml6b250YWxcclxuXHRcdFx0PyBsYXlvdXQuYm94LmZ1bGxXaWR0aCAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGhcclxuXHRcdFx0OiBwYXJhbXMudkJveE1heFdpZHRoO1xyXG5cdFx0Ly8gc3RvcmUgaGVpZ2h0IHVzZWQgaW5zdGVhZCBvZiBjaGFydEFyZWEuaCBpbiBmaXRCb3hlc1xyXG5cdFx0bGF5b3V0LmhlaWdodCA9IGxheW91dC5ob3Jpem9udGFsICYmIHBhcmFtcy5oQm94TWF4SGVpZ2h0O1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xyXG5cdHZhciBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XHJcblx0dmFyIGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XHJcblx0dmFyIHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcclxuXHR2YXIgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XHJcblx0dmFyIGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcclxuXHRcdHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoYm90dG9tKSxcclxuXHRcdGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxyXG5cdFx0dmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KSxcclxuXHRcdGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xyXG5cdHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0KSB7XHJcblx0dmFyIGJveCA9IGxheW91dC5ib3g7XHJcblx0dmFyIG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcclxuXHR2YXIgbmV3V2lkdGgsIG5ld0hlaWdodDtcclxuXHJcblx0aWYgKGxheW91dC5zaXplKSB7XHJcblx0XHQvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcclxuXHRcdGNoYXJ0QXJlYVtsYXlvdXQucG9zXSAtPSBsYXlvdXQuc2l6ZTtcclxuXHR9XHJcblx0bGF5b3V0LnNpemUgPSBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGg7XHJcblx0Y2hhcnRBcmVhW2xheW91dC5wb3NdICs9IGxheW91dC5zaXplO1xyXG5cclxuXHRpZiAoYm94LmdldFBhZGRpbmcpIHtcclxuXHRcdHZhciBib3hQYWRkaW5nID0gYm94LmdldFBhZGRpbmcoKTtcclxuXHRcdG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcclxuXHRcdG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcclxuXHRcdG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcclxuXHRcdG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcclxuXHR9XHJcblxyXG5cdG5ld1dpZHRoID0gcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0Jyk7XHJcblx0bmV3SGVpZ2h0ID0gcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpO1xyXG5cclxuXHRpZiAobmV3V2lkdGggIT09IGNoYXJ0QXJlYS53IHx8IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmgpIHtcclxuXHRcdGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XHJcblx0XHRjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcclxuXHJcblx0XHQvLyByZXR1cm4gdHJ1ZSBpZiBjaGFydCBhcmVhIGNoYW5nZWQgaW4gbGF5b3V0J3MgZGlyZWN0aW9uXHJcblx0XHR2YXIgc2l6ZXMgPSBsYXlvdXQuaG9yaXpvbnRhbCA/IFtuZXdXaWR0aCwgY2hhcnRBcmVhLnddIDogW25ld0hlaWdodCwgY2hhcnRBcmVhLmhdO1xyXG5cdFx0cmV0dXJuIHNpemVzWzBdICE9PSBzaXplc1sxXSAmJiAoIWlzTmFOKHNpemVzWzBdKSB8fCAhaXNOYU4oc2l6ZXNbMV0pKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XHJcblx0dmFyIG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xyXG5cdFx0dmFyIGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcclxuXHRcdGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcclxuXHRcdHJldHVybiBjaGFuZ2U7XHJcblx0fVxyXG5cdGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XHJcblx0Y2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XHJcblx0dXBkYXRlUG9zKCdyaWdodCcpO1xyXG5cdHVwZGF0ZVBvcygnYm90dG9tJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XHJcblx0dmFyIG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcclxuXHJcblx0ZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xyXG5cdFx0dmFyIG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xyXG5cdFx0cG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9zKSB7XHJcblx0XHRcdG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBtYXJnaW47XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaG9yaXpvbnRhbFxyXG5cdFx0PyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXHJcblx0XHQ6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykge1xyXG5cdHZhciByZWZpdEJveGVzID0gW107XHJcblx0dmFyIGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0bGF5b3V0ID0gYm94ZXNbaV07XHJcblx0XHRib3ggPSBsYXlvdXQuYm94O1xyXG5cclxuXHRcdGJveC51cGRhdGUoXHJcblx0XHRcdGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcclxuXHRcdFx0bGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcclxuXHRcdFx0Z2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxyXG5cdFx0KTtcclxuXHRcdGlmICh1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQpKSB7XHJcblx0XHRcdGNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0XHRpZiAocmVmaXRCb3hlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBEaW1lbnNpb25zIGNoYW5nZWQgYW5kIHRoZXJlIHdlcmUgbm9uIGZ1bGwgd2lkdGggYm94ZXMgYmVmb3JlIHRoaXNcclxuXHRcdFx0XHQvLyAtPiB3ZSBoYXZlIHRvIHJlZml0IHRob3NlXHJcblx0XHRcdFx0cmVmaXQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHsgLy8gZnVsbFdpZHRoIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXHJcblx0XHRcdHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlZml0ID8gZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpIHx8IGNoYW5nZWQgOiBjaGFuZ2VkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykge1xyXG5cdHZhciB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xyXG5cdHZhciB4ID0gY2hhcnRBcmVhLng7XHJcblx0dmFyIHkgPSBjaGFydEFyZWEueTtcclxuXHR2YXIgaSwgaWxlbiwgbGF5b3V0LCBib3g7XHJcblxyXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGxheW91dCA9IGJveGVzW2ldO1xyXG5cdFx0Ym94ID0gbGF5b3V0LmJveDtcclxuXHRcdGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xyXG5cdFx0XHRib3gubGVmdCA9IGJveC5mdWxsV2lkdGggPyB1c2VyUGFkZGluZy5sZWZ0IDogY2hhcnRBcmVhLmxlZnQ7XHJcblx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudztcclxuXHRcdFx0Ym94LnRvcCA9IHk7XHJcblx0XHRcdGJveC5ib3R0b20gPSB5ICsgYm94LmhlaWdodDtcclxuXHRcdFx0Ym94LndpZHRoID0gYm94LnJpZ2h0IC0gYm94LmxlZnQ7XHJcblx0XHRcdHkgPSBib3guYm90dG9tO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ym94LmxlZnQgPSB4O1xyXG5cdFx0XHRib3gucmlnaHQgPSB4ICsgYm94LndpZHRoO1xyXG5cdFx0XHRib3gudG9wID0gY2hhcnRBcmVhLnRvcDtcclxuXHRcdFx0Ym94LmJvdHRvbSA9IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaDtcclxuXHRcdFx0Ym94LmhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wO1xyXG5cdFx0XHR4ID0gYm94LnJpZ2h0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y2hhcnRBcmVhLnggPSB4O1xyXG5cdGNoYXJ0QXJlYS55ID0geTtcclxufVxyXG5cclxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0bGF5b3V0OiB7XHJcblx0XHRwYWRkaW5nOiB7XHJcblx0XHRcdHRvcDogMCxcclxuXHRcdFx0cmlnaHQ6IDAsXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogMFxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBJTGF5b3V0SXRlbVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXHJcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcclxuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXHJcbiAqIEBwcm9wIHtmdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcclxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cclxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcclxuICogQHByb3Age251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXHJcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXHJcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcclxuICogQHByb3Age251bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcclxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXHJcbiAqL1xyXG5cclxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXHJcbi8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxyXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXHJcbnZhciBjb3JlX2xheW91dHMgPSB7XHJcblx0ZGVmYXVsdHM6IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlciBhIGJveCB0byBhIGNoYXJ0LlxyXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXHJcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXHJcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYXllZCBvdXRcclxuXHQgKi9cclxuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XHJcblx0XHRpZiAoIWNoYXJ0LmJveGVzKSB7XHJcblx0XHRcdGNoYXJ0LmJveGVzID0gW107XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XHJcblx0XHRpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcclxuXHRcdGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcclxuXHRcdGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0ejogMCxcclxuXHRcdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGl0ZW0uZHJhdy5hcHBseShpdGVtLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fV07XHJcblx0XHR9O1xyXG5cclxuXHRcdGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXHJcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcclxuXHQgKi9cclxuXHRyZW1vdmVCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBsYXlvdXRJdGVtKSB7XHJcblx0XHR2YXIgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcclxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0Y2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXHJcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXHJcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cclxuXHQgKi9cclxuXHRjb25maWd1cmU6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcclxuXHRcdHZhciBpbGVuID0gcHJvcHMubGVuZ3RoO1xyXG5cdFx0dmFyIGkgPSAwO1xyXG5cdFx0dmFyIHByb3A7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xyXG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdFx0XHRcdGl0ZW1bcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcclxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cclxuXHQgKi9cclxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRpZiAoIWNoYXJ0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGF5b3V0T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMubGF5b3V0IHx8IHt9O1xyXG5cdFx0dmFyIHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcobGF5b3V0T3B0aW9ucy5wYWRkaW5nKTtcclxuXHJcblx0XHR2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIHBhZGRpbmcud2lkdGg7XHJcblx0XHR2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XHJcblx0XHR2YXIgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcclxuXHRcdHZhciB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XHJcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcclxuXHJcblx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXHJcblx0XHQvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cclxuXHRcdC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXHJcblx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcclxuXHRcdC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xyXG5cdFx0Ly8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXHJcblx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cclxuXHRcdC8vXHJcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxyXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcclxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxyXG5cdFx0Ly8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XHJcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcclxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxyXG5cdFx0Ly8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XHJcblx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcclxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxyXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcblx0XHQvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcclxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XHJcblx0XHRcdG91dGVyV2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRvdXRlckhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRwYWRkaW5nOiBwYWRkaW5nLFxyXG5cdFx0XHRhdmFpbGFibGVXaWR0aDogYXZhaWxhYmxlV2lkdGgsXHJcblx0XHRcdHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmVydGljYWxCb3hlcy5sZW5ndGgsXHJcblx0XHRcdGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcclxuXHRcdH0pO1xyXG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGV4dGVuZCh7XHJcblx0XHRcdG1heFBhZGRpbmc6IGV4dGVuZCh7fSwgcGFkZGluZyksXHJcblx0XHRcdHc6IGF2YWlsYWJsZVdpZHRoLFxyXG5cdFx0XHRoOiBhdmFpbGFibGVIZWlnaHQsXHJcblx0XHRcdHg6IHBhZGRpbmcubGVmdCxcclxuXHRcdFx0eTogcGFkZGluZy50b3BcclxuXHRcdH0sIHBhZGRpbmcpO1xyXG5cclxuXHRcdHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcclxuXHJcblx0XHQvLyBGaXJzdCBmaXQgdmVydGljYWwgYm94ZXNcclxuXHRcdGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKTtcclxuXHJcblx0XHQvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXHJcblx0XHRpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykpIHtcclxuXHRcdFx0Ly8gaWYgdGhlIGFyZWEgY2hhbmdlZCwgcmUtZml0IHZlcnRpY2FsIGJveGVzXHJcblx0XHRcdGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKTtcclxuXHRcdH1cclxuXHJcblx0XHRoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XHJcblxyXG5cdFx0Ly8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xyXG5cdFx0cGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcyk7XHJcblxyXG5cdFx0Ly8gTW92ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIGNoYXJ0XHJcblx0XHRjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcclxuXHRcdGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xyXG5cclxuXHRcdHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zKTtcclxuXHJcblx0XHRjaGFydC5jaGFydEFyZWEgPSB7XHJcblx0XHRcdGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxyXG5cdFx0XHR0b3A6IGNoYXJ0QXJlYS50b3AsXHJcblx0XHRcdHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxyXG5cdFx0XHRib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBGaW5hbGx5IHVwZGF0ZSBib3hlcyBpbiBjaGFydEFyZWEgKHJhZGlhbCBzY2FsZSBmb3IgZXhhbXBsZSlcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGJveGVzLmNoYXJ0QXJlYSwgZnVuY3Rpb24obGF5b3V0KSB7XHJcblx0XHRcdHZhciBib3ggPSBsYXlvdXQuYm94O1xyXG5cdFx0XHRleHRlbmQoYm94LCBjaGFydC5jaGFydEFyZWEpO1xyXG5cdFx0XHRib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XG5cbi8qKlxyXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcclxuICovXHJcblxyXG52YXIgcGxhdGZvcm1fYmFzaWMgPSB7XHJcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XHJcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxyXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XHJcblx0fVxyXG59O1xuXG52YXIgcGxhdGZvcm1fZG9tID0gXCIvKlxcclxcbiAqIERPTSBlbGVtZW50IHJlbmRlcmluZyBkZXRlY3Rpb25cXHJcXG4gKiBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cXHJcXG4gKi9cXHJcXG5Aa2V5ZnJhbWVzIGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiB7XFxyXFxuXFx0ZnJvbSB7IG9wYWNpdHk6IDAuOTk7IH1cXHJcXG5cXHR0byB7IG9wYWNpdHk6IDE7IH1cXHJcXG59XFxyXFxuXFxyXFxuLmNoYXJ0anMtcmVuZGVyLW1vbml0b3Ige1xcclxcblxcdGFuaW1hdGlvbjogY2hhcnRqcy1yZW5kZXItYW5pbWF0aW9uIDAuMDAxcztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gKiBET00gZWxlbWVudCByZXNpemluZyBkZXRlY3Rpb25cXHJcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xcclxcbiAqL1xcclxcbi5jaGFydGpzLXNpemUtbW9uaXRvcixcXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kLFxcclxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbmsge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRkaXJlY3Rpb246IGx0cjtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuXFx0ei1pbmRleDogLTE7XFxyXFxufVxcclxcblxcclxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQgPiBkaXYge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR3aWR0aDogMTAwMDAwMHB4O1xcclxcblxcdGhlaWdodDogMTAwMDAwMHB4O1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0dG9wOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rID4gZGl2IHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0d2lkdGg6IDIwMCU7XFxyXFxuXFx0aGVpZ2h0OiAyMDAlO1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0dG9wOiAwO1xcclxcbn1cXHJcXG5cIjtcblxudmFyIHBsYXRmb3JtX2RvbSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuJ2RlZmF1bHQnOiBwbGF0Zm9ybV9kb21cbn0pO1xuXG52YXIgc3R5bGVzaGVldCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UocGxhdGZvcm1fZG9tJDEpO1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xyXG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XHJcbnZhciBDU1NfU0laRV9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdzaXplLW1vbml0b3InO1xyXG52YXIgQ1NTX1JFTkRFUl9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdyZW5kZXItbW9uaXRvcic7XHJcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XHJcbnZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWydhbmltYXRpb25zdGFydCcsICd3ZWJraXRBbmltYXRpb25TdGFydCddO1xyXG5cclxuLyoqXHJcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cclxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcclxuICovXHJcbnZhciBFVkVOVF9UWVBFUyA9IHtcclxuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcclxuXHR0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoZW5kOiAnbW91c2V1cCcsXHJcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXHJcblx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxyXG5cdHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcclxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcclxuXHRwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXHJcblx0cG9pbnRlcm91dDogJ21vdXNlb3V0J1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcclxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcclxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxyXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxyXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XHJcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcclxuXHR2YXIgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xyXG5cdHJldHVybiBtYXRjaGVzID8gTnVtYmVyKG1hdGNoZXNbMV0pIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXHJcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcclxuICogdG8gZGV0ZXJtaW5lIHRoZSBhc3BlY3QgcmF0aW8gdG8gYXBwbHkgaW4gY2FzZSBubyBleHBsaWNpdCBoZWlnaHQgaGFzIGJlZW4gc3BlY2lmaWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGNvbmZpZykge1xyXG5cdHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcclxuXHJcblx0Ly8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxyXG5cdC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXHJcblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xyXG5cdHZhciByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XHJcblxyXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XHJcblx0Y2FudmFzW0VYUEFORE9fS0VZXSA9IHtcclxuXHRcdGluaXRpYWw6IHtcclxuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXHJcblx0XHRcdHdpZHRoOiByZW5kZXJXaWR0aCxcclxuXHRcdFx0c3R5bGU6IHtcclxuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxyXG5cdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxyXG5cdFx0XHRcdHdpZHRoOiBzdHlsZS53aWR0aFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxyXG5cdC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cclxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxyXG5cdHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XHJcblxyXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcclxuXHRcdHZhciBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcclxuXHRcdGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAocmVuZGVySGVpZ2h0ID09PSBudWxsIHx8IHJlbmRlckhlaWdodCA9PT0gJycpIHtcclxuXHRcdGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xyXG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXHJcblx0XHRcdC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxyXG5cdFx0XHQvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cclxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xyXG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNhbnZhcztcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XHJcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdXBwb3J0cyA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2UnLCBudWxsLCBvcHRpb25zKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0cztcclxufSgpKTtcclxuXHJcbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcclxudmFyIGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcclxuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcclxuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6IHR5cGUsXHJcblx0XHRjaGFydDogY2hhcnQsXHJcblx0XHRuYXRpdmU6IG5hdGl2ZUV2ZW50IHx8IG51bGwsXHJcblx0XHR4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcclxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcclxuXHR2YXIgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XHJcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XHJcblx0cmV0dXJuIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCBwb3MueCwgcG9zLnksIGV2ZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnKSB7XHJcblx0dmFyIHRpY2tpbmcgPSBmYWxzZTtcclxuXHR2YXIgYXJncyA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHRcdHRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XHJcblxyXG5cdFx0aWYgKCF0aWNraW5nKSB7XHJcblx0XHRcdHRpY2tpbmcgPSB0cnVlO1xyXG5cdFx0XHRoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcdGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEaXYoY2xzKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcclxuZnVuY3Rpb24gY3JlYXRlUmVzaXplcihoYW5kbGVyKSB7XHJcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xyXG5cclxuXHQvLyBOT1RFKFNCKSBEb24ndCB1c2UgaW5uZXJIVE1MIGJlY2F1c2UgaXQgY291bGQgYmUgY29uc2lkZXJlZCB1bnNhZmUuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcclxuXHR2YXIgcmVzaXplciA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SKTtcclxuXHR2YXIgZXhwYW5kID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IgKyAnLWV4cGFuZCcpO1xyXG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XHJcblxyXG5cdGV4cGFuZC5hcHBlbmRDaGlsZChjcmVhdGVEaXYoKSk7XHJcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcclxuXHJcblx0cmVzaXplci5hcHBlbmRDaGlsZChleHBhbmQpO1xyXG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcclxuXHRyZXNpemVyLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0ZXhwYW5kLnNjcm9sbExlZnQgPSBtYXhTaXplO1xyXG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XHJcblx0XHRzaHJpbmsuc2Nyb2xsTGVmdCA9IG1heFNpemU7XHJcblx0XHRzaHJpbmsuc2Nyb2xsVG9wID0gbWF4U2l6ZTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25TY3JvbGwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XHJcblx0XHRoYW5kbGVyKCk7XHJcblx0fTtcclxuXHJcblx0YWRkTGlzdGVuZXIoZXhwYW5kLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChleHBhbmQsICdleHBhbmQnKSk7XHJcblx0YWRkTGlzdGVuZXIoc2hyaW5rLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChzaHJpbmssICdzaHJpbmsnKSk7XHJcblxyXG5cdHJldHVybiByZXNpemVyO1xyXG59XHJcblxyXG4vLyBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cclxuZnVuY3Rpb24gd2F0Y2hGb3JSZW5kZXIobm9kZSwgaGFuZGxlcikge1xyXG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xyXG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHkgPSBmdW5jdGlvbihlKSB7XHJcblx0XHRpZiAoZS5hbmltYXRpb25OYW1lID09PSBDU1NfUkVOREVSX0FOSU1BVElPTikge1xyXG5cdFx0XHRoYW5kbGVyKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0YWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyAjNDczNzogQ2hyb21lIG1pZ2h0IHNraXAgdGhlIENTUyBhbmltYXRpb24gd2hlbiB0aGUgQ1NTX1JFTkRFUl9NT05JVE9SIGNsYXNzXHJcblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcclxuXHQvLyBgb2Zmc2V0UGFyZW50YCBwcm9wZXJ0eSB3aWxsIGZvcmNlIGEgcmVmbG93IGFuZCByZS1ldmFsdWF0ZSB0aGUgQ1NTIGFuaW1hdGlvbi5cclxuXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNWQ1MmZiMDgxYjM1NzBjODFlM2EjYm94LW1ldHJpY3NcclxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xyXG5cdGV4cGFuZG8ucmVmbG93ID0gISFub2RlLm9mZnNldFBhcmVudDtcclxuXHJcblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xyXG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XHJcblx0dmFyIHByb3h5ID0gZXhwYW5kby5yZW5kZXJQcm94eTtcclxuXHJcblx0aWYgKHByb3h5KSB7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChBTklNQVRJT05fU1RBUlRfRVZFTlRTLCBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xyXG5cdH1cclxuXHJcblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xyXG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xyXG5cclxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cclxuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplciA9IGNyZWF0ZVJlc2l6ZXIodGhyb3R0bGVkKGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xyXG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcclxuXHRcdFx0dmFyIHcgPSBjb250YWluZXIgPyBjb250YWluZXIuY2xpZW50V2lkdGggOiAwO1xyXG5cdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcclxuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xyXG5cdFx0XHRcdC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXHJcblx0XHRcdFx0Ly8gc2Nyb2xsYmFyIGFwcGVhcmVkLiBTbyB3ZSByZXNpemUgYWdhaW4gd2l0aCB0aGUgc2Nyb2xsYmFyIHZpc2libGUgLVxyXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cclxuXHRcdFx0XHQvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcclxuXHRcdFx0XHQvLyBldmVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgd2hvbGUgMiByZXNpemUgcHJvY2Vzcy5cclxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXHJcblx0XHRcdFx0Ly8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxyXG5cdFx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSkpO1xyXG5cclxuXHQvLyBUaGUgcmVzaXplciBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZSBwYXJlbnQsIHNvIHdlIGZpcnN0IG5lZWQgdG8gYmVcclxuXHQvLyBzdXJlIHRoYXQgYG5vZGVgIGlzIGF0dGFjaGVkIHRvIHRoZSBET00gYmVmb3JlIGluamVjdGluZyB0aGUgcmVzaXplciBlbGVtZW50LlxyXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xyXG5cdFx0XHR2YXIgY29udGFpbmVyID0gbm9kZS5wYXJlbnROb2RlO1xyXG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XHJcblx0XHRcdFx0Y29udGFpbmVyLmluc2VydEJlZm9yZShyZXNpemVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRoZSBjb250YWluZXIgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQsIGxldCdzIHJlc2V0IHRoZSByZXNpemVyIHN0YXRlLlxyXG5cdFx0XHRyZXNpemVyLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihub2RlKSB7XHJcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCB7fTtcclxuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcclxuXHJcblx0ZGVsZXRlIGV4cGFuZG8ucmVzaXplcjtcclxuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xyXG5cclxuXHRpZiAocmVzaXplciAmJiByZXNpemVyLnBhcmVudE5vZGUpIHtcclxuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbmplY3RzIENTUyBzdHlsZXMgaW5saW5lIGlmIHRoZSBzdHlsZXMgYXJlIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAqIEBwYXJhbSB7SFRNTERvY3VtZW50fFNoYWRvd1Jvb3R9IHJvb3ROb2RlIC0gdGhlIG5vZGUgdG8gY29udGFpbiB0aGUgPHN0eWxlPi5cclxuICogQHBhcmFtIHtzdHJpbmd9IGNzcyAtIHRoZSBDU1MgdG8gYmUgaW5qZWN0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmplY3RDU1Mocm9vdE5vZGUsIGNzcykge1xyXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTIyMTM5XHJcblx0dmFyIGV4cGFuZG8gPSByb290Tm9kZVtFWFBBTkRPX0tFWV0gfHwgKHJvb3ROb2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcclxuXHRpZiAoIWV4cGFuZG8uY29udGFpbnNTdHlsZXMpIHtcclxuXHRcdGV4cGFuZG8uY29udGFpbnNTdHlsZXMgPSB0cnVlO1xyXG5cdFx0Y3NzID0gJy8qIENoYXJ0LmpzICovXFxuJyArIGNzcztcclxuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcclxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdFx0cm9vdE5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xyXG5cdH1cclxufVxyXG5cclxudmFyIHBsYXRmb3JtX2RvbSQyID0ge1xyXG5cdC8qKlxyXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xyXG5cdCAqIGNvcnJlY3RseSBkZXRlY3Qgd2hlbiB0aGUgY2hhcnQgaXMgYWRkZWQgdG8gdGhlIERPTSBhbmQgdGhlbiByZXNpemVkLiBUaGlzXHJcblx0ICogc3dpdGNoIGhhcyBiZWVuIGFkZGVkIHRvIGFsbG93IGV4dGVybmFsIHN0eWxlc2hlZXQgKGBkaXN0L0NoYXJ0KC5taW4pPy5qc2ApXHJcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXHJcblx0ICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MjA4XHJcblx0ICovXHJcblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxyXG5cdCAqIEN1cnJlbnRseSB1c2VkIGJ5IHBsYXRmb3JtLmpzIHRvIHNlbGVjdCB0aGUgcHJvcGVyIGltcGxlbWVudGF0aW9uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2VuYWJsZWQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHJlc291cmNlcyB0aGF0IGRlcGVuZCBvbiBwbGF0Zm9ybSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBDYW52YXMgZWxlbWVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9lbnN1cmVMb2FkZWQ6IGZ1bmN0aW9uKGNhbnZhcykge1xyXG5cdFx0aWYgKCF0aGlzLmRpc2FibGVDU1NJbmplY3Rpb24pIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGNhbnZhcyBpcyBpbiBhIHNoYWRvdyBET00sIHRoZW4gdGhlIHN0eWxlcyBtdXN0IGFsc28gYmUgaW5zZXJ0ZWRcclxuXHRcdFx0Ly8gaW50byB0aGUgc2FtZSBzaGFkb3cgRE9NLlxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTc2M1xyXG5cdFx0XHR2YXIgcm9vdCA9IGNhbnZhcy5nZXRSb290Tm9kZSA/IGNhbnZhcy5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XHJcblx0XHRcdHZhciB0YXJnZXROb2RlID0gcm9vdC5ob3N0ID8gcm9vdCA6IGRvY3VtZW50LmhlYWQ7XHJcblx0XHRcdGluamVjdENTUyh0YXJnZXROb2RlLCBzdHlsZXNoZWV0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XHJcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcclxuXHRcdH0gZWxzZSBpZiAoaXRlbS5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXHJcblx0XHRcdGl0ZW0gPSBpdGVtWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XHJcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxyXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxyXG5cdFx0Ly8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XHJcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcclxuXHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcclxuXHRcdC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXHJcblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcclxuXHRcdGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBpdGVtKSB7XHJcblx0XHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXHJcblx0XHRcdC8vIGltcG9ydCB0aGUgbGlicmFyeSBiZWZvcmUgc2V0dGluZyBwbGF0Zm9ybSBvcHRpb25zLlxyXG5cdFx0XHR0aGlzLl9lbnN1cmVMb2FkZWQoaXRlbSk7XHJcblx0XHRcdGluaXRDYW52YXMoaXRlbSwgY29uZmlnKTtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcclxuXHRcdGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XHJcblx0XHRbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xyXG5cdFx0XHR2YXIgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xyXG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XHJcblx0XHRcdFx0Y2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goaW5pdGlhbC5zdHlsZSB8fCB7fSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG5cdFx0XHRjYW52YXMuc3R5bGVba2V5XSA9IHZhbHVlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXHJcblx0XHQvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcclxuXHRcdC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXHJcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XHJcblxyXG5cdFx0ZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XHJcblx0fSxcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XHJcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdGFkZFJlc2l6ZUxpc3RlbmVyKGNhbnZhcywgbGlzdGVuZXIsIGNoYXJ0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IChsaXN0ZW5lcltFWFBBTkRPX0tFWV0gPSB7fSk7XHJcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCAoZXhwYW5kby5wcm94aWVzID0ge30pO1xyXG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0bGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcclxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XHJcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcclxuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cclxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IHt9O1xyXG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwge307XHJcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XHJcblx0XHRpZiAoIXByb3h5KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRyZW1vdmVMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cclxuICogRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzJDEuYWRkRXZlbnQgPSBhZGRMaXN0ZW5lcjtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cclxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L3JlbW92ZUV2ZW50TGlzdGVuZXJcclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMucmVtb3ZlRXZlbnRcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzJDEucmVtb3ZlRXZlbnQgPSByZW1vdmVMaXN0ZW5lcjtcblxuLy8gQFRPRE8gTWFrZSBwb3NzaWJsZSB0byBzZWxlY3QgYW5vdGhlciBwbGF0Zm9ybSBhdCBidWlsZCB0aW1lLlxyXG52YXIgaW1wbGVtZW50YXRpb24gPSBwbGF0Zm9ybV9kb20kMi5fZW5hYmxlZCA/IHBsYXRmb3JtX2RvbSQyIDogcGxhdGZvcm1fYmFzaWM7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBDaGFydC5wbGF0Zm9ybVxyXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXHJcbiAqIEBzaW5jZSAyLjQuMFxyXG4gKi9cclxudmFyIHBsYXRmb3JtID0gaGVscGVycyQxLmV4dGVuZCh7XHJcblx0LyoqXHJcblx0ICogQHNpbmNlIDIuNy4wXHJcblx0ICovXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xyXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxyXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZCBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbigpIHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XHJcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXHJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2VcclxuXHQgKi9cclxuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3JcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXHJcblx0ICogdGhlIHtAbGluayBJRXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxyXG5cdCAqL1xyXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXHJcblx0ICovXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxyXG5cclxufSwgaW1wbGVtZW50YXRpb24pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRwbHVnaW5zOiB7fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcGx1Z2luIHNlcnZpY2Ugc2luZ2xldG9uXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGx1Z2luc1xyXG4gKiBAc2luY2UgMi4xLjBcclxuICovXHJcbnZhciBjb3JlX3BsdWdpbnMgPSB7XHJcblx0LyoqXHJcblx0ICogR2xvYmFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3BsdWdpbnM6IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XHJcblx0ICogd2hlbiBhIGdsb2JhbCBwbHVnaW4gaXMgcmVnaXN0ZXJlZCBvciB1bnJlZ2lzdGVyZWQuIEluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIElEIGlzXHJcblx0ICogaW5jcmVtZW50ZWQgYW5kIGRlc2NyaXB0b3JzIGFyZSByZWdlbmVyYXRlZCBkdXJpbmcgZm9sbG93aW5nIEFQSSBjYWxscy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jYWNoZUlkOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLlxyXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxyXG5cdCAqL1xyXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XHJcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xyXG5cdFx0XHRpZiAocC5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XHJcblx0XHRcdFx0cC5wdXNoKHBsdWdpbik7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuX2NhY2hlSWQrKztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIG9ubHkgaWYgcmVnaXN0ZXJlZC5cclxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cclxuXHQgKi9cclxuXHR1bnJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XHJcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XHJcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xyXG5cdFx0XHR2YXIgaWR4ID0gcC5pbmRleE9mKHBsdWdpbik7XHJcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XHJcblx0XHRcdFx0cC5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxyXG5cdCAqIEBzaW5jZSAyLjEuNVxyXG5cdCAqL1xyXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcclxuXHRcdHRoaXMuX2NhY2hlSWQrKztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVnaXN0ZXJlZCBwbHVnaW5zP1xyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHNpbmNlIDIuMS41XHJcblx0ICovXHJcblx0Y291bnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnMubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cclxuXHQgKiBAcmV0dXJucyB7SVBsdWdpbltdfSBhcnJheSBvZiBwbHVnaW4gb2JqZWN0cy5cclxuXHQgKiBAc2luY2UgMi4xLjVcclxuXHQgKi9cclxuXHRnZXRBbGw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcclxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXHJcblx0ICovXHJcblx0bm90aWZ5OiBmdW5jdGlvbihjaGFydCwgaG9vaywgYXJncykge1xyXG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XHJcblx0XHR2YXIgaWxlbiA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcclxuXHRcdHZhciBpLCBkZXNjcmlwdG9yLCBwbHVnaW4sIHBhcmFtcywgbWV0aG9kO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0ZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2ldO1xyXG5cdFx0XHRwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcclxuXHRcdFx0bWV0aG9kID0gcGx1Z2luW2hvb2tdO1xyXG5cdFx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xyXG5cdFx0XHRcdHBhcmFtcy5wdXNoKGRlc2NyaXB0b3Iub3B0aW9ucyk7XHJcblx0XHRcdFx0aWYgKG1ldGhvZC5hcHBseShwbHVnaW4sIHBhcmFtcykgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0W119IFt7IHBsdWdpbiwgb3B0aW9ucyB9XVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHR2YXIgY2FjaGUgPSBjaGFydC4kcGx1Z2lucyB8fCAoY2hhcnQuJHBsdWdpbnMgPSB7fSk7XHJcblx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcclxuXHRcdFx0cmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwbHVnaW5zID0gW107XHJcblx0XHR2YXIgZGVzY3JpcHRvcnMgPSBbXTtcclxuXHRcdHZhciBjb25maWcgPSAoY2hhcnQgJiYgY2hhcnQuY29uZmlnKSB8fCB7fTtcclxuXHRcdHZhciBvcHRpb25zID0gKGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMpIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xyXG5cdFx0XHR2YXIgaWR4ID0gcGx1Z2lucy5pbmRleE9mKHBsdWdpbik7XHJcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XHJcblx0XHRcdHZhciBvcHRzID0gb3B0aW9uc1tpZF07XHJcblx0XHRcdGlmIChvcHRzID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcclxuXHRcdFx0XHRvcHRzID0gaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZ2xvYmFsLnBsdWdpbnNbaWRdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGx1Z2lucy5wdXNoKHBsdWdpbik7XHJcblx0XHRcdGRlc2NyaXB0b3JzLnB1c2goe1xyXG5cdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxyXG5cdFx0XHRcdG9wdGlvbnM6IG9wdHMgfHwge31cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjYWNoZS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xyXG5cdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xyXG5cdFx0cmV0dXJuIGRlc2NyaXB0b3JzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEludmFsaWRhdGVzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY2hhcnQ6IGRlc2NyaXB0b3JzIGhvbGQgYSByZWZlcmVuY2Ugb24gcGx1Z2luIG9wdGlvbixcclxuXHQgKiBidXQgaW4gc29tZSBjYXNlcywgdGhpcyByZWZlcmVuY2UgY2FuIGJlIGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiB1cGRhdGluZyBvcHRpb25zLlxyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9pbnZhbGlkYXRlOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0ZGVsZXRlIGNoYXJ0LiRwbHVnaW5zO1xyXG5cdH1cclxufTtcblxudmFyIGNvcmVfc2NhbGVTZXJ2aWNlID0ge1xyXG5cdC8vIFNjYWxlIHJlZ2lzdHJhdGlvbiBvYmplY3QuIEV4dGVuc2lvbnMgY2FuIHJlZ2lzdGVyIG5ldyBzY2FsZSB0eXBlcyAoc3VjaCBhcyBsb2cgb3IgREIgc2NhbGVzKSBhbmQgdGhlblxyXG5cdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxyXG5cdGNvbnN0cnVjdG9yczoge30sXHJcblx0Ly8gVXNlIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIG1vdmUgdG8gYW4gRVM2IG1hcCB3aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHN1cHBvcnRcclxuXHQvLyBvbGQgYnJvd3NlcnNcclxuXHJcblx0Ly8gU2NhbGUgY29uZmlnIGRlZmF1bHRzXHJcblx0ZGVmYXVsdHM6IHt9LFxyXG5cdHJlZ2lzdGVyU2NhbGVUeXBlOiBmdW5jdGlvbih0eXBlLCBzY2FsZUNvbnN0cnVjdG9yLCBzY2FsZURlZmF1bHRzKSB7XHJcblx0XHR0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA9IHNjYWxlQ29uc3RydWN0b3I7XHJcblx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xyXG5cdH0sXHJcblx0Z2V0U2NhbGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XHJcblx0fSxcclxuXHRnZXRTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xyXG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkgPyBoZWxwZXJzJDEubWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW2NvcmVfZGVmYXVsdHMuc2NhbGUsIHRoaXMuZGVmYXVsdHNbdHlwZV1dKSA6IHt9O1xyXG5cdH0sXHJcblx0dXBkYXRlU2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSwgYWRkaXRpb25zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XHJcblx0XHRcdG1lLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmV4dGVuZChtZS5kZWZhdWx0c1t0eXBlXSwgYWRkaXRpb25zKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdGFkZFNjYWxlc1RvTGF5b3V0OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0Ly8gQWRkcyBlYWNoIHNjYWxlIHRvIHRoZSBjaGFydC5ib3hlcyBhcnJheSB0byBiZSBzaXplZCBhY2NvcmRpbmdseVxyXG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xyXG5cdFx0XHQvLyBTZXQgSUxheW91dEl0ZW0gcGFyYW1ldGVycyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0c2NhbGUuZnVsbFdpZHRoID0gc2NhbGUub3B0aW9ucy5mdWxsV2lkdGg7XHJcblx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdFx0c2NhbGUud2VpZ2h0ID0gc2NhbGUub3B0aW9ucy53ZWlnaHQ7XHJcblx0XHRcdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHNjYWxlKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDggPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcbnZhciBnZXRSdGxIZWxwZXIgPSBoZWxwZXJzJDEucnRsLmdldFJ0bEFkYXB0ZXI7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHR0b29sdGlwczoge1xyXG5cdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdGN1c3RvbTogbnVsbCxcclxuXHRcdG1vZGU6ICduZWFyZXN0JyxcclxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXHJcblx0XHRpbnRlcnNlY3Q6IHRydWUsXHJcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxyXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcclxuXHRcdHRpdGxlU3BhY2luZzogMixcclxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiA2LFxyXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcclxuXHRcdHRpdGxlQWxpZ246ICdsZWZ0JyxcclxuXHRcdGJvZHlTcGFjaW5nOiAyLFxyXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxyXG5cdFx0Ym9keUFsaWduOiAnbGVmdCcsXHJcblx0XHRmb290ZXJGb250U3R5bGU6ICdib2xkJyxcclxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXHJcblx0XHRmb290ZXJNYXJnaW5Ub3A6IDYsXHJcblx0XHRmb290ZXJGb250Q29sb3I6ICcjZmZmJyxcclxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXHJcblx0XHR5UGFkZGluZzogNixcclxuXHRcdHhQYWRkaW5nOiA2LFxyXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxyXG5cdFx0Y2FyZXRTaXplOiA1LFxyXG5cdFx0Y29ybmVyUmFkaXVzOiA2LFxyXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXHJcblx0XHRkaXNwbGF5Q29sb3JzOiB0cnVlLFxyXG5cdFx0Ym9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuXHRcdGJvcmRlcldpZHRoOiAwLFxyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycyQxLm5vb3AsXHJcblx0XHRcdHRpdGxlOiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcclxuXHRcdFx0XHR2YXIgdGl0bGUgPSAnJztcclxuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XHJcblx0XHRcdFx0dmFyIGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcclxuXHJcblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcclxuXHRcdFx0XHRcdGlmIChpdGVtLmxhYmVsKSB7XHJcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS5sYWJlbDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXRlbS54TGFiZWwpIHtcclxuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtLnhMYWJlbDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGl0bGU7XHJcblx0XHRcdH0sXHJcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXHJcblx0XHRcdGJlZm9yZUJvZHk6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcclxuXHRcdFx0YmVmb3JlTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxyXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcclxuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XHJcblxyXG5cdFx0XHRcdGlmIChsYWJlbCkge1xyXG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0b29sdGlwSXRlbS52YWx1ZSkpIHtcclxuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS55TGFiZWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBsYWJlbDtcclxuXHRcdFx0fSxcclxuXHRcdFx0bGFiZWxDb2xvcjogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGNoYXJ0KSB7XHJcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xyXG5cdFx0XHRcdHZhciBhY3RpdmVFbGVtZW50ID0gbWV0YS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcclxuXHRcdFx0XHR2YXIgdmlldyA9IGFjdGl2ZUVsZW1lbnQuX3ZpZXc7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiB2aWV3LmJvcmRlckNvbG9yLFxyXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiB2aWV3LmJhY2tncm91bmRDb2xvclxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0sXHJcblx0XHRcdGxhYmVsVGV4dENvbG9yOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5ib2R5Rm9udENvbG9yO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxyXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXHJcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycyQxLm5vb3AsXHJcblx0XHRcdGZvb3RlcjogaGVscGVycyQxLm5vb3AsXHJcblx0XHRcdGFmdGVyRm9vdGVyOiBoZWxwZXJzJDEubm9vcFxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgcG9zaXRpb25lcnMgPSB7XHJcblx0LyoqXHJcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cclxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXHJcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydEVsZW1lbnRbXX0gdGhlIGVsZW1lbnRzIGJlaW5nIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgcG9zaXRpb25cclxuXHQgKi9cclxuXHRhdmVyYWdlOiBmdW5jdGlvbihlbGVtZW50cykge1xyXG5cdFx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblx0XHR2YXIgeCA9IDA7XHJcblx0XHR2YXIgeSA9IDA7XHJcblx0XHR2YXIgY291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xyXG5cdFx0XHRpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcclxuXHRcdFx0XHR4ICs9IHBvcy54O1xyXG5cdFx0XHRcdHkgKz0gcG9zLnk7XHJcblx0XHRcdFx0Kytjb3VudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHggLyBjb3VudCxcclxuXHRcdFx0eTogeSAvIGNvdW50XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxyXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3RcclxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcclxuXHQgKiBAcGFyYW0gZXZlbnRQb3NpdGlvbiB7b2JqZWN0fSB0aGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IGluIGNhbnZhcyBjb29yZGluYXRlc1xyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0b29sdGlwIHBvc2l0aW9uXHJcblx0ICovXHJcblx0bmVhcmVzdDogZnVuY3Rpb24oZWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcclxuXHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xyXG5cdFx0dmFyIHkgPSBldmVudFBvc2l0aW9uLnk7XHJcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcclxuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHR2YXIgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcclxuXHRcdFx0XHR2YXIgZCA9IGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcclxuXHJcblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0YW5jZSkge1xyXG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xyXG5cdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmVhcmVzdEVsZW1lbnQpIHtcclxuXHRcdFx0dmFyIHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XHJcblx0XHRcdHggPSB0cC54O1xyXG5cdFx0XHR5ID0gdHAueTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5XHJcblx0XHR9O1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcclxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xyXG5cdGlmICh0b1B1c2gpIHtcclxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0b1B1c2gpKSB7XHJcblx0XHRcdC8vIGJhc2UgPSBiYXNlLmNvbmNhdCh0b1B1c2gpO1xyXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YmFzZS5wdXNoKHRvUHVzaCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gYmFzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcclxuXHRpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcclxuXHRcdHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3RyO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIHRoZSBjaGFydCBlbGVtZW50IChwb2ludCwgYXJjLCBiYXIpIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxyXG4gKiBAcmV0dXJuIG5ldyB0b29sdGlwIGl0ZW1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGVsZW1lbnQpIHtcclxuXHR2YXIgeFNjYWxlID0gZWxlbWVudC5feFNjYWxlO1xyXG5cdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXHJcblx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XHJcblx0dmFyIGRhdGFzZXRJbmRleCA9IGVsZW1lbnQuX2RhdGFzZXRJbmRleDtcclxuXHR2YXIgY29udHJvbGxlciA9IGVsZW1lbnQuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcclxuXHR2YXIgaW5kZXhTY2FsZSA9IGNvbnRyb2xsZXIuX2dldEluZGV4U2NhbGUoKTtcclxuXHR2YXIgdmFsdWVTY2FsZSA9IGNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHhMYWJlbDogeFNjYWxlID8geFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcclxuXHRcdHlMYWJlbDogeVNjYWxlID8geVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcclxuXHRcdGxhYmVsOiBpbmRleFNjYWxlID8gJycgKyBpbmRleFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcclxuXHRcdHZhbHVlOiB2YWx1ZVNjYWxlID8gJycgKyB2YWx1ZVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcclxuXHRcdGluZGV4OiBpbmRleCxcclxuXHRcdGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LFxyXG5cdFx0eDogZWxlbWVudC5fbW9kZWwueCxcclxuXHRcdHk6IGVsZW1lbnQuX21vZGVsLnlcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCB0aGUgcmVzZXQgbW9kZWwgZm9yIHRoZSB0b29sdGlwXHJcbiAqIEBwYXJhbSB0b29sdGlwT3B0cyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCYXNlTW9kZWwodG9vbHRpcE9wdHMpIHtcclxuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIFBvc2l0aW9uaW5nXHJcblx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXHJcblx0XHR5UGFkZGluZzogdG9vbHRpcE9wdHMueVBhZGRpbmcsXHJcblx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcclxuXHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxyXG5cclxuXHRcdC8vIERyYXdpbmcgZGlyZWN0aW9uIGFuZCB0ZXh0IGRpcmVjdGlvblxyXG5cdFx0cnRsOiB0b29sdGlwT3B0cy5ydGwsXHJcblx0XHR0ZXh0RGlyZWN0aW9uOiB0b29sdGlwT3B0cy50ZXh0RGlyZWN0aW9uLFxyXG5cclxuXHRcdC8vIEJvZHlcclxuXHRcdGJvZHlGb250Q29sb3I6IHRvb2x0aXBPcHRzLmJvZHlGb250Q29sb3IsXHJcblx0XHRfYm9keUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuYm9keUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcclxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxyXG5cdFx0X2JvZHlBbGlnbjogdG9vbHRpcE9wdHMuYm9keUFsaWduLFxyXG5cdFx0Ym9keUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmJvZHlGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcclxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcclxuXHJcblx0XHQvLyBUaXRsZVxyXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxyXG5cdFx0X3RpdGxlRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy50aXRsZUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcclxuXHRcdF90aXRsZUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy50aXRsZUZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXHJcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXHJcblx0XHRfdGl0bGVBbGlnbjogdG9vbHRpcE9wdHMudGl0bGVBbGlnbixcclxuXHRcdHRpdGxlU3BhY2luZzogdG9vbHRpcE9wdHMudGl0bGVTcGFjaW5nLFxyXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxyXG5cclxuXHRcdC8vIEZvb3RlclxyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXHJcblx0XHRfZm9vdGVyRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5mb290ZXJGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXHJcblx0XHRfZm9vdGVyRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXHJcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcclxuXHRcdF9mb290ZXJBbGlnbjogdG9vbHRpcE9wdHMuZm9vdGVyQWxpZ24sXHJcblx0XHRmb290ZXJTcGFjaW5nOiB0b29sdGlwT3B0cy5mb290ZXJTcGFjaW5nLFxyXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXHJcblxyXG5cdFx0Ly8gQXBwZWFyYW5jZVxyXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXHJcblx0XHRjb3JuZXJSYWRpdXM6IHRvb2x0aXBPcHRzLmNvcm5lclJhZGl1cyxcclxuXHRcdGJhY2tncm91bmRDb2xvcjogdG9vbHRpcE9wdHMuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0b3BhY2l0eTogMCxcclxuXHRcdGxlZ2VuZENvbG9yQmFja2dyb3VuZDogdG9vbHRpcE9wdHMubXVsdGlLZXlCYWNrZ3JvdW5kLFxyXG5cdFx0ZGlzcGxheUNvbG9yczogdG9vbHRpcE9wdHMuZGlzcGxheUNvbG9ycyxcclxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcclxuXHRcdGJvcmRlcldpZHRoOiB0b29sdGlwT3B0cy5ib3JkZXJXaWR0aFxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcclxuICovXHJcbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG1vZGVsKSB7XHJcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcclxuXHJcblx0dmFyIGhlaWdodCA9IG1vZGVsLnlQYWRkaW5nICogMjsgLy8gVG9vbHRpcCBQYWRkaW5nXHJcblx0dmFyIHdpZHRoID0gMDtcclxuXHJcblx0Ly8gQ291bnQgb2YgYWxsIGxpbmVzIGluIHRoZSBib2R5XHJcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xyXG5cdHZhciBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZShmdW5jdGlvbihjb3VudCwgYm9keUl0ZW0pIHtcclxuXHRcdHJldHVybiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGg7XHJcblx0fSwgMCk7XHJcblx0Y29tYmluZWRCb2R5TGVuZ3RoICs9IG1vZGVsLmJlZm9yZUJvZHkubGVuZ3RoICsgbW9kZWwuYWZ0ZXJCb2R5Lmxlbmd0aDtcclxuXHJcblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xyXG5cdHZhciBmb290ZXJMaW5lQ291bnQgPSBtb2RlbC5mb290ZXIubGVuZ3RoO1xyXG5cdHZhciB0aXRsZUZvbnRTaXplID0gbW9kZWwudGl0bGVGb250U2l6ZTtcclxuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xyXG5cdHZhciBmb290ZXJGb250U2l6ZSA9IG1vZGVsLmZvb3RlckZvbnRTaXplO1xyXG5cclxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xyXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/ICh0aXRsZUxpbmVDb3VudCAtIDEpICogbW9kZWwudGl0bGVTcGFjaW5nIDogMDsgLy8gVGl0bGUgTGluZSBTcGFjaW5nXHJcblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ID8gbW9kZWwudGl0bGVNYXJnaW5Cb3R0b20gOiAwOyAvLyBUaXRsZSdzIGJvdHRvbSBNYXJnaW5cclxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXHJcblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCA/IChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG1vZGVsLmJvZHlTcGFjaW5nIDogMDsgLy8gQm9keSBMaW5lIFNwYWNpbmdcclxuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gbW9kZWwuZm9vdGVyTWFyZ2luVG9wIDogMDsgLy8gRm9vdGVyIE1hcmdpblxyXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcclxuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gKGZvb3RlckxpbmVDb3VudCAtIDEpICogbW9kZWwuZm9vdGVyU3BhY2luZyA6IDA7IC8vIEZvb3RlciBMaW5lIFNwYWNpbmdcclxuXHJcblx0Ly8gVGl0bGUgd2lkdGhcclxuXHR2YXIgd2lkdGhQYWRkaW5nID0gMDtcclxuXHR2YXIgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcclxuXHR9O1xyXG5cclxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XHJcblx0aGVscGVycyQxLmVhY2gobW9kZWwudGl0bGUsIG1heExpbmVXaWR0aCk7XHJcblxyXG5cdC8vIEJvZHkgd2lkdGhcclxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgbW9kZWwuX2JvZHlGb250U3R5bGUsIG1vZGVsLl9ib2R5Rm9udEZhbWlseSk7XHJcblx0aGVscGVycyQxLmVhY2gobW9kZWwuYmVmb3JlQm9keS5jb25jYXQobW9kZWwuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcclxuXHJcblx0Ly8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XHJcblx0d2lkdGhQYWRkaW5nID0gbW9kZWwuZGlzcGxheUNvbG9ycyA/IChib2R5Rm9udFNpemUgKyAyKSA6IDA7XHJcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcclxuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xyXG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XHJcblx0fSk7XHJcblxyXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxyXG5cdHdpZHRoUGFkZGluZyA9IDA7XHJcblxyXG5cdC8vIEZvb3RlciB3aWR0aFxyXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoZm9vdGVyRm9udFNpemUsIG1vZGVsLl9mb290ZXJGb250U3R5bGUsIG1vZGVsLl9mb290ZXJGb250RmFtaWx5KTtcclxuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5mb290ZXIsIG1heExpbmVXaWR0aCk7XHJcblxyXG5cdC8vIEFkZCBwYWRkaW5nXHJcblx0d2lkdGggKz0gMiAqIG1vZGVsLnhQYWRkaW5nO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0aGVpZ2h0OiBoZWlnaHRcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCB0aGUgYWxpZ25tZW50IG9mIGEgdG9vbHRpcCBnaXZlbiB0aGUgc2l6ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KHRvb2x0aXAsIHNpemUpIHtcclxuXHR2YXIgbW9kZWwgPSB0b29sdGlwLl9tb2RlbDtcclxuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcclxuXHR2YXIgY2hhcnRBcmVhID0gdG9vbHRpcC5fY2hhcnQuY2hhcnRBcmVhO1xyXG5cdHZhciB4QWxpZ24gPSAnY2VudGVyJztcclxuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XHJcblxyXG5cdGlmIChtb2RlbC55IDwgc2l6ZS5oZWlnaHQpIHtcclxuXHRcdHlBbGlnbiA9ICd0b3AnO1xyXG5cdH0gZWxzZSBpZiAobW9kZWwueSA+IChjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodCkpIHtcclxuXHRcdHlBbGlnbiA9ICdib3R0b20nO1xyXG5cdH1cclxuXHJcblx0dmFyIGxmLCByZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBsZWZ0LCByaWdodCBhbGlnbm1lbnRcclxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxyXG5cdHZhciB5ZjsgLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSB5IGFsaWdubWVudCBpZiB0aGUgdG9vbHRpcCBnb2VzIG91dHNpZGUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgZWRnZXNcclxuXHR2YXIgbWlkWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xyXG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XHJcblxyXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XHJcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHggPD0gbWlkWDtcclxuXHRcdH07XHJcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0cmV0dXJuIHggPiBtaWRYO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4IDw9IChzaXplLndpZHRoIC8gMik7XHJcblx0XHR9O1xyXG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRcdHJldHVybiB4ID49IChjaGFydC53aWR0aCAtIChzaXplLndpZHRoIC8gMikpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcclxuXHRcdHJldHVybiB4ICsgc2l6ZS53aWR0aCArIG1vZGVsLmNhcmV0U2l6ZSArIG1vZGVsLmNhcmV0UGFkZGluZyA+IGNoYXJ0LndpZHRoO1xyXG5cdH07XHJcblx0b3JmID0gZnVuY3Rpb24oeCkge1xyXG5cdFx0cmV0dXJuIHggLSBzaXplLndpZHRoIC0gbW9kZWwuY2FyZXRTaXplIC0gbW9kZWwuY2FyZXRQYWRkaW5nIDwgMDtcclxuXHR9O1xyXG5cdHlmID0gZnVuY3Rpb24oeSkge1xyXG5cdFx0cmV0dXJuIHkgPD0gbWlkWSA/ICd0b3AnIDogJ2JvdHRvbSc7XHJcblx0fTtcclxuXHJcblx0aWYgKGxmKG1vZGVsLngpKSB7XHJcblx0XHR4QWxpZ24gPSAnbGVmdCc7XHJcblxyXG5cdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdmVyIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjaGFydC4/XHJcblx0XHRpZiAob2xmKG1vZGVsLngpKSB7XHJcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xyXG5cdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XHJcblx0XHR4QWxpZ24gPSAncmlnaHQnO1xyXG5cclxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xyXG5cdFx0aWYgKG9yZihtb2RlbC54KSkge1xyXG5cdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgb3B0cyA9IHRvb2x0aXAuX29wdGlvbnM7XHJcblx0cmV0dXJuIHtcclxuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcclxuXHRcdHlBbGlnbjogb3B0cy55QWxpZ24gPyBvcHRzLnlBbGlnbiA6IHlBbGlnblxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KHZtLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XHJcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxyXG5cdHZhciB4ID0gdm0ueDtcclxuXHR2YXIgeSA9IHZtLnk7XHJcblxyXG5cdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XHJcblx0dmFyIGNhcmV0UGFkZGluZyA9IHZtLmNhcmV0UGFkZGluZztcclxuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xyXG5cdHZhciB4QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xyXG5cdHZhciB5QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xyXG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcclxuXHR2YXIgcmFkaXVzQW5kUGFkZGluZyA9IGNvcm5lclJhZGl1cyArIGNhcmV0UGFkZGluZztcclxuXHJcblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG5cdFx0eCAtPSBzaXplLndpZHRoO1xyXG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xyXG5cdFx0aWYgKHggKyBzaXplLndpZHRoID4gY2hhcnQud2lkdGgpIHtcclxuXHRcdFx0eCA9IGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aDtcclxuXHRcdH1cclxuXHRcdGlmICh4IDwgMCkge1xyXG5cdFx0XHR4ID0gMDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XHJcblx0XHR5ICs9IHBhZGRpbmdBbmRTaXplO1xyXG5cdH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xyXG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR5IC09IChzaXplLmhlaWdodCAvIDIpO1xyXG5cdH1cclxuXHJcblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHR4ICs9IHBhZGRpbmdBbmRTaXplO1xyXG5cdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XHJcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XHJcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuXHRcdHggKz0gcmFkaXVzQW5kUGFkZGluZztcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiB4LFxyXG5cdFx0eTogeVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEFsaWduZWRYKHZtLCBhbGlnbikge1xyXG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcclxuXHRcdD8gdm0ueCArIHZtLndpZHRoIC8gMlxyXG5cdFx0OiBhbGlnbiA9PT0gJ3JpZ2h0J1xyXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXHJcblx0XHRcdDogdm0ueCArIHZtLnhQYWRkaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcclxuXHRyZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XHJcbn1cclxuXHJcbnZhciBleHBvcnRzJDQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuX21vZGVsID0gZ2V0QmFzZU1vZGVsKHRoaXMuX29wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGFzdEFjdGl2ZSA9IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0aGUgdGl0bGVcclxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxyXG5cdGdldFRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xyXG5cdFx0dmFyIGNhbGxiYWNrcyA9IG9wdHMuY2FsbGJhY2tzO1xyXG5cclxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdHZhciB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdHZhciBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0dmFyIGxpbmVzID0gW107XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcclxuXHJcblx0XHRyZXR1cm4gbGluZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcclxuXHRnZXRCZWZvcmVCb2R5OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcclxuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XHJcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcclxuXHRcdFx0XHRiZWZvcmU6IFtdLFxyXG5cdFx0XHRcdGxpbmVzOiBbXSxcclxuXHRcdFx0XHRhZnRlcjogW11cclxuXHRcdFx0fTtcclxuXHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhjYWxsYmFja3MuYmVmb3JlTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XHJcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XHJcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhjYWxsYmFja3MuYWZ0ZXJMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcclxuXHJcblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBib2R5SXRlbXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcclxuXHRnZXRBZnRlckJvZHk6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xyXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXHJcblx0Z2V0Rm9vdGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xyXG5cclxuXHRcdHZhciBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0dmFyIGxpbmVzID0gW107XHJcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcclxuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xyXG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcclxuXHJcblx0XHRyZXR1cm4gbGluZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbihjaGFuZ2VkKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcclxuXHJcblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxyXG5cdFx0Ly8gdGhhdCBkb2VzIF92aWV3ID0gX21vZGVsIGlmIGVhc2UgPT09IDEuIFRoaXMgY2F1c2VzIHRoZSAybmQgdG9vbHRpcCB1cGRhdGUgdG8gc2V0IHByb3BlcnRpZXMgaW4gYm90aCB0aGUgdmlldyBhbmQgbW9kZWwgYXQgdGhlIHNhbWUgdGltZVxyXG5cdFx0Ly8gd2hpY2ggYnJlYWtzIGFueSBhbmltYXRpb25zLlxyXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XHJcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWwgPSBnZXRCYXNlTW9kZWwob3B0cyk7XHJcblx0XHR2YXIgYWN0aXZlID0gbWUuX2FjdGl2ZTtcclxuXHJcblx0XHR2YXIgZGF0YSA9IG1lLl9kYXRhO1xyXG5cclxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXHJcblx0XHR2YXIgYWxpZ25tZW50ID0ge1xyXG5cdFx0XHR4QWxpZ246IGV4aXN0aW5nTW9kZWwueEFsaWduLFxyXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXHJcblx0XHR9O1xyXG5cdFx0dmFyIGJhY2tncm91bmRQb2ludCA9IHtcclxuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxyXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLnlcclxuXHRcdH07XHJcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XHJcblx0XHRcdHdpZHRoOiBleGlzdGluZ01vZGVsLndpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGV4aXN0aW5nTW9kZWwuaGVpZ2h0XHJcblx0XHR9O1xyXG5cdFx0dmFyIHRvb2x0aXBQb3NpdGlvbiA9IHtcclxuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC5jYXJldFgsXHJcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGFjdGl2ZS5sZW5ndGgpIHtcclxuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XHJcblxyXG5cdFx0XHR2YXIgbGFiZWxDb2xvcnMgPSBbXTtcclxuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xyXG5cdFx0XHR0b29sdGlwUG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRzLnBvc2l0aW9uXS5jYWxsKG1lLCBhY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcclxuXHJcblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcblx0XHRcdFx0dG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0oYWN0aXZlW2ldKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgZmlsdGVyIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXHJcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xyXG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoZnVuY3Rpb24oYSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9wdHMuZmlsdGVyKGEsIGRhdGEpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcclxuXHRcdFx0aWYgKG9wdHMuaXRlbVNvcnQpIHtcclxuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcclxuXHRcdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xyXG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XHJcblx0XHRcdFx0bGFiZWxUZXh0Q29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxUZXh0Q29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblxyXG5cdFx0XHQvLyBCdWlsZCB0aGUgVGV4dCBMaW5lc1xyXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XHJcblx0XHRcdG1vZGVsLmJlZm9yZUJvZHkgPSBtZS5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XHJcblx0XHRcdG1vZGVsLmJvZHkgPSBtZS5nZXRCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XHJcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xyXG5cdFx0XHRtb2RlbC5mb290ZXIgPSBtZS5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBkYXRhKTtcclxuXHJcblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xyXG5cdFx0XHRtb2RlbC54ID0gdG9vbHRpcFBvc2l0aW9uLng7XHJcblx0XHRcdG1vZGVsLnkgPSB0b29sdGlwUG9zaXRpb24ueTtcclxuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XHJcblx0XHRcdG1vZGVsLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XHJcblx0XHRcdG1vZGVsLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcclxuXHJcblx0XHRcdC8vIGRhdGEgcG9pbnRzXHJcblx0XHRcdG1vZGVsLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XHJcblxyXG5cdFx0XHQvLyBXZSBuZWVkIHRvIGRldGVybWluZSBhbGlnbm1lbnQgb2YgdGhlIHRvb2x0aXBcclxuXHRcdFx0dG9vbHRpcFNpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBtb2RlbCk7XHJcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XHJcblx0XHRcdC8vIEZpbmFsIFNpemUgYW5kIFBvc2l0aW9uXHJcblx0XHRcdGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChtb2RlbCwgdG9vbHRpcFNpemUsIGFsaWdubWVudCwgbWUuX2NoYXJ0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1vZGVsLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XHJcblx0XHRtb2RlbC55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xyXG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xyXG5cdFx0bW9kZWwueSA9IGJhY2tncm91bmRQb2ludC55O1xyXG5cdFx0bW9kZWwud2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcclxuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcclxuXHJcblx0XHQvLyBQb2ludCB3aGVyZSB0aGUgY2FyZXQgb24gdGhlIHRvb2x0aXAgcG9pbnRzIHRvXHJcblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcclxuXHRcdG1vZGVsLmNhcmV0WSA9IHRvb2x0aXBQb3NpdGlvbi55O1xyXG5cclxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xyXG5cclxuXHRcdGlmIChjaGFuZ2VkICYmIG9wdHMuY3VzdG9tKSB7XHJcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XHJcblxyXG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcclxuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XHJcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xyXG5cdH0sXHJcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xyXG5cdFx0dmFyIHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XHJcblx0XHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xyXG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcclxuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XHJcblx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xyXG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xyXG5cdFx0dmFyIHB0WSA9IHRvb2x0aXBQb2ludC55O1xyXG5cdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcclxuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcclxuXHJcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xyXG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcclxuXHJcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHRcdHgxID0gcHRYO1xyXG5cdFx0XHRcdHgyID0geDEgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MTtcclxuXHJcblx0XHRcdFx0eTEgPSB5MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR5MyA9IHkyIC0gY2FyZXRTaXplO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHgxID0gcHRYICsgd2lkdGg7XHJcblx0XHRcdFx0eDIgPSB4MSArIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR4MyA9IHgxO1xyXG5cclxuXHRcdFx0XHR5MSA9IHkyIC0gY2FyZXRTaXplO1xyXG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG5cdFx0XHRcdHgyID0gcHRYICsgY29ybmVyUmFkaXVzICsgKGNhcmV0U2l6ZSk7XHJcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG5cdFx0XHRcdHgyID0gcHRYICsgd2lkdGggLSBjb3JuZXJSYWRpdXMgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcclxuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xyXG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xyXG5cdFx0XHRcdHkxID0gcHRZO1xyXG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XHJcblx0XHRcdFx0eTMgPSB5MTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcclxuXHRcdFx0XHR5MiA9IHkxICsgY2FyZXRTaXplO1xyXG5cdFx0XHRcdHkzID0geTE7XHJcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcclxuXHRcdFx0XHR2YXIgdG1wID0geDM7XHJcblx0XHRcdFx0eDMgPSB4MTtcclxuXHRcdFx0XHR4MSA9IHRtcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcclxuXHR9LFxyXG5cclxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XHJcblx0XHR2YXIgdGl0bGUgPSB2bS50aXRsZTtcclxuXHRcdHZhciBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XHJcblx0XHR2YXIgdGl0bGVGb250U2l6ZSwgdGl0bGVTcGFjaW5nLCBpO1xyXG5cclxuXHRcdGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlcih2bS5ydGwsIHZtLngsIHZtLndpZHRoKTtcclxuXHJcblx0XHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgdm0uX3RpdGxlQWxpZ24pO1xyXG5cclxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24odm0uX3RpdGxlQWxpZ24pO1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblxyXG5cdFx0XHR0aXRsZUZvbnRTaXplID0gdm0udGl0bGVGb250U2l6ZTtcclxuXHRcdFx0dGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xyXG5cclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLnRpdGxlRm9udENvbG9yO1xyXG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIHZtLl90aXRsZUZvbnRTdHlsZSwgdm0uX3RpdGxlRm9udEZhbWlseSk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250U2l6ZSAvIDIpO1xyXG5cdFx0XHRcdHB0LnkgKz0gdGl0bGVGb250U2l6ZSArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcclxuXHJcblx0XHRcdFx0aWYgKGkgKyAxID09PSBsZW5ndGgpIHtcclxuXHRcdFx0XHRcdHB0LnkgKz0gdm0udGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhd0JvZHk6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XHJcblx0XHR2YXIgYm9keUZvbnRTaXplID0gdm0uYm9keUZvbnRTaXplO1xyXG5cdFx0dmFyIGJvZHlTcGFjaW5nID0gdm0uYm9keVNwYWNpbmc7XHJcblx0XHR2YXIgYm9keUFsaWduID0gdm0uX2JvZHlBbGlnbjtcclxuXHRcdHZhciBib2R5ID0gdm0uYm9keTtcclxuXHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XHJcblx0XHR2YXIgeExpbmVQYWRkaW5nID0gMDtcclxuXHRcdHZhciBjb2xvclggPSBkcmF3Q29sb3JCb3hlcyA/IGdldEFsaWduZWRYKHZtLCAnbGVmdCcpIDogMDtcclxuXHJcblx0XHR2YXIgcnRsSGVscGVyID0gZ2V0UnRsSGVscGVyKHZtLnJ0bCwgdm0ueCwgdm0ud2lkdGgpO1xyXG5cclxuXHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUZvbnRTaXplIC8gMik7XHJcblx0XHRcdHB0LnkgKz0gYm9keUZvbnRTaXplICsgYm9keVNwYWNpbmc7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBib2R5SXRlbSwgdGV4dENvbG9yLCBsYWJlbENvbG9ycywgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XHJcblx0XHR2YXIgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XHJcblxyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCB2bS5fYm9keUZvbnRTdHlsZSwgdm0uX2JvZHlGb250RmFtaWx5KTtcclxuXHJcblx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uKTtcclxuXHJcblx0XHQvLyBCZWZvcmUgYm9keSBsaW5lc1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvZHlGb250Q29sb3I7XHJcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XHJcblxyXG5cdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcclxuXHRcdFx0PyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJvZHlGb250U2l6ZSAvIDIgKyAxKSA6IChib2R5Rm9udFNpemUgKyAyKVxyXG5cdFx0XHQ6IDA7XHJcblxyXG5cdFx0Ly8gRHJhdyBib2R5IGxpbmVzIG5vd1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGJvZHlJdGVtID0gYm9keVtpXTtcclxuXHRcdFx0dGV4dENvbG9yID0gdm0ubGFiZWxUZXh0Q29sb3JzW2ldO1xyXG5cdFx0XHRsYWJlbENvbG9ycyA9IHZtLmxhYmVsQ29sb3JzW2ldO1xyXG5cclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcclxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XHJcblxyXG5cdFx0XHRsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xyXG5cdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcclxuXHRcdFx0XHRpZiAoZHJhd0NvbG9yQm94ZXMpIHtcclxuXHRcdFx0XHRcdHZhciBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdm0ubGVnZW5kQ29sb3JCYWNrZ3JvdW5kO1xyXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm9keUZvbnRTaXplKSwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEJvcmRlclxyXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDE7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm9keUZvbnRTaXplKSwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xyXG5cclxuXHRcdFx0XHRcdC8vIElubmVyIHNxdWFyZVxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm9keUZvbnRTaXplIC0gMiksIHB0LnkgKyAxLCBib2R5Rm9udFNpemUgLSAyLCBib2R5Rm9udFNpemUgLSAyKTtcclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XHJcblx0XHR4TGluZVBhZGRpbmcgPSAwO1xyXG5cclxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcclxuXHRcdGhlbHBlcnMkMS5lYWNoKHZtLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xyXG5cdFx0cHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXHJcblx0fSxcclxuXHJcblx0ZHJhd0Zvb3RlcjogZnVuY3Rpb24ocHQsIHZtLCBjdHgpIHtcclxuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XHJcblx0XHR2YXIgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcclxuXHRcdHZhciBmb290ZXJGb250U2l6ZSwgaTtcclxuXHJcblx0XHRpZiAobGVuZ3RoKSB7XHJcblx0XHRcdHZhciBydGxIZWxwZXIgPSBnZXRSdGxIZWxwZXIodm0ucnRsLCB2bS54LCB2bS53aWR0aCk7XHJcblxyXG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl9mb290ZXJBbGlnbik7XHJcblx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyTWFyZ2luVG9wO1xyXG5cclxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24odm0uX2Zvb3RlckFsaWduKTtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdFx0Zm9vdGVyRm9udFNpemUgPSB2bS5mb290ZXJGb250U2l6ZTtcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XHJcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoZm9vdGVyRm9udFNpemUsIHZtLl9mb290ZXJGb250U3R5bGUsIHZtLl9mb290ZXJGb250RmFtaWx5KTtcclxuXHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udFNpemUgLyAyKTtcclxuXHRcdFx0XHRwdC55ICs9IGZvb3RlckZvbnRTaXplICsgdm0uZm9vdGVyU3BhY2luZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpIHtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcclxuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcclxuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XHJcblx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xyXG5cdFx0dmFyIHggPSBwdC54O1xyXG5cdFx0dmFyIHkgPSBwdC55O1xyXG5cdFx0dmFyIHdpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XHJcblx0XHR2YXIgaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xyXG5cdFx0dmFyIHJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcclxuXHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xyXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcclxuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcclxuXHRcdH1cclxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcclxuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xyXG5cdFx0fVxyXG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xyXG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xyXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcclxuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcclxuXHRcdH1cclxuXHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XHJcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcclxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XHJcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xyXG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XHJcblx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblxyXG5cdFx0Y3R4LmZpbGwoKTtcclxuXHJcblx0XHRpZiAodm0uYm9yZGVyV2lkdGggPiAwKSB7XHJcblx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XHJcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xyXG5cclxuXHRcdGlmICh2bS5vcGFjaXR5ID09PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XHJcblx0XHRcdHdpZHRoOiB2bS53aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiB2bS5oZWlnaHRcclxuXHRcdH07XHJcblx0XHR2YXIgcHQgPSB7XHJcblx0XHRcdHg6IHZtLngsXHJcblx0XHRcdHk6IHZtLnlcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxyXG5cdFx0dmFyIG9wYWNpdHkgPSBNYXRoLmFicyh2bS5vcGFjaXR5IDwgMWUtMykgPyAwIDogdm0ub3BhY2l0eTtcclxuXHJcblx0XHQvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXHJcblx0XHR2YXIgaGFzVG9vbHRpcENvbnRlbnQgPSB2bS50aXRsZS5sZW5ndGggfHwgdm0uYmVmb3JlQm9keS5sZW5ndGggfHwgdm0uYm9keS5sZW5ndGggfHwgdm0uYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB2bS5mb290ZXIubGVuZ3RoO1xyXG5cclxuXHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcclxuXHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuXHJcblx0XHRcdC8vIERyYXcgQmFja2dyb3VuZFxyXG5cdFx0XHR0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCB2bSwgY3R4LCB0b29sdGlwU2l6ZSk7XHJcblxyXG5cdFx0XHQvLyBEcmF3IFRpdGxlLCBCb2R5LCBhbmQgRm9vdGVyXHJcblx0XHRcdHB0LnkgKz0gdm0ueVBhZGRpbmc7XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEucnRsLm92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIHZtLnRleHREaXJlY3Rpb24pO1xyXG5cclxuXHRcdFx0Ly8gVGl0bGVzXHJcblx0XHRcdHRoaXMuZHJhd1RpdGxlKHB0LCB2bSwgY3R4KTtcclxuXHJcblx0XHRcdC8vIEJvZHlcclxuXHRcdFx0dGhpcy5kcmF3Qm9keShwdCwgdm0sIGN0eCk7XHJcblxyXG5cdFx0XHQvLyBGb290ZXJcclxuXHRcdFx0dGhpcy5kcmF3Rm9vdGVyKHB0LCB2bSwgY3R4KTtcclxuXHJcblx0XHRcdGhlbHBlcnMkMS5ydGwucmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCB2bS50ZXh0RGlyZWN0aW9uKTtcclxuXHJcblx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlIGFuIGV2ZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxyXG5cdCAqL1xyXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcclxuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcclxuXHJcblx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcclxuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcclxuXHRcdFx0bWUuX2FjdGl2ZSA9IFtdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XHJcblx0XHRcdGlmIChvcHRpb25zLnJldmVyc2UpIHtcclxuXHRcdFx0XHRtZS5fYWN0aXZlLnJldmVyc2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xyXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuX2FjdGl2ZSwgbWUuX2xhc3RBY3RpdmUpO1xyXG5cclxuXHRcdC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxyXG5cdFx0aWYgKGNoYW5nZWQpIHtcclxuXHRcdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fYWN0aXZlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xyXG5cdFx0XHRcdG1lLl9ldmVudFBvc2l0aW9uID0ge1xyXG5cdFx0XHRcdFx0eDogZS54LFxyXG5cdFx0XHRcdFx0eTogZS55XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xyXG5cdFx0XHRcdG1lLnBpdm90KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2hhbmdlZDtcclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xyXG4gKi9cclxudmFyIHBvc2l0aW9uZXJzXzEgPSBwb3NpdGlvbmVycztcclxuXHJcbnZhciBjb3JlX3Rvb2x0aXAgPSBleHBvcnRzJDQ7XG5jb3JlX3Rvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVyc18xO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkOSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxuXHJcbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xyXG5cdGVsZW1lbnRzOiB7fSxcclxuXHRldmVudHM6IFtcclxuXHRcdCdtb3VzZW1vdmUnLFxyXG5cdFx0J21vdXNlb3V0JyxcclxuXHRcdCdjbGljaycsXHJcblx0XHQndG91Y2hzdGFydCcsXHJcblx0XHQndG91Y2htb3ZlJ1xyXG5cdF0sXHJcblx0aG92ZXI6IHtcclxuXHRcdG9uSG92ZXI6IG51bGwsXHJcblx0XHRtb2RlOiAnbmVhcmVzdCcsXHJcblx0XHRpbnRlcnNlY3Q6IHRydWUsXHJcblx0XHRhbmltYXRpb25EdXJhdGlvbjogNDAwXHJcblx0fSxcclxuXHRvbkNsaWNrOiBudWxsLFxyXG5cdG1haW50YWluQXNwZWN0UmF0aW86IHRydWUsXHJcblx0cmVzcG9uc2l2ZTogdHJ1ZSxcclxuXHRyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb246IDBcclxufSk7XHJcblxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlc2Agb3B0aW9uXHJcbiAqIGJ5IGluY29ycG9yYXRpbmcgc2NhbGUgZGVmYXVsdHMgaW4gYHhBeGVzYCBhbmQgYHlBeGVzYCBhcnJheSBpdGVtcywgdGhlblxyXG4gKiByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSByZXN1bHQsIHRodXMgZG9lc24ndCBhbHRlciBpbnB1dHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xyXG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XHJcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKGtleSA9PT0gJ3hBeGVzJyB8fCBrZXkgPT09ICd5QXhlcycpIHtcclxuXHRcdFx0XHR2YXIgc2xlbiA9IHNvdXJjZVtrZXldLmxlbmd0aDtcclxuXHRcdFx0XHR2YXIgaSwgdHlwZSwgc2NhbGU7XHJcblxyXG5cdFx0XHRcdGlmICghdGFyZ2V0W2tleV0pIHtcclxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XHJcblx0XHRcdFx0XHRzY2FsZSA9IHNvdXJjZVtrZXldW2ldO1xyXG5cdFx0XHRcdFx0dHlwZSA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGUudHlwZSwga2V5ID09PSAneEF4ZXMnID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaSA+PSB0YXJnZXRba2V5XS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0ucHVzaCh7fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XVtpXS50eXBlIHx8IChzY2FsZS50eXBlICYmIHNjYWxlLnR5cGUgIT09IHRhcmdldFtrZXldW2ldLnR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xyXG5cdFx0XHRcdFx0XHQvLyB0aGVuIG1lcmdlIHNvdXJjZSBzY2FsZSB0byBjb3JyZWN0bHkgb3ZlcndyaXRlIHRoZSBkZWZhdWx0cy5cclxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBbY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyh0eXBlKSwgc2NhbGVdKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIHNjYWxlcyB0eXBlIGFyZSB0aGUgc2FtZVxyXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIHNjYWxlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyBhcyB0aGUgcm9vdCBvcHRpb25zIGJ5IGhhbmRsaW5nXHJcbiAqIGRlZmF1bHQgc2NhbGUgb3B0aW9ucyBmb3IgdGhlIGBzY2FsZXNgIGFuZCBgc2NhbGVgIHByb3BlcnRpZXMsIHRoZW4gcmV0dXJuc1xyXG4gKiBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VDb25maWcoLyogY29uZmlnIG9iamVjdHMgLi4uICovKSB7XHJcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcclxuXHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblx0XHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoa2V5ID09PSAnc2NhbGVzJykge1xyXG5cdFx0XHRcdC8vIHNjYWxlIGNvbmZpZyBtZXJnaW5nIGlzIGNvbXBsZXguIEFkZCBvdXIgb3duIGZ1bmN0aW9uIGhlcmUgZm9yIHRoYXRcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlU2NhbGVDb25maWcodHZhbCwgc3ZhbCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2NhbGUnKSB7XHJcblx0XHRcdFx0Ly8gdXNlZCBpbiBwb2xhciBhcmVhICYgcmFkYXIgY2hhcnRzIHNpbmNlIHRoZXJlIGlzIG9ubHkgb25lIHNjYWxlXHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzJDEubWVyZ2UodHZhbCwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XHJcblx0Y29uZmlnID0gY29uZmlnIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5cdC8vIERvIE5PVCB1c2UgbWVyZ2VDb25maWcgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcclxuXHQvLyBhbmQgc28gd291bGQgY2hhbmdlIHJlZmVyZW5jZXMgdG8gbGFiZWxzIGFuZCBkYXRhc2V0cywgcHJldmVudGluZyBkYXRhIHVwZGF0ZXMuXHJcblx0dmFyIGRhdGEgPSBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xyXG5cdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xyXG5cdGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XHJcblxyXG5cdGNvbmZpZy5vcHRpb25zID0gbWVyZ2VDb25maWcoXHJcblx0XHRjb3JlX2RlZmF1bHRzLmdsb2JhbCxcclxuXHRcdGNvcmVfZGVmYXVsdHNbY29uZmlnLnR5cGVdLFxyXG5cdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xyXG5cclxuXHRyZXR1cm4gY29uZmlnO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDb25maWcoY2hhcnQpIHtcclxuXHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XHJcblxyXG5cdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHNjYWxlKTtcclxuXHR9KTtcclxuXHJcblx0bmV3T3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxyXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXHJcblx0XHRjb3JlX2RlZmF1bHRzW2NoYXJ0LmNvbmZpZy50eXBlXSxcclxuXHRcdG5ld09wdGlvbnMpO1xyXG5cclxuXHRjaGFydC5vcHRpb25zID0gY2hhcnQuY29uZmlnLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xyXG5cdGNoYXJ0LmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcclxuXHRjaGFydC5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XHJcblxyXG5cdC8vIFRvb2x0aXBcclxuXHRjaGFydC50b29sdGlwLl9vcHRpb25zID0gbmV3T3B0aW9ucy50b29sdGlwcztcclxuXHRjaGFydC50b29sdGlwLmluaXRpYWxpemUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmV4dEF2YWlsYWJsZVNjYWxlSWQoYXhlc09wdHMsIHByZWZpeCwgaW5kZXgpIHtcclxuXHR2YXIgaWQ7XHJcblx0dmFyIGhhc0lkID0gZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRyZXR1cm4gb2JqLmlkID09PSBpZDtcclxuXHR9O1xyXG5cclxuXHRkbyB7XHJcblx0XHRpZCA9IHByZWZpeCArIGluZGV4Kys7XHJcblx0fSB3aGlsZSAoaGVscGVycyQxLmZpbmRJbmRleChheGVzT3B0cywgaGFzSWQpID49IDApO1xyXG5cclxuXHRyZXR1cm4gaWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uKSB7XHJcblx0cmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhW2wxXSA9PT0gYltsMV1cclxuXHRcdFx0PyBhW2wyXSAtIGJbbDJdXHJcblx0XHRcdDogYVtsMV0gLSBiW2wxXTtcclxuXHR9O1xyXG59XHJcblxyXG52YXIgQ2hhcnQgPSBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcclxuXHR0aGlzLmNvbnN0cnVjdChpdGVtLCBjb25maWcpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y29uc3RydWN0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xyXG5cclxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcclxuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xyXG5cdFx0dmFyIGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xyXG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcclxuXHJcblx0XHRtZS5pZCA9IGhlbHBlcnMkMS51aWQoKTtcclxuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XHJcblx0XHRtZS5jYW52YXMgPSBjYW52YXM7XHJcblx0XHRtZS5jb25maWcgPSBjb25maWc7XHJcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0bWUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0bWUuYXNwZWN0UmF0aW8gPSBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XHJcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XHJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcclxuXHRcdG1lLl9sYXllcnMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBDaGFydCBhbmQgQ2hhcnQuQ29udHJvbGxlciBoYXZlIGJlZW4gbWVyZ2VkLFxyXG5cdFx0ICogdGhlIFwiaW5zdGFuY2VcIiBzdGlsbCBuZWVkIHRvIGJlIGRlZmluZWQgc2luY2UgaXQgbWlnaHQgYmUgY2FsbGVkIGZyb20gcGx1Z2lucy5cclxuXHRcdCAqIEBwcm9wIENoYXJ0I2NoYXJ0XHJcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXHJcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblx0XHRtZS5jaGFydCA9IG1lO1xyXG5cdFx0bWUuY29udHJvbGxlciA9IG1lOyAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cclxuXHJcblx0XHQvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXHJcblx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGFsaWFzIHRvIHRoZSBjb25maWcgZGF0YTogYGNoYXJ0LmRhdGEgPT09IGNoYXJ0LmNvbmZpZy5kYXRhYFxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbWUuY29uZmlnLmRhdGE7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0XHRtZS5jb25maWcuZGF0YSA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xyXG5cdFx0XHQvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcclxuXHRcdFx0Ly8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcclxuXHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5pbml0aWFsaXplKCk7XHJcblx0XHRtZS51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHQvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlSW5pdCcpO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgbWUub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcclxuXHJcblx0XHRtZS5iaW5kRXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG5cdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXHJcblx0XHRcdG1lLnJlc2l6ZSh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5pbml0VG9vbFRpcCgpO1xyXG5cclxuXHRcdC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xyXG5cclxuXHRcdHJldHVybiBtZTtcclxuXHR9LFxyXG5cclxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24oKSB7XHJcblx0XHQvLyBTdG9wcyBhbnkgY3VycmVudCBhbmltYXRpb24gbG9vcCBvY2N1cnJpbmdcclxuXHRcdGNvcmVfYW5pbWF0aW9ucy5jYW5jZWxBbmltYXRpb24odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZXNpemU6IGZ1bmN0aW9uKHNpbGVudCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XHJcblx0XHR2YXIgYXNwZWN0UmF0aW8gPSAob3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG1lLmFzcGVjdFJhdGlvKSB8fCBudWxsO1xyXG5cclxuXHRcdC8vIHRoZSBjYW52YXMgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBjYXN0ZWQgdG8gaW50ZWdlcnMgc28gbWFrZSBzdXJlIHRoYXRcclxuXHRcdC8vIHRoZSBjYW52YXMgZGlzcGxheSBzdHlsZSB1c2VzIHRoZSBzYW1lIGludGVnZXIgdmFsdWVzIHRvIGF2b2lkIGJsdXJyaW5nIGVmZmVjdC5cclxuXHJcblx0XHQvLyBTZXQgdG8gMCBpbnN0ZWFkIG9mIGNhbnZhcy5zaXplIGJlY2F1c2UgdGhlIHNpemUgZGVmYXVsdHMgdG8gMzAweDE1MCBpZiB0aGUgZWxlbWVudCBpcyBjb2xsYXBzZWRcclxuXHRcdHZhciBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoaGVscGVycyQxLmdldE1heGltdW1XaWR0aChjYW52YXMpKSk7XHJcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XHJcblxyXG5cdFx0aWYgKG1lLndpZHRoID09PSBuZXdXaWR0aCAmJiBtZS5oZWlnaHQgPT09IG5ld0hlaWdodCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBtZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcblx0XHRjYW52YXMuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XHJcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcclxuXHJcblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcblxyXG5cdFx0aWYgKCFzaWxlbnQpIHtcclxuXHRcdFx0Ly8gTm90aWZ5IGFueSBwbHVnaW5zIGFib3V0IHRoZSByZXNpemVcclxuXHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XHJcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xyXG5cclxuXHRcdFx0Ly8gTm90aWZ5IG9mIHJlc2l6ZVxyXG5cdFx0XHRpZiAob3B0aW9ucy5vblJlc2l6ZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMub25SZXNpemUobWUsIG5ld1NpemUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZS5zdG9wKCk7XHJcblx0XHRcdG1lLnVwZGF0ZSh7XHJcblx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xyXG5cdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy54QXhlcywgZnVuY3Rpb24oeEF4aXNPcHRpb25zLCBpbmRleCkge1xyXG5cdFx0XHRpZiAoIXhBeGlzT3B0aW9ucy5pZCkge1xyXG5cdFx0XHRcdHhBeGlzT3B0aW9ucy5pZCA9IG5leHRBdmFpbGFibGVTY2FsZUlkKHNjYWxlc09wdGlvbnMueEF4ZXMsICd4LWF4aXMtJywgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnlBeGVzLCBmdW5jdGlvbih5QXhpc09wdGlvbnMsIGluZGV4KSB7XHJcblx0XHRcdGlmICgheUF4aXNPcHRpb25zLmlkKSB7XHJcblx0XHRcdFx0eUF4aXNPcHRpb25zLmlkID0gbmV4dEF2YWlsYWJsZVNjYWxlSWQoc2NhbGVzT3B0aW9ucy55QXhlcywgJ3ktYXhpcy0nLCBpbmRleCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChzY2FsZU9wdGlvbnMpIHtcclxuXHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cclxuXHQgKi9cclxuXHRidWlsZE9yVXBkYXRlU2NhbGVzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgc2NhbGVzID0gbWUuc2NhbGVzIHx8IHt9O1xyXG5cdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHR2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgaWQpIHtcclxuXHRcdFx0b2JqW2lkXSA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fSwge30pO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNjYWxlcykge1xyXG5cdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcclxuXHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeEF4aXNPcHRpb25zLCBkdHlwZTogJ2NhdGVnb3J5JywgZHBvc2l0aW9uOiAnYm90dG9tJ307XHJcblx0XHRcdFx0fSksXHJcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHlBeGlzT3B0aW9ucywgZHR5cGU6ICdsaW5lYXInLCBkcG9zaXRpb246ICdsZWZ0J307XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5zY2FsZSkge1xyXG5cdFx0XHRpdGVtcy5wdXNoKHtcclxuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLnNjYWxlLFxyXG5cdFx0XHRcdGR0eXBlOiAncmFkaWFsTGluZWFyJyxcclxuXHRcdFx0XHRpc0RlZmF1bHQ6IHRydWUsXHJcblx0XHRcdFx0ZHBvc2l0aW9uOiAnY2hhcnRBcmVhJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xyXG5cdFx0XHR2YXIgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XHJcblx0XHRcdHZhciBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ5KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcclxuXHJcblx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcclxuXHRcdFx0XHRzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXBkYXRlZFtpZF0gPSB0cnVlO1xyXG5cdFx0XHR2YXIgc2NhbGUgPSBudWxsO1xyXG5cdFx0XHRpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XHJcblx0XHRcdFx0c2NhbGUgPSBzY2FsZXNbaWRdO1xyXG5cdFx0XHRcdHNjYWxlLm9wdGlvbnMgPSBzY2FsZU9wdGlvbnM7XHJcblx0XHRcdFx0c2NhbGUuY3R4ID0gbWUuY3R4O1xyXG5cdFx0XHRcdHNjYWxlLmNoYXJ0ID0gbWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHNjYWxlQ2xhc3MgPSBjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XHJcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xyXG5cdFx0XHRcdFx0aWQ6IGlkLFxyXG5cdFx0XHRcdFx0dHlwZTogc2NhbGVUeXBlLFxyXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxyXG5cdFx0XHRcdFx0Y3R4OiBtZS5jdHgsXHJcblx0XHRcdFx0XHRjaGFydDogbWVcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjYWxlLm1lcmdlVGlja3NPcHRpb25zKCk7XHJcblxyXG5cdFx0XHQvLyBUT0RPKFNCKTogSSB0aGluayB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjdXN0b20gY2FzZSAob3B0aW9ucy5zY2FsZSlcclxuXHRcdFx0Ly8gYW5kIGNvbnNpZGVyIGl0IGFzIGEgcmVndWxhciBzY2FsZSBwYXJ0IG9mIHRoZSBcInNjYWxlc1wiXCIgbWFwIG9ubHkhIFRoaXMgd291bGRcclxuXHRcdFx0Ly8gbWFrZSB0aGUgbG9naWMgZWFzaWVyIGFuZCByZW1vdmUgc29tZSB1c2VsZXNzPyBjdXN0b20gY29kZS5cclxuXHRcdFx0aWYgKGl0ZW0uaXNEZWZhdWx0KSB7XHJcblx0XHRcdFx0bWUuc2NhbGUgPSBzY2FsZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHQvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXHJcblx0XHRoZWxwZXJzJDEuZWFjaCh1cGRhdGVkLCBmdW5jdGlvbihoYXNVcGRhdGVkLCBpZCkge1xyXG5cdFx0XHRpZiAoIWhhc1VwZGF0ZWQpIHtcclxuXHRcdFx0XHRkZWxldGUgc2NhbGVzW2lkXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWUuc2NhbGVzID0gc2NhbGVzO1xyXG5cclxuXHRcdGNvcmVfc2NhbGVTZXJ2aWNlLmFkZFNjYWxlc1RvTGF5b3V0KHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGJ1aWxkT3JVcGRhdGVDb250cm9sbGVyczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gW107XHJcblx0XHR2YXIgZGF0YXNldHMgPSBtZS5kYXRhLmRhdGFzZXRzO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xyXG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcclxuXHJcblx0XHRcdGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XHJcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRtZXRhLnR5cGUgPSB0eXBlO1xyXG5cdFx0XHRtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xyXG5cdFx0XHRtZXRhLmluZGV4ID0gaTtcclxuXHJcblx0XHRcdGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcclxuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XHJcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgQ29udHJvbGxlckNsYXNzID0gY29udHJvbGxlcnNbbWV0YS50eXBlXTtcclxuXHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbWV0YS50eXBlICsgJ1wiIGlzIG5vdCBhIGNoYXJ0IHR5cGUuJyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKG1lLCBpKTtcclxuXHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3Q29udHJvbGxlcnM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVzZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xyXG5cdFx0fSwgbWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0J3Mgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxyXG5cdCovXHJcblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5yZXNldEVsZW1lbnRzKCk7XHJcblx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0Y29uZmlnID0ge1xyXG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXHJcblx0XHRcdFx0bGF6eTogYXJndW1lbnRzWzFdXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dXBkYXRlQ29uZmlnKG1lKTtcclxuXHJcblx0XHQvLyBwbHVnaW5zIG9wdGlvbnMgcmVmZXJlbmNlcyBtaWdodCBoYXZlIGNoYW5nZSwgbGV0J3MgaW52YWxpZGF0ZSB0aGUgY2FjaGVcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcclxuXHRcdGNvcmVfcGx1Z2lucy5faW52YWxpZGF0ZShtZSk7XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluIGNhc2UgdGhlIGVudGlyZSBkYXRhIG9iamVjdCBjaGFuZ2VkXHJcblx0XHRtZS50b29sdGlwLl9kYXRhID0gbWUuZGF0YTtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxyXG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gbWUuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS51cGRhdGVMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcclxuXHRcdGlmIChtZS5vcHRpb25zLmFuaW1hdGlvbiAmJiBtZS5vcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbikge1xyXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xyXG5cdFx0XHRcdGNvbnRyb2xsZXIucmVzZXQoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUudXBkYXRlRGF0YXNldHMoKTtcclxuXHJcblx0XHQvLyBOZWVkIHRvIHJlc2V0IHRvb2x0aXAgaW4gY2FzZSBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBlbGVtZW50cyB0aGF0IGFyZSByZW1vdmVkXHJcblx0XHQvLyBhZnRlciB1cGRhdGUuXHJcblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcclxuXHJcblx0XHQvLyBMYXN0IGFjdGl2ZSBjb250YWlucyBpdGVtcyB0aGF0IHdlcmUgcHJldmlvdXNseSBpbiB0aGUgdG9vbHRpcC5cclxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcclxuXHRcdG1lLmxhc3RBY3RpdmUgPSBbXTtcclxuXHJcblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJVcGRhdGUnKTtcclxuXHJcblx0XHRtZS5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xyXG5cclxuXHRcdGlmIChtZS5fYnVmZmVyZWRSZW5kZXIpIHtcclxuXHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IHtcclxuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxyXG5cdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyxcclxuXHRcdFx0XHRsYXp5OiBjb25maWcubGF6eVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUucmVuZGVyKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlTGF5b3V0JykgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb3JlX2xheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcblx0XHRtZS5fbGF5ZXJzID0gW107XHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XHJcblx0XHRcdC8vIF9jb25maWd1cmUgaXMgY2FsbGVkIHR3aWNlLCBvbmNlIGluIGNvcmUuc2NhbGUudXBkYXRlIGFuZCBvbmNlIGhlcmUuXHJcblx0XHRcdC8vIEhlcmUgdGhlIGJveGVzIGFyZSBmdWxseSB1cGRhdGVkIGFuZCBhdCB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXHJcblx0XHRcdGlmIChib3guX2NvbmZpZ3VyZSkge1xyXG5cdFx0XHRcdGJveC5fY29uZmlndXJlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bWUuX2xheWVycy5wdXNoLmFwcGx5KG1lLl9sYXllcnMsIGJveC5fbGF5ZXJzKCkpO1xyXG5cdFx0fSwgbWUpO1xyXG5cclxuXHRcdG1lLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xyXG5cdFx0XHRpdGVtLl9pZHggPSBpbmRleDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXHJcblx0XHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJTY2FsZVVwZGF0ZVxyXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxyXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyU2NhbGVVcGRhdGUnKTtcclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckxheW91dCcpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcclxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNVcGRhdGUnKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcclxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZURhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XHJcblx0XHR2YXIgYXJncyA9IHtcclxuXHRcdFx0bWV0YTogbWV0YSxcclxuXHRcdFx0aW5kZXg6IGluZGV4XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldFVwZGF0ZScsIFthcmdzXSkgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xyXG5cdH0sXHJcblxyXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XHJcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdGNvbmZpZyA9IHtcclxuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxyXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhbmltYXRpb25PcHRpb25zID0gbWUub3B0aW9ucy5hbmltYXRpb247XHJcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ5KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcclxuXHRcdHZhciBsYXp5ID0gY29uZmlnLmxhenk7XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XHJcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclJlbmRlcicpO1xyXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBuZXcgY29yZV9hbmltYXRpb24oe1xyXG5cdFx0XHRcdG51bVN0ZXBzOiBkdXJhdGlvbiAvIDE2LjY2LCAvLyA2MCBmcHNcclxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXHJcblxyXG5cdFx0XHRcdHJlbmRlcjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbk9iamVjdCkge1xyXG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xyXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRTdGVwID0gYW5pbWF0aW9uT2JqZWN0LmN1cnJlbnRTdGVwO1xyXG5cdFx0XHRcdFx0dmFyIHN0ZXBEZWNpbWFsID0gY3VycmVudFN0ZXAgLyBhbmltYXRpb25PYmplY3QubnVtU3RlcHM7XHJcblxyXG5cdFx0XHRcdFx0Y2hhcnQuZHJhdyhlYXNpbmdGdW5jdGlvbihzdGVwRGVjaW1hbCksIHN0ZXBEZWNpbWFsLCBjdXJyZW50U3RlcCk7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0b25BbmltYXRpb25Qcm9ncmVzczogYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLFxyXG5cdFx0XHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG9uQ29tcGxldGVcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb3JlX2FuaW1hdGlvbnMuYWRkQW5pbWF0aW9uKG1lLCBhbmltYXRpb24sIGR1cmF0aW9uLCBsYXp5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1lLmRyYXcoKTtcclxuXHJcblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxyXG5cdFx0XHRvbkNvbXBsZXRlKG5ldyBjb3JlX2FuaW1hdGlvbih7bnVtU3RlcHM6IDAsIGNoYXJ0OiBtZX0pKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWU7XHJcblx0fSxcclxuXHJcblx0ZHJhdzogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgaSwgbGF5ZXJzO1xyXG5cclxuXHRcdG1lLmNsZWFyKCk7XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGVhc2luZ1ZhbHVlKSkge1xyXG5cdFx0XHRlYXNpbmdWYWx1ZSA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblxyXG5cdFx0aWYgKG1lLndpZHRoIDw9IDAgfHwgbWUuaGVpZ2h0IDw9IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmVjYXVzZSBvZiBwbHVnaW4gaG9va3MgKGJlZm9yZS9hZnRlckRhdGFzZXRzRHJhdyksIGRhdGFzZXRzIGNhbid0XHJcblx0XHQvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcclxuXHRcdC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcclxuXHRcdGxheWVycyA9IG1lLl9sYXllcnM7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcclxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcobWUuY2hhcnRBcmVhKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5kcmF3RGF0YXNldHMoZWFzaW5nVmFsdWUpO1xyXG5cclxuXHRcdC8vIFJlc3Qgb2YgbGF5ZXJzXHJcblx0XHRmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRsYXllcnNbaV0uZHJhdyhtZS5jaGFydEFyZWEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl9kcmF3VG9vbHRpcChlYXNpbmdWYWx1ZSk7XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnRvb2x0aXAudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0U29ydGVkRGF0YXNldE1ldGFzOiBmdW5jdGlvbihmaWx0ZXJWaXNpYmxlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gbWUuZGF0YS5kYXRhc2V0cyB8fCBbXTtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdHZhciBpLCBpbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChtZS5nZXREYXRhc2V0TWV0YShpKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2BcclxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhd0RhdGFzZXRzOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtZXRhc2V0cywgaTtcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWV0YXNldHMgPSBtZS5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xyXG5cdFx0Zm9yIChpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHRcdFx0bWUuZHJhd0RhdGFzZXQobWV0YXNldHNbaV0sIGVhc2luZ1ZhbHVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2BcclxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkcmF3RGF0YXNldDogZnVuY3Rpb24obWV0YSwgZWFzaW5nVmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgYXJncyA9IHtcclxuXHRcdFx0bWV0YTogbWV0YSxcclxuXHRcdFx0aW5kZXg6IG1ldGEuaW5kZXgsXHJcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXREcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1ldGEuY29udHJvbGxlci5kcmF3KGVhc2luZ1ZhbHVlKTtcclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0RHJhdycsIFthcmdzXSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgdG9vbHRpcCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlVG9vbHRpcERyYXdgXHJcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyVG9vbHRpcERyYXdgLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdUb29sdGlwOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcclxuXHRcdHZhciBhcmdzID0ge1xyXG5cdFx0XHR0b29sdGlwOiB0b29sdGlwLFxyXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVUb29sdGlwRHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0b29sdGlwLmRyYXcoKTtcclxuXHJcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJUb29sdGlwRHJhdycsIFthcmdzXSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXHJcblx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YXNldCBpbmRleCBhbmQgZWxlbWVudCBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudC4gQWxzbyBjb250YWlucyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2FzIGRyYXdcclxuXHQgKi9cclxuXHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuc2luZ2xlKHRoaXMsIGUpO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnRzQXRFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMubGFiZWwodGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnRzQXRYQXhpczogZnVuY3Rpb24oZSkge1xyXG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgbWV0aG9kID0gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcclxuXHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH0sXHJcblxyXG5cdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XHJcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0KHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHRnZXREYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XHJcblx0XHRpZiAoIWRhdGFzZXQuX21ldGEpIHtcclxuXHRcdFx0ZGF0YXNldC5fbWV0YSA9IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YVttZS5pZF07XHJcblx0XHRpZiAoIW1ldGEpIHtcclxuXHRcdFx0bWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdID0ge1xyXG5cdFx0XHRcdHR5cGU6IG51bGwsXHJcblx0XHRcdFx0ZGF0YTogW10sXHJcblx0XHRcdFx0ZGF0YXNldDogbnVsbCxcclxuXHRcdFx0XHRjb250cm9sbGVyOiBudWxsLFxyXG5cdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcclxuXHRcdFx0XHR4QXhpc0lEOiBudWxsLFxyXG5cdFx0XHRcdHlBeGlzSUQ6IG51bGwsXHJcblx0XHRcdFx0b3JkZXI6IGRhdGFzZXQub3JkZXIgfHwgMCxcclxuXHRcdFx0XHRpbmRleDogZGF0YXNldEluZGV4XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1ldGE7XHJcblx0fSxcclxuXHJcblx0Z2V0VmlzaWJsZURhdGFzZXRDb3VudDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY291bnQgPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRjb3VudCsrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY291bnQ7XHJcblx0fSxcclxuXHJcblx0aXNEYXRhc2V0VmlzaWJsZTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHJcblx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXHJcblx0XHQvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXHJcblx0XHRyZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uaGlkZGVuO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlTGVnZW5kOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkZXN0cm95RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5pZDtcclxuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XHJcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGEgJiYgZGF0YXNldC5fbWV0YVtpZF07XHJcblxyXG5cdFx0aWYgKG1ldGEpIHtcclxuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcclxuXHRcdFx0ZGVsZXRlIGRhdGFzZXQuX21ldGFbaWRdO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XHJcblx0XHR2YXIgaSwgaWxlbjtcclxuXHJcblx0XHRtZS5zdG9wKCk7XHJcblxyXG5cdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjYW52YXMpIHtcclxuXHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XHJcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIobWUpO1xyXG5cdFx0XHRwbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChtZS5jdHgpO1xyXG5cdFx0XHRtZS5jYW52YXMgPSBudWxsO1xyXG5cdFx0XHRtZS5jdHggPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XHJcblxyXG5cdFx0ZGVsZXRlIENoYXJ0Lmluc3RhbmNlc1ttZS5pZF07XHJcblx0fSxcclxuXHJcblx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRtZS50b29sdGlwID0gbmV3IGNvcmVfdG9vbHRpcCh7XHJcblx0XHRcdF9jaGFydDogbWUsXHJcblx0XHRcdF9jaGFydEluc3RhbmNlOiBtZSwgLy8gZGVwcmVjYXRlZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRfZGF0YTogbWUuZGF0YSxcclxuXHRcdFx0X29wdGlvbnM6IG1lLm9wdGlvbnMudG9vbHRpcHNcclxuXHRcdH0sIG1lKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XHJcblx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XHJcblx0XHRcdGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gRWxlbWVudHMgdXNlZCB0byBkZXRlY3Qgc2l6ZSBjaGFuZ2Ugc2hvdWxkIG5vdCBiZSBpbmplY3RlZCBmb3Igbm9uIHJlc3BvbnNpdmUgY2hhcnRzLlxyXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXHJcblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XHJcblx0XHRcdGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bWUucmVzaXplKCk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xyXG5cdFx0XHRsaXN0ZW5lcnMucmVzaXplID0gbGlzdGVuZXI7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bmJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzO1xyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xyXG5cdFx0aGVscGVycyQxLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xyXG5cdFx0XHRwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50cywgbW9kZSwgZW5hYmxlZCkge1xyXG5cdFx0dmFyIHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xyXG5cdFx0dmFyIGVsZW1lbnQsIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcblx0XHRcdGlmIChlbGVtZW50KSB7XHJcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShlbGVtZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcclxuXHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50c1swXS5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XHJcblxyXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVFdmVudCcsIFtlXSkgPT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWZmZXIgYW55IHVwZGF0ZSBjYWxscyBzbyB0aGF0IHJlbmRlcnMgZG8gbm90IG9jY3VyXHJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xyXG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XHJcblxyXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcclxuXHRcdC8vIGZvciBzbW9vdGggdG9vbHRpcCBhbmltYXRpb25zIGlzc3VlICM0OTg5XHJcblx0XHQvLyB0aGUgdG9vbHRpcCBzaG91bGQgYmUgdGhlIHNvdXJjZSBvZiBjaGFuZ2VcclxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxyXG5cdFx0Ly8gdG9vbHRpcC5fc3RhcnQgd2lsbCBiZSBudWxsIHdoZW4gdG9vbHRpcCBpc24ndCBhbmltYXRpbmdcclxuXHRcdGlmICh0b29sdGlwKSB7XHJcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxyXG5cdFx0XHRcdD8gdG9vbHRpcC5oYW5kbGVFdmVudChlKVxyXG5cdFx0XHRcdDogY2hhbmdlZCB8IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRXZlbnQnLCBbZV0pO1xyXG5cclxuXHRcdHZhciBidWZmZXJlZFJlcXVlc3QgPSBtZS5fYnVmZmVyZWRSZXF1ZXN0O1xyXG5cdFx0aWYgKGJ1ZmZlcmVkUmVxdWVzdCkge1xyXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXHJcblx0XHRcdG1lLnJlbmRlcihidWZmZXJlZFJlcXVlc3QpO1xyXG5cdFx0fSBlbHNlIGlmIChjaGFuZ2VkICYmICFtZS5hbmltYXRpbmcpIHtcclxuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XHJcblx0XHRcdG1lLnN0b3AoKTtcclxuXHJcblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcclxuXHRcdFx0Ly8gcmVjb21wdXRlZCBnZW5lcmF0aW5nIGZsaWNrZXIgJiB1c2luZyBtb3JlIG1lbW9yeSB0aGFuIG5lY2Vzc2FyeS5cclxuXHRcdFx0bWUucmVuZGVyKHtcclxuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcclxuXHRcdFx0XHRsYXp5OiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLl9idWZmZXJlZFJlbmRlciA9IGZhbHNlO1xyXG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIG1lO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBhbiBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IHRoZSBldmVudCB0byBoYW5kbGVcclxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcclxuXHQgKi9cclxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucyB8fCB7fTtcclxuXHRcdHZhciBob3Zlck9wdGlvbnMgPSBvcHRpb25zLmhvdmVyO1xyXG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuXHJcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUubGFzdEFjdGl2ZSB8fCBbXTtcclxuXHJcblx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgaG92ZXIgYW5kIHRvb2x0aXBzXHJcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XHJcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuYWN0aXZlID0gbWUuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbnZva2Ugb25Ib3ZlciBob29rXHJcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayhvcHRpb25zLm9uSG92ZXIgfHwgb3B0aW9ucy5ob3Zlci5vbkhvdmVyLCBbZS5uYXRpdmUsIG1lLmFjdGl2ZV0sIG1lKTtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdGlmIChvcHRpb25zLm9uQ2xpY2spIHtcclxuXHRcdFx0XHQvLyBVc2UgZS5uYXRpdmUgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZW1vdmUgc3R5bGluZyBmb3IgbGFzdCBhY3RpdmUgKGV2ZW4gaWYgaXQgbWF5IHN0aWxsIGJlIGFjdGl2ZSlcclxuXHRcdGlmIChtZS5sYXN0QWN0aXZlLmxlbmd0aCkge1xyXG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xyXG5cdFx0aWYgKG1lLmFjdGl2ZS5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcclxuXHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5hY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRjaGFuZ2VkID0gIWhlbHBlcnMkMS5hcnJheUVxdWFscyhtZS5hY3RpdmUsIG1lLmxhc3RBY3RpdmUpO1xyXG5cclxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xyXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmFjdGl2ZTtcclxuXHJcblx0XHRyZXR1cm4gY2hhbmdlZDtcclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcclxuICogZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIFRob3VnaCwgaXQgY2FuIHN0aWxsIGJlIHVzZWZ1bCBmb3IgcGx1Z2lucyB0aGF0XHJcbiAqIHdvdWxkIG5lZWQgdG8gd29yayBvbiBtdWx0aXBsZSBjaGFydHM/IVxyXG4gKi9cclxuQ2hhcnQuaW5zdGFuY2VzID0ge307XHJcblxyXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XHJcblxyXG4vLyBERVBSRUNBVElPTlNcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0IGluc3RlYWQuXHJcbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbkNoYXJ0LkNvbnRyb2xsZXIgPSBDaGFydDtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbkNoYXJ0LnR5cGVzID0ge307XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuaGVscGVycyQxLmNvbmZpZ01lcmdlID0gbWVyZ2VDb25maWc7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cclxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5oZWxwZXJzJDEuc2NhbGVNZXJnZSA9IG1lcmdlU2NhbGVDb25maWc7XG5cbnZhciBjb3JlX2hlbHBlcnMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0Ly8gLS0gQmFzaWMganMgdXRpbGl0eSBtZXRob2RzXHJcblxyXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XHJcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoY29sbGVjdGlvbikgJiYgQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xyXG5cdFx0XHRyZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoZmlsdGVyQ2FsbGJhY2spO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGZpbHRlcmVkID0gW107XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soaXRlbSkpIHtcclxuXHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZmlsdGVyZWQ7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuZmluZEluZGV4ID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCA/XHJcblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcblx0XHRcdHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2ssIHNjb3BlKTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBhcnJheSA6IHNjb3BlO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fTtcclxuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XHJcblx0XHQvLyBEZWZhdWx0IHRvIHN0YXJ0IG9mIHRoZSBhcnJheVxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XHJcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4ICsgMTsgaSA8IGFycmF5VG9TZWFyY2gubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcclxuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xyXG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcclxuXHRcdC8vIERlZmF1bHQgdG8gZW5kIG9mIHRoZSBhcnJheVxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XHJcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcclxuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xyXG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIC0tIE1hdGggbWV0aG9kc1xyXG5cdGhlbHBlcnMkMS5pc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcclxuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24oeCwgeSwgZXBzaWxvbikge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuYWxtb3N0V2hvbGUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XHJcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XHJcblx0XHRyZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWF4LCB2YWx1ZSkge1xyXG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbWF4O1xyXG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5taW4gPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XHJcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XHJcblx0XHRcdFx0cmV0dXJuIE1hdGgubWluKG1pbiwgdmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtaW47XHJcblx0XHR9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLnNpZ24gPSBNYXRoLnNpZ24gP1xyXG5cdFx0ZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xyXG5cdFx0fSA6XHJcblx0XHRmdW5jdGlvbih4KSB7XHJcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxyXG5cdFx0XHRpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xyXG5cdFx0XHRcdHJldHVybiB4O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB4ID4gMCA/IDEgOiAtMTtcclxuXHRcdH07XHJcblx0aGVscGVycyQxLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcclxuXHRcdHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xyXG5cdH07XHJcblx0aGVscGVycyQxLnRvRGVncmVlcyA9IGZ1bmN0aW9uKHJhZGlhbnMpIHtcclxuXHRcdHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG5cdCAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIEEgbnVtYmVyLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbih4KSB7XHJcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh4KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgZSA9IDE7XHJcblx0XHR2YXIgcCA9IDA7XHJcblx0XHR3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XHJcblx0XHRcdGUgKj0gMTA7XHJcblx0XHRcdHArKztcclxuXHRcdH1cclxuXHRcdHJldHVybiBwO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXHJcblx0aGVscGVycyQxLmdldEFuZ2xlRnJvbVBvaW50ID0gZnVuY3Rpb24oY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcclxuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcclxuXHRcdHZhciBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcclxuXHRcdHZhciByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XHJcblxyXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcclxuXHJcblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XHJcblx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YW5nbGU6IGFuZ2xlLFxyXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXHJcblx0XHR9O1xyXG5cdH07XHJcblx0aGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hbGlhc1BpeGVsXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKi9cclxuXHRoZWxwZXJzJDEuYWxpYXNQaXhlbCA9IGZ1bmN0aW9uKHBpeGVsV2lkdGgpIHtcclxuXHRcdHJldHVybiAocGl4ZWxXaWR0aCAlIDIgPT09IDApID8gMCA6IDAuNTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbCAtIEEgcGl4ZWwgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGVscGVycyQxLl9hbGlnblBpeGVsID0gZnVuY3Rpb24oY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xyXG5cdFx0dmFyIGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xyXG5cdH07XHJcblxyXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XHJcblx0XHQvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcclxuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXHJcblxyXG5cdFx0dmFyIHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xyXG5cdFx0dmFyIGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcclxuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xyXG5cclxuXHRcdHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudC54IC0gcHJldmlvdXMueCwgMikgKyBNYXRoLnBvdyhjdXJyZW50LnkgLSBwcmV2aW91cy55LCAyKSk7XHJcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcclxuXHJcblx0XHR2YXIgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XHJcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XHJcblxyXG5cdFx0Ly8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxyXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XHJcblx0XHRzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcclxuXHJcblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcclxuXHRcdHZhciBmYiA9IHQgKiBzMTI7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0cHJldmlvdXM6IHtcclxuXHRcdFx0XHR4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcclxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuZXh0OiB7XHJcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXHJcblx0XHRcdFx0eTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5FUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XHJcblx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxyXG5cdFx0Ly8gYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxyXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxyXG5cdFx0Ly8gU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxyXG5cclxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRtb2RlbDogcG9pbnQuX21vZGVsLFxyXG5cdFx0XHRcdGRlbHRhSzogMCxcclxuXHRcdFx0XHRtSzogMFxyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHNsb3BlcyAoZGVsdGFLKSBhbmQgaW5pdGlhbGl6ZSB0YW5nZW50cyAobUspXHJcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50LCBwb2ludEFmdGVyO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XHJcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcclxuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcclxuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XHJcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHR2YXIgc2xvcGVEZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpO1xyXG5cclxuXHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQuZGVsdGFLID0gc2xvcGVEZWx0YVggIT09IDAgPyAocG9pbnRBZnRlci5tb2RlbC55IC0gcG9pbnRDdXJyZW50Lm1vZGVsLnkpIC8gc2xvcGVEZWx0YVggOiAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXBvaW50QmVmb3JlIHx8IHBvaW50QmVmb3JlLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFwb2ludEFmdGVyIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QmVmb3JlLmRlbHRhSztcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XHJcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xyXG5cdFx0dmFyIGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGU7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XHJcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcclxuXHRcdFx0cG9pbnRBZnRlciA9IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV07XHJcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMocG9pbnRDdXJyZW50LmRlbHRhSywgMCwgdGhpcy5FUFNJTE9OKSkge1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QWZ0ZXIubUsgPSAwO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0XHRiZXRhSyA9IHBvaW50QWZ0ZXIubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0XHRzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcclxuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcclxuXHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gYWxwaGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XHJcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcclxuXHRcdHZhciBkZWx0YVg7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcclxuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xyXG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xyXG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcclxuXHRcdFx0aWYgKHBvaW50QmVmb3JlICYmICFwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XHJcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50Q3VycmVudC5tb2RlbC54IC0gcG9pbnRCZWZvcmUubW9kZWwueCkgLyAzO1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcclxuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgLSBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xyXG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCkgLyAzO1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IHBvaW50Q3VycmVudC5tb2RlbC54ICsgZGVsdGFYO1xyXG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRoZWxwZXJzJDEubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xyXG5cdFx0aWYgKGxvb3ApIHtcclxuXHRcdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xyXG5cdH07XHJcblx0aGVscGVycyQxLnByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XHJcblx0XHRpZiAobG9vcCkge1xyXG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcclxuXHR9O1xyXG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXHJcblx0aGVscGVycyQxLm5pY2VOdW0gPSBmdW5jdGlvbihyYW5nZSwgcm91bmQpIHtcclxuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHJhbmdlKSk7XHJcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XHJcblx0XHR2YXIgbmljZUZyYWN0aW9uO1xyXG5cclxuXHRcdGlmIChyb3VuZCkge1xyXG5cdFx0XHRpZiAoZnJhY3Rpb24gPCAxLjUpIHtcclxuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xyXG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XHJcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCA3KSB7XHJcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSAxLjApIHtcclxuXHRcdFx0bmljZUZyYWN0aW9uID0gMTtcclxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xyXG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xyXG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSB7XHJcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmljZUZyYWN0aW9uICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcclxuXHR9O1xyXG5cdC8vIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsIC0gaHR0cHM6Ly93d3cucGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG5cdFx0XHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0XHRcdGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG5cdFx0XHR9O1xyXG5cdH0oKSk7XHJcblx0Ly8gLS0gRE9NIG1ldGhvZHNcclxuXHRoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCwgY2hhcnQpIHtcclxuXHRcdHZhciBtb3VzZVgsIG1vdXNlWTtcclxuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xyXG5cdFx0dmFyIGNhbnZhcyA9IGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQ7XHJcblx0XHR2YXIgYm91bmRpbmdSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xyXG5cdFx0aWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcclxuXHRcdFx0bW91c2VZID0gdG91Y2hlc1swXS5jbGllbnRZO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1vdXNlWCA9IGUuY2xpZW50WDtcclxuXHRcdFx0bW91c2VZID0gZS5jbGllbnRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNjYWxlIG1vdXNlIGNvb3JkaW5hdGVzIGludG8gY2FudmFzIGNvb3JkaW5hdGVzXHJcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXHJcblx0XHQvLyBodHRwczovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vYWR2YW5jZWQvaHRtbDUtY2FudmFzLW1vdXNlLWNvb3JkaW5hdGVzL1xyXG5cdFx0dmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1sZWZ0JykpO1xyXG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXRvcCcpKTtcclxuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXJpZ2h0JykpO1xyXG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWJvdHRvbScpKTtcclxuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XHJcblx0XHR2YXIgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcclxuXHJcblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXHJcblx0XHQvLyB0aGUgYmFja2VuZCBtb2RlbCBpcyBpbiB1bnNjYWxlZCBjb29yZGluYXRlcy4gU2luY2Ugd2UgYXJlIGdvaW5nIHRvIGRlYWwgd2l0aCBvdXIgbW9kZWwgY29vcmRpbmF0ZXMsIHdlIGdvIGJhY2sgaGVyZVxyXG5cdFx0bW91c2VYID0gTWF0aC5yb3VuZCgobW91c2VYIC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCkgLyAod2lkdGgpICogY2FudmFzLndpZHRoIC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xyXG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IG1vdXNlWCxcclxuXHRcdFx0eTogbW91c2VZXHJcblx0XHR9O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXHJcblx0ZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xyXG5cdFx0dmFyIHZhbHVlSW5QaXhlbHM7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XHJcblxyXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XHJcblx0XHRcdFx0Ly8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXHJcblx0XHRcdFx0dmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVJblBpeGVscztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJ25vbmUnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbWF4IHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgaW4gYSBjcm9zcy1icm93c2VyIGNvbXBhdGlibGUgZmFzaGlvblxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbU5vZGUgLSB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXhTdHlsZSAtIHRoZSBzdHlsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZm9yIHRoZSBkaXJlY3Rpb24gd2UgYXJlIHVzaW5nICgnbWF4LXdpZHRoJyAvICdtYXgtaGVpZ2h0JylcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGVyY2VudGFnZVByb3BlcnR5IC0gcHJvcGVydHkgb2YgcGFyZW50IHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIHdpZHRoIGFzIGEgcGVyY2VudGFnZVxyXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3Nlcn1cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsIG1heFN0eWxlLCBwZXJjZW50YWdlUHJvcGVydHkpIHtcclxuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcclxuXHRcdHZhciBjb25zdHJhaW5lZE5vZGUgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSlbbWF4U3R5bGVdO1xyXG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcclxuXHRcdHZhciBoYXNDTm9kZSA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZE5vZGUpO1xyXG5cdFx0dmFyIGhhc0NDb250YWluZXIgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWRDb250YWluZXIpO1xyXG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuXHRcdGlmIChoYXNDTm9kZSB8fCBoYXNDQ29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1pbihcclxuXHRcdFx0XHRoYXNDTm9kZSA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWROb2RlLCBkb21Ob2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHksXHJcblx0XHRcdFx0aGFzQ0NvbnRhaW5lciA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWRDb250YWluZXIsIHBhcmVudE5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICdub25lJztcclxuXHR9XHJcblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcclxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xyXG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC13aWR0aCcsICdjbGllbnRXaWR0aCcpO1xyXG5cdH07XHJcblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcclxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcclxuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xyXG5cdH07XHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuIFx0ICovXHJcblx0aGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYWRkaW5nLCBwYXJlbnREaW1lbnNpb24pIHtcclxuXHRcdHBhZGRpbmcgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoY29udGFpbmVyLCBwYWRkaW5nKTtcclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZy5pbmRleE9mKCclJykgPiAtMSA/IHBhcmVudERpbWVuc2lvbiAqIHBhcnNlSW50KHBhZGRpbmcsIDEwKSAvIDEwMCA6IHBhcnNlSW50KHBhZGRpbmcsIDEwKTtcclxuXHR9O1xyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGVscGVycyQxLl9nZXRQYXJlbnROb2RlID0gZnVuY3Rpb24oZG9tTm9kZSkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcclxuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xyXG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQuaG9zdDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYXJlbnQ7XHJcblx0fTtcclxuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudFdpZHRoO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcclxuXHRcdHZhciBwYWRkaW5nTGVmdCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLWxlZnQnLCBjbGllbnRXaWR0aCk7XHJcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctcmlnaHQnLCBjbGllbnRXaWR0aCk7XHJcblxyXG5cdFx0dmFyIHcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xyXG5cdFx0dmFyIGN3ID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aChkb21Ob2RlKTtcclxuXHRcdHJldHVybiBpc05hTihjdykgPyB3IDogTWF0aC5taW4odywgY3cpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmdldE1heGltdW1IZWlnaHQgPSBmdW5jdGlvbihkb21Ob2RlKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50SGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy10b3AnLCBjbGllbnRIZWlnaHQpO1xyXG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nLCBjbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdHZhciBoID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XHJcblx0XHR2YXIgY2ggPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodChkb21Ob2RlKTtcclxuXHRcdHJldHVybiBpc05hTihjaCkgPyBoIDogTWF0aC5taW4oaCwgY2gpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLmdldFN0eWxlID0gZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XHJcblx0XHRyZXR1cm4gZWwuY3VycmVudFN0eWxlID9cclxuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XHJcblx0XHRcdGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xyXG5cdH07XHJcblx0aGVscGVycyQxLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcclxuXHRcdHZhciBwaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcclxuXHRcdGlmIChwaXhlbFJhdGlvID09PSAxKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xyXG5cdFx0dmFyIGhlaWdodCA9IGNoYXJ0LmhlaWdodDtcclxuXHRcdHZhciB3aWR0aCA9IGNoYXJ0LndpZHRoO1xyXG5cclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xyXG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG5cclxuXHRcdC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXHJcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxyXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XHJcblx0XHRpZiAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkge1xyXG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0Ly8gLS0gQ2FudmFzIG1ldGhvZHNcclxuXHRoZWxwZXJzJDEuZm9udFN0cmluZyA9IGZ1bmN0aW9uKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XHJcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xyXG5cdH07XHJcblx0aGVscGVycyQxLmxvbmdlc3RUZXh0ID0gZnVuY3Rpb24oY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xyXG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcclxuXHRcdHZhciBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XHJcblx0XHR2YXIgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xyXG5cclxuXHRcdGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XHJcblx0XHRcdGRhdGEgPSBjYWNoZS5kYXRhID0ge307XHJcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcclxuXHRcdFx0Y2FjaGUuZm9udCA9IGZvbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LmZvbnQgPSBmb250O1xyXG5cdFx0dmFyIGxvbmdlc3QgPSAwO1xyXG5cdFx0dmFyIGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcclxuXHRcdHZhciBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcclxuXHJcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxyXG5cdFx0XHRpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBoZWxwZXJzJDEuaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcclxuXHRcdFx0XHRsb25nZXN0ID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcclxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcclxuXHRcdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XHJcblx0XHRcdFx0Ly8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xyXG5cdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcclxuXHRcdFx0XHRcdG5lc3RlZFRoaW5nID0gdGhpbmdbal07XHJcblx0XHRcdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcclxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzJDEuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcclxuXHRcdFx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcclxuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XHJcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdjLnNwbGljZSgwLCBnY0xlbik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbG9uZ2VzdDtcclxuXHR9O1xyXG5cdGhlbHBlcnMkMS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xyXG5cdFx0dmFyIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcclxuXHRcdGlmICghdGV4dFdpZHRoKSB7XHJcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xyXG5cdFx0XHRnYy5wdXNoKHN0cmluZyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xyXG5cdFx0XHRsb25nZXN0ID0gdGV4dFdpZHRoO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxvbmdlc3Q7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKi9cclxuXHRoZWxwZXJzJDEubnVtYmVyT2ZMYWJlbExpbmVzID0gZnVuY3Rpb24oYXJyYXlPZlRoaW5ncykge1xyXG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xyXG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcclxuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSkge1xyXG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XHJcblx0XHRcdFx0XHRudW1iZXJPZkxpbmVzID0gdGhpbmcubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gbnVtYmVyT2ZMaW5lcztcclxuXHR9O1xyXG5cclxuXHRoZWxwZXJzJDEuY29sb3IgPSAhY2hhcnRqc0NvbG9yID9cclxuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbG9yLmpzIG5vdCBmb3VuZCEnKTtcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSA6XHJcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHQvKiBnbG9iYWwgQ2FudmFzR3JhZGllbnQgKi9cclxuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNoYXJ0anNDb2xvcih2YWx1ZSk7XHJcblx0XHR9O1xyXG5cclxuXHRoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvciA9IGZ1bmN0aW9uKGNvbG9yVmFsdWUpIHtcclxuXHRcdC8qIGdsb2JhbCBDYW52YXNQYXR0ZXJuICovXHJcblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xyXG5cdFx0XHRjb2xvclZhbHVlIDpcclxuXHRcdFx0aGVscGVycyQxLmNvbG9yKGNvbG9yVmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkucmdiU3RyaW5nKCk7XHJcblx0fTtcclxufTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xyXG5cdFx0J2JlIGZvdW5kIG9yIGFuIGluY29tcGxldGUgaW50ZWdyYXRpb24gd2FzIHByb3ZpZGVkLidcclxuXHQpO1xyXG59XHJcblxyXG4vKipcclxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXHJcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG4vKipcclxuICogQ3VycmVudGx5IHN1cHBvcnRlZCB1bml0IHN0cmluZyB2YWx1ZXMuXHJcbiAqIEB0eXBlZGVmIHsoJ21pbGxpc2Vjb25kJ3wnc2Vjb25kJ3wnbWludXRlJ3wnaG91cid8J2RheSd8J3dlZWsnfCdtb250aCd8J3F1YXJ0ZXInfCd5ZWFyJyl9XHJcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcclxuICogQG5hbWUgVW5pdFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIERhdGVBZGFwdGVyKG9wdGlvbnMpIHtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG59XHJcblxyXG5oZWxwZXJzJDEuZXh0ZW5kKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBEYXRlQWRhcHRlciAqLyB7XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXHJcblx0ICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cclxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cclxuXHQgKi9cclxuXHRmb3JtYXRzOiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxyXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxyXG5cdCAqIEByZXR1cm5zIHsobnVtYmVyfG51bGwpfVxyXG5cdCAqIEBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdHBhcnNlOiBhYnN0cmFjdCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxyXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRmb3JtYXQ6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xyXG5cdCAqIEByZXR1cm4ge251bWJlcn1cclxuXHQgKiBAZnVuY3Rpb25cclxuXHQgKi9cclxuXHRhZGQ6IGFic3RyYWN0LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIHRoZSBpbnB1dCB0aW1lc3RhbXAgKHJlZmVyZW5jZSlcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0ZGlmZjogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcclxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dlZWtkYXldIC0gdGhlIElTTyBkYXkgb2YgdGhlIHdlZWsgd2l0aCAxIGJlaW5nIE1vbmRheVxyXG5cdCAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0c3RhcnRPZjogYWJzdHJhY3QsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXHJcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXHJcblx0ICogQGZ1bmN0aW9uXHJcblx0ICovXHJcblx0ZW5kT2Y6IGFic3RyYWN0LFxyXG5cclxuXHQvLyBERVBSRUNBVElPTlNcclxuXHJcblx0LyoqXHJcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcclxuXHQgKiB0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBvbmx5IGJ5IHRoZSBtb21lbnQgYWRhcHRlci5cclxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9XHJcbn0pO1xyXG5cclxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XHJcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xyXG59O1xyXG5cclxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxyXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXHJcbiAqL1xyXG52YXIgY29yZV90aWNrcyA9IHtcclxuXHQvKipcclxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3NcclxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcclxuXHQgKi9cclxuXHRmb3JtYXR0ZXJzOiB7XHJcblx0XHQvKipcclxuXHRcdCAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXHJcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXHJcblx0XHQgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcclxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcclxuXHRcdCAqL1xyXG5cdFx0dmFsdWVzOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3NcclxuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5saW5lYXJcclxuXHRcdCAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxyXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcclxuXHRcdCAqIEBwYXJhbSB0aWNrcyB7bnVtYmVyW119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxyXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcclxuXHRcdCAqL1xyXG5cdFx0bGluZWFyOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xyXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGxvdHMgb2YgdGlja3MsIGRvbid0IHVzZSB0aGUgb25lc1xyXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XHJcblxyXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXHJcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XHJcblx0XHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XHJcblx0XHRcdFx0XHQvLyBub3QgYW4gaW50ZWdlclxyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbG9nRGVsdGEgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcclxuXHRcdFx0dmFyIHRpY2tTdHJpbmcgPSAnJztcclxuXHJcblx0XHRcdGlmICh0aWNrVmFsdWUgIT09IDApIHtcclxuXHRcdFx0XHR2YXIgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0pKTtcclxuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxyXG5cdFx0XHRcdFx0dmFyIGxvZ1RpY2sgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnModGlja1ZhbHVlKSk7XHJcblx0XHRcdFx0XHR2YXIgbnVtRXhwb25lbnRpYWwgPSBNYXRoLmZsb29yKGxvZ1RpY2spIC0gTWF0aC5mbG9vcihsb2dEZWx0YSk7XHJcblx0XHRcdFx0XHRudW1FeHBvbmVudGlhbCA9IE1hdGgubWF4KE1hdGgubWluKG51bUV4cG9uZW50aWFsLCAyMCksIDApO1xyXG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKG51bUV4cG9uZW50aWFsKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIG51bURlY2ltYWwgPSAtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpO1xyXG5cdFx0XHRcdFx0bnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKG51bURlY2ltYWwsIDIwKSwgMCk7IC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXHJcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRpY2tTdHJpbmcgPSAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XHJcblx0XHR9LFxyXG5cclxuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xyXG5cdFx0XHR2YXIgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsdWUpKSkpO1xyXG5cclxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xyXG5cdFx0XHRcdHJldHVybiAnMCc7XHJcblx0XHRcdH0gZWxzZSBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHRpY2tzLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gJyc7XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgaXNBcnJheSA9IGhlbHBlcnMkMS5pc0FycmF5O1xyXG52YXIgaXNOdWxsT3JVbmRlZiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xyXG52YXIgdmFsdWVPckRlZmF1bHQkYSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcclxudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYWxlJywge1xyXG5cdGRpc3BsYXk6IHRydWUsXHJcblx0cG9zaXRpb246ICdsZWZ0JyxcclxuXHRvZmZzZXQ6IGZhbHNlLFxyXG5cclxuXHQvLyBncmlkIGxpbmUgc2V0dGluZ3NcclxuXHRncmlkTGluZXM6IHtcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRjb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXHJcblx0XHRsaW5lV2lkdGg6IDEsXHJcblx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxyXG5cdFx0ZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxyXG5cdFx0ZHJhd1RpY2tzOiB0cnVlLFxyXG5cdFx0dGlja01hcmtMZW5ndGg6IDEwLFxyXG5cdFx0emVyb0xpbmVXaWR0aDogMSxcclxuXHRcdHplcm9MaW5lQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMjUpJyxcclxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXHJcblx0XHR6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcclxuXHRcdG9mZnNldEdyaWRMaW5lczogZmFsc2UsXHJcblx0XHRib3JkZXJEYXNoOiBbXSxcclxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxyXG5cdH0sXHJcblxyXG5cdC8vIHNjYWxlIGxhYmVsXHJcblx0c2NhbGVMYWJlbDoge1xyXG5cdFx0Ly8gZGlzcGxheSBwcm9wZXJ0eVxyXG5cdFx0ZGlzcGxheTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gYWN0dWFsIGxhYmVsXHJcblx0XHRsYWJlbFN0cmluZzogJycsXHJcblxyXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXHJcblx0XHRwYWRkaW5nOiB7XHJcblx0XHRcdHRvcDogNCxcclxuXHRcdFx0Ym90dG9tOiA0XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gbGFiZWwgc2V0dGluZ3NcclxuXHR0aWNrczoge1xyXG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxyXG5cdFx0bWluUm90YXRpb246IDAsXHJcblx0XHRtYXhSb3RhdGlvbjogNTAsXHJcblx0XHRtaXJyb3I6IGZhbHNlLFxyXG5cdFx0cGFkZGluZzogMCxcclxuXHRcdHJldmVyc2U6IGZhbHNlLFxyXG5cdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdGF1dG9Ta2lwOiB0cnVlLFxyXG5cdFx0YXV0b1NraXBQYWRkaW5nOiAwLFxyXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXHJcblx0XHQvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cclxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxyXG5cdFx0bWlub3I6IHt9LFxyXG5cdFx0bWFqb3I6IHt9XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKiBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgbnVtSXRlbXMgZnJvbSBhcnIgKi9cclxuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcclxuXHR2YXIgcmVzdWx0ID0gW107XHJcblx0dmFyIGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcclxuXHR2YXIgaSA9IDA7XHJcblx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG5cdGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xyXG5cdFx0cmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xyXG5cdHZhciBsZW5ndGggPSBzY2FsZS5nZXRUaWNrcygpLmxlbmd0aDtcclxuXHR2YXIgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcclxuXHR2YXIgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xyXG5cdHZhciBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xyXG5cdHZhciBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XHJcblx0dmFyIGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxyXG5cdHZhciBvZmZzZXQ7XHJcblxyXG5cdGlmIChvZmZzZXRHcmlkTGluZXMpIHtcclxuXHRcdGlmIChsZW5ndGggPT09IDEpIHtcclxuXHRcdFx0b2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XHJcblx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XHJcblx0XHRcdG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XHJcblx0XHR9XHJcblx0XHRsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcclxuXHJcblx0XHQvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXHJcblx0XHRpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbGluZVZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xyXG5cdGhlbHBlcnMkMS5lYWNoKGNhY2hlcywgZnVuY3Rpb24oY2FjaGUpIHtcclxuXHRcdHZhciBnYyA9IGNhY2hlLmdjO1xyXG5cdFx0dmFyIGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcclxuXHRcdHZhciBpO1xyXG5cdFx0aWYgKGdjTGVuID4gbGVuZ3RoKSB7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XHJcblx0XHRcdFx0ZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdjLnNwbGljZSgwLCBnY0xlbik7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHt3aWR0aCwgaGVpZ2h0LCBvZmZzZXR9IG9iamVjdHMgZm9yIHRoZSBmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0IHRpY2tcclxuICogbGFiZWxzIHdoZXJlIG9mZnNldCBpbmRpY2F0ZXMgdGhlIGFuY2hvciBwb2ludCBvZmZzZXQgZnJvbSB0aGUgdG9wIGluIHBpeGVscy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVMYWJlbFNpemVzKGN0eCwgdGlja0ZvbnRzLCB0aWNrcywgY2FjaGVzKSB7XHJcblx0dmFyIGxlbmd0aCA9IHRpY2tzLmxlbmd0aDtcclxuXHR2YXIgd2lkdGhzID0gW107XHJcblx0dmFyIGhlaWdodHMgPSBbXTtcclxuXHR2YXIgb2Zmc2V0cyA9IFtdO1xyXG5cdHZhciB3aWRlc3RMYWJlbFNpemUgPSAwO1xyXG5cdHZhciBoaWdoZXN0TGFiZWxTaXplID0gMDtcclxuXHR2YXIgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWwsIHdpZGVzdCwgaGlnaGVzdDtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcblx0XHRsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xyXG5cdFx0dGlja0ZvbnQgPSB0aWNrc1tpXS5tYWpvciA/IHRpY2tGb250cy5tYWpvciA6IHRpY2tGb250cy5taW5vcjtcclxuXHRcdGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcclxuXHRcdGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcclxuXHRcdGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xyXG5cdFx0d2lkdGggPSBoZWlnaHQgPSAwO1xyXG5cdFx0Ly8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcclxuXHRcdGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRcdHdpZHRoID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XHJcblx0XHRcdGhlaWdodCA9IGxpbmVIZWlnaHQ7XHJcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XHJcblx0XHRcdC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldCdzIG1lYXN1cmUgZWFjaCBlbGVtZW50XHJcblx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuXHRcdFx0XHRuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xyXG5cdFx0XHRcdC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXHJcblx0XHRcdFx0aWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcclxuXHRcdFx0XHRcdHdpZHRoID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XHJcblx0XHRcdFx0XHRoZWlnaHQgKz0gbGluZUhlaWdodDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHdpZHRocy5wdXNoKHdpZHRoKTtcclxuXHRcdGhlaWdodHMucHVzaChoZWlnaHQpO1xyXG5cdFx0b2Zmc2V0cy5wdXNoKGxpbmVIZWlnaHQgLyAyKTtcclxuXHRcdHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xyXG5cdFx0aGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XHJcblx0fVxyXG5cdGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcclxuXHJcblx0d2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcclxuXHRoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xyXG5cclxuXHRmdW5jdGlvbiB2YWx1ZUF0KGlkeCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDAsXHJcblx0XHRcdG9mZnNldDogb2Zmc2V0c1tpZHhdIHx8IDBcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Zmlyc3Q6IHZhbHVlQXQoMCksXHJcblx0XHRsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxyXG5cdFx0d2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXHJcblx0XHRoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpXHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xyXG5cdHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja01hcmtMZW5ndGggOiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY2FsZUxhYmVsSGVpZ2h0KG9wdGlvbnMpIHtcclxuXHR2YXIgZm9udCwgcGFkZGluZztcclxuXHJcblx0aWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0Zm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9ucyk7XHJcblx0cGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xyXG5cclxuXHRyZXR1cm4gZm9udC5saW5lSGVpZ2h0ICsgcGFkZGluZy5oZWlnaHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlRm9udE9wdGlvbnMob3B0aW9ucywgbmVzdGVkT3B0cykge1xyXG5cdHJldHVybiBoZWxwZXJzJDEuZXh0ZW5kKGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQoe1xyXG5cdFx0Zm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkYShuZXN0ZWRPcHRzLmZvbnRGYW1pbHksIG9wdGlvbnMuZm9udEZhbWlseSksXHJcblx0XHRmb250U2l6ZTogdmFsdWVPckRlZmF1bHQkYShuZXN0ZWRPcHRzLmZvbnRTaXplLCBvcHRpb25zLmZvbnRTaXplKSxcclxuXHRcdGZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkYShuZXN0ZWRPcHRzLmZvbnRTdHlsZSwgb3B0aW9ucy5mb250U3R5bGUpLFxyXG5cdFx0bGluZUhlaWdodDogdmFsdWVPckRlZmF1bHQkYShuZXN0ZWRPcHRzLmxpbmVIZWlnaHQsIG9wdGlvbnMubGluZUhlaWdodClcclxuXHR9KSwge1xyXG5cdFx0Y29sb3I6IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmUoW25lc3RlZE9wdHMuZm9udENvbG9yLCBvcHRpb25zLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcl0pXHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVGlja0ZvbnRPcHRpb25zKG9wdGlvbnMpIHtcclxuXHR2YXIgbWlub3IgPSBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMubWlub3IpO1xyXG5cdHZhciBtYWpvciA9IG9wdGlvbnMubWFqb3IuZW5hYmxlZCA/IHBhcnNlRm9udE9wdGlvbnMob3B0aW9ucywgb3B0aW9ucy5tYWpvcikgOiBtaW5vcjtcclxuXHJcblx0cmV0dXJuIHttaW5vcjogbWlub3IsIG1ham9yOiBtYWpvcn07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vblNraXBwZWQodGlja3NUb0ZpbHRlcikge1xyXG5cdHZhciBmaWx0ZXJlZCA9IFtdO1xyXG5cdHZhciBpdGVtLCBpbmRleCwgbGVuO1xyXG5cdGZvciAoaW5kZXggPSAwLCBsZW4gPSB0aWNrc1RvRmlsdGVyLmxlbmd0aDsgaW5kZXggPCBsZW47ICsraW5kZXgpIHtcclxuXHRcdGl0ZW0gPSB0aWNrc1RvRmlsdGVyW2luZGV4XTtcclxuXHRcdGlmICh0eXBlb2YgaXRlbS5faW5kZXggIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmaWx0ZXJlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XHJcblx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcblx0dmFyIGksIGRpZmY7XHJcblxyXG5cdGlmIChsZW4gPCAyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcclxuXHRcdGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRpZmY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgYXhpc0xlbmd0aCwgdGlja3NMaW1pdCkge1xyXG5cdHZhciBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcclxuXHR2YXIgc3BhY2luZyA9ICh0aWNrcy5sZW5ndGggLSAxKSAvIHRpY2tzTGltaXQ7XHJcblx0dmFyIGZhY3RvcnMsIGZhY3RvciwgaSwgaWxlbjtcclxuXHJcblx0Ly8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcclxuXHQvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXHJcblx0aWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XHJcblx0fVxyXG5cclxuXHRmYWN0b3JzID0gaGVscGVycyQxLm1hdGguX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRmYWN0b3IgPSBmYWN0b3JzW2ldO1xyXG5cdFx0aWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcclxuXHRcdFx0cmV0dXJuIGZhY3RvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcclxuXHR2YXIgcmVzdWx0ID0gW107XHJcblx0dmFyIGksIGlsZW47XHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0aWYgKHRpY2tzW2ldLm1ham9yKSB7XHJcblx0XHRcdHJlc3VsdC5wdXNoKGkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHZhciBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xyXG5cdHZhciBpLCB0aWNrO1xyXG5cclxuXHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dGljayA9IHRpY2tzW2ldO1xyXG5cdFx0aWYgKGkgPT09IG5leHQpIHtcclxuXHRcdFx0dGljay5faW5kZXggPSBpO1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0XHRuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZWxldGUgdGljay5sYWJlbDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNraXAodGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XHJcblx0dmFyIHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQkYShtYWpvclN0YXJ0LCAwKTtcclxuXHR2YXIgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQkYShtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHZhciBsZW5ndGgsIGksIHRpY2ssIG5leHQ7XHJcblxyXG5cdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XHJcblx0aWYgKG1ham9yRW5kKSB7XHJcblx0XHRsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XHJcblx0XHRzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcclxuXHR9XHJcblxyXG5cdG5leHQgPSBzdGFydDtcclxuXHJcblx0d2hpbGUgKG5leHQgPCAwKSB7XHJcblx0XHRjb3VudCsrO1xyXG5cdFx0bmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xyXG5cdH1cclxuXHJcblx0Zm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcclxuXHRcdHRpY2sgPSB0aWNrc1tpXTtcclxuXHRcdGlmIChpID09PSBuZXh0KSB7XHJcblx0XHRcdHRpY2suX2luZGV4ID0gaTtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdFx0bmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG52YXIgU2NhbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHJcblx0emVyb0xpbmVJbmRleDogMCxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXHJcblx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7UGFkZGluZ30gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXHJcblx0ICovXHJcblx0Z2V0UGFkZGluZzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bGVmdDogbWUucGFkZGluZ0xlZnQgfHwgMCxcclxuXHRcdFx0dG9wOiBtZS5wYWRkaW5nVG9wIHx8IDAsXHJcblx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcclxuXHRcdFx0Ym90dG9tOiBtZS5wYWRkaW5nQm90dG9tIHx8IDBcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcclxuXHQgKiBAc2luY2UgMi43XHJcblx0ICovXHJcblx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RpY2tzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCogQHByaXZhdGVcclxuXHQqL1xyXG5cdF9nZXRMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XHJcblx0fSxcclxuXHJcblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3lsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxyXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cclxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuU2NhbGUubWVyZ2VUaWNrc09wdGlvbnNcclxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXHJcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG5cdCAqL1xyXG5cdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdC8vIG5vb3BcclxuXHR9LFxyXG5cclxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gdGhlIG1heCB3aWR0aCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gdGhlIG1heCBoZWlnaHQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1hcmdpbnMgLSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZWRnZSBvZiB0aGUgb3RoZXIgc2NhbGVzIGFuZCBlZGdlIG9mIHRoZSBjaGFydFxyXG5cdCAqICAgVGhpcyBzcGFjZSBjb21lcyBmcm9tIHR3byBzb3VyY2VzOlxyXG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcclxuXHQgKiAgICAgLSB0aGlja25lc3Mgb2Ygc2NhbGVzIG9yIGxlZ2VuZHMgaW4gYW5vdGhlciBvcmllbnRhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XHJcblx0XHR2YXIgaSwgaWxlbiwgbGFiZWxzLCB0aWNrcywgc2FtcGxpbmdFbmFibGVkO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXHJcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcclxuXHJcblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcclxuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XHJcblx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdGJvdHRvbTogMFxyXG5cdFx0fSwgbWFyZ2lucyk7XHJcblxyXG5cdFx0bWUuX3RpY2tzID0gbnVsbDtcclxuXHRcdG1lLnRpY2tzID0gbnVsbDtcclxuXHRcdG1lLl9sYWJlbFNpemVzID0gbnVsbDtcclxuXHRcdG1lLl9tYXhMYWJlbExpbmVzID0gMDtcclxuXHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gMDtcclxuXHRcdG1lLmxvbmdlc3RUZXh0Q2FjaGUgPSBtZS5sb25nZXN0VGV4dENhY2hlIHx8IHt9O1xyXG5cdFx0bWUuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xyXG5cdFx0bWUuX2xhYmVsSXRlbXMgPSBudWxsO1xyXG5cclxuXHRcdC8vIERpbWVuc2lvbnNcclxuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xyXG5cclxuXHRcdC8vIERhdGEgbWluL21heFxyXG5cdFx0bWUuYmVmb3JlRGF0YUxpbWl0cygpO1xyXG5cdFx0bWUuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xyXG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XHJcblxyXG5cdFx0Ly8gVGlja3MgLSBgdGhpcy50aWNrc2AgaXMgbm93IERFUFJFQ0FURUQhXHJcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXHJcblx0XHQvLyBhbmQgbXVzdCBub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBvdXRzaWRlIHRoaXMgY2xhc3MuIGB0aGlzLnRpY2tzYCBiZWluZ1xyXG5cdFx0Ly8gYXJvdW5kIGZvciBsb25nIHRpbWUgYW5kIG5vdCBtYXJrZWQgYXMgcHJpdmF0ZSwgd2UgY2FuJ3QgY2hhbmdlIGl0cyBzdHJ1Y3R1cmVcclxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxyXG5cdFx0Ly8gdXNlIHNjYWxlLmdldFRpY2tzKCkgaW5zdGVhZC5cclxuXHJcblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XHJcblxyXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgYnV0IGZvciBCQUNLV0FSRCBDT01QQVQsXHJcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxyXG5cdFx0dGlja3MgPSBtZS5idWlsZFRpY2tzKCkgfHwgW107XHJcblxyXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxyXG5cdFx0dGlja3MgPSBtZS5hZnRlckJ1aWxkVGlja3ModGlja3MpIHx8IHRpY2tzO1xyXG5cclxuXHRcdC8vIEVuc3VyZSB0aWNrcyBjb250YWlucyB0aWNrcyBpbiBuZXcgdGljayBmb3JtYXRcclxuXHRcdGlmICgoIXRpY2tzIHx8ICF0aWNrcy5sZW5ndGgpICYmIG1lLnRpY2tzKSB7XHJcblx0XHRcdHRpY2tzID0gW107XHJcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHR0aWNrcy5wdXNoKHtcclxuXHRcdFx0XHRcdHZhbHVlOiBtZS50aWNrc1tpXSxcclxuXHRcdFx0XHRcdG1ham9yOiBmYWxzZVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX3RpY2tzID0gdGlja3M7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSB0aWNrIHJvdGF0aW9uIGFuZCBmaXQgdXNpbmcgYSBzYW1wbGVkIHN1YnNldCBvZiBsYWJlbHNcclxuXHRcdC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXHJcblx0XHRzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoO1xyXG5cdFx0bGFiZWxzID0gbWUuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSkgOiB0aWNrcyk7XHJcblxyXG5cdFx0Ly8gX2NvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaGVyZSwgb25jZSBmcm9tIGNvcmUuY29udHJvbGxlci51cGRhdGVMYXlvdXQuXHJcblx0XHQvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXHJcblx0XHQvLyBWYXJpYWJsZXMgc2V0IGluIF9jb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlVGlja1JvdGF0aW9uLCBhbmRcclxuXHRcdC8vIGl0J3Mgb2sgdGhhdCBjb29yZGluYXRlcyBhcmUgbm90IGNvcnJlY3QgdGhlcmUsIG9ubHkgZGltZW5zaW9ucyBtYXR0ZXIuXHJcblx0XHRtZS5fY29uZmlndXJlKCk7XHJcblxyXG5cdFx0Ly8gVGljayBSb3RhdGlvblxyXG5cdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XHJcblx0XHRtZS5jYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcclxuXHRcdG1lLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XHJcblxyXG5cdFx0bWUuYmVmb3JlRml0KCk7XHJcblx0XHRtZS5maXQoKTtcclxuXHRcdG1lLmFmdGVyRml0KCk7XHJcblxyXG5cdFx0Ly8gQXV0by1za2lwXHJcblx0XHRtZS5fdGlja3NUb0RyYXcgPSB0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykgPyBtZS5fYXV0b1NraXAodGlja3MpIDogdGlja3M7XHJcblxyXG5cdFx0aWYgKHNhbXBsaW5nRW5hYmxlZCkge1xyXG5cdFx0XHQvLyBHZW5lcmF0ZSBsYWJlbHMgdXNpbmcgYWxsIG5vbi1za2lwcGVkIHRpY2tzXHJcblx0XHRcdGxhYmVscyA9IG1lLl9jb252ZXJ0VGlja3NUb0xhYmVscyhtZS5fdGlja3NUb0RyYXcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcclxuXHJcblx0XHQvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxyXG5cclxuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gVE9ETyh2Myk6IHJlbW92ZSBtaW5TaXplIGFzIGEgcHVibGljIHByb3BlcnR5IGFuZCByZXR1cm4gdmFsdWUgZnJvbSBhbGwgbGF5b3V0IGJveGVzLiBJdCBpcyB1bnVzZWRcclxuXHRcdC8vIG1ha2UgbWF4V2lkdGggYW5kIG1heEhlaWdodCBwcml2YXRlXHJcblx0XHRyZXR1cm4gbWUubWluU2l6ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jb25maWd1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciByZXZlcnNlUGl4ZWxzID0gbWUub3B0aW9ucy50aWNrcy5yZXZlcnNlO1xyXG5cdFx0dmFyIHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xyXG5cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRzdGFydFBpeGVsID0gbWUubGVmdDtcclxuXHRcdFx0ZW5kUGl4ZWwgPSBtZS5yaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0YXJ0UGl4ZWwgPSBtZS50b3A7XHJcblx0XHRcdGVuZFBpeGVsID0gbWUuYm90dG9tO1xyXG5cdFx0XHQvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXHJcblx0XHRcdHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcclxuXHRcdH1cclxuXHRcdG1lLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcclxuXHRcdG1lLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xyXG5cdFx0bWUuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xyXG5cdFx0bWUuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcclxuXHR9LFxyXG5cclxuXHRhZnRlclVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cclxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcclxuXHRcdFx0bWUubGVmdCA9IDA7XHJcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XHJcblxyXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cclxuXHRcdFx0bWUudG9wID0gMDtcclxuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcclxuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcclxuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xyXG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcclxuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xyXG5cdH0sXHJcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xyXG5cdH0sXHJcblxyXG5cdC8vIERhdGEgbGltaXRzXHJcblx0YmVmb3JlRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XHJcblx0fSxcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBoZWxwZXJzJDEubm9vcCxcclxuXHRhZnRlckRhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckRhdGFMaW1pdHMsIFt0aGlzXSk7XHJcblx0fSxcclxuXHJcblx0Ly9cclxuXHRiZWZvcmVCdWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQnVpbGRUaWNrcywgW3RoaXNdKTtcclxuXHR9LFxyXG5cdGJ1aWxkVGlja3M6IGhlbHBlcnMkMS5ub29wLFxyXG5cdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHQvLyB0aWNrcyBpcyBlbXB0eSBmb3Igb2xkIGF4aXMgaW1wbGVtZW50YXRpb25zIGhlcmVcclxuXHRcdGlmIChpc0FycmF5KHRpY2tzKSAmJiB0aWNrcy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCB0aWNrc10pO1xyXG5cdFx0fVxyXG5cdFx0Ly8gU3VwcG9ydCBvbGQgaW1wbGVtZW50YXRpb25zICh0aGF0IG1vZGlmaWVkIGB0aGlzLnRpY2tzYCBkaXJlY3RseSBpbiBidWlsZFRpY2tzKVxyXG5cdFx0bWUudGlja3MgPSBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgbWUudGlja3NdKSB8fCBtZS50aWNrcztcclxuXHRcdHJldHVybiB0aWNrcztcclxuXHR9LFxyXG5cclxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xyXG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XHJcblx0fSxcclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gQ29udmVydCB0aWNrcyB0byBzdHJpbmdzXHJcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAodGlja09wdHMudXNlckNhbGxiYWNrIHx8IHRpY2tPcHRzLmNhbGxiYWNrLCB0aGlzKTtcclxuXHR9LFxyXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XHJcblx0fSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xyXG5cdH0sXHJcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIG51bVRpY2tzID0gbWUuZ2V0VGlja3MoKS5sZW5ndGg7XHJcblx0XHR2YXIgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xyXG5cdFx0dmFyIG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XHJcblx0XHR2YXIgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xyXG5cdFx0dmFyIGxhYmVsU2l6ZXMsIG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0LCBtYXhXaWR0aCwgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XHJcblxyXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhbWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0bWUubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XHJcblx0XHRtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XHJcblx0XHRtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsYWJlbFNpemVzLmhpZ2hlc3Qub2Zmc2V0O1xyXG5cclxuXHRcdC8vIEVzdGltYXRlIHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYmFzZWQgb24gdGhlIGNhbnZhcyB3aWR0aCwgdGhlIG1heGltdW1cclxuXHRcdC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXHJcblx0XHRtYXhXaWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtZS5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgpO1xyXG5cdFx0dGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyBtZS5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcclxuXHJcblx0XHQvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxyXG5cdFx0aWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XHJcblx0XHRcdHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xyXG5cdFx0XHRtYXhIZWlnaHQgPSBtZS5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWRMaW5lcylcclxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRTY2FsZUxhYmVsSGVpZ2h0KG9wdGlvbnMuc2NhbGVMYWJlbCk7XHJcblx0XHRcdG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcclxuXHRcdFx0bGFiZWxSb3RhdGlvbiA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoTWF0aC5taW4oXHJcblx0XHRcdFx0TWF0aC5hc2luKE1hdGgubWluKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIDEpKSxcclxuXHRcdFx0XHRNYXRoLmFzaW4oTWF0aC5taW4obWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgMSkpIC0gTWF0aC5hc2luKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbClcclxuXHRcdFx0KSk7XHJcblx0XHRcdGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcclxuXHR9LFxyXG5cdGFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24sIFt0aGlzXSk7XHJcblx0fSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlRml0OiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xyXG5cdH0sXHJcblx0Zml0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHQvLyBSZXNldFxyXG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0aGVpZ2h0OiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcclxuXHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcclxuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcclxuXHRcdHZhciBkaXNwbGF5ID0gbWUuX2lzVmlzaWJsZSgpO1xyXG5cdFx0dmFyIGlzQm90dG9tID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblxyXG5cdFx0Ly8gV2lkdGhcclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoO1xyXG5cdFx0fSBlbHNlIGlmIChkaXNwbGF5KSB7XHJcblx0XHRcdG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkTGluZU9wdHMpICsgZ2V0U2NhbGVMYWJlbEhlaWdodChzY2FsZUxhYmVsT3B0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGVpZ2h0XHJcblx0XHRpZiAoIWlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxyXG5cdFx0fSBlbHNlIGlmIChkaXNwbGF5KSB7XHJcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZExpbmVPcHRzKSArIGdldFNjYWxlTGFiZWxIZWlnaHQoc2NhbGVMYWJlbE9wdHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xyXG5cdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xyXG5cdFx0XHR2YXIgdGlja0ZvbnRzID0gcGFyc2VUaWNrRm9udE9wdGlvbnModGlja09wdHMpO1xyXG5cdFx0XHR2YXIgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XHJcblx0XHRcdHZhciBmaXJzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMuZmlyc3Q7XHJcblx0XHRcdHZhciBsYXN0TGFiZWxTaXplID0gbGFiZWxTaXplcy5sYXN0O1xyXG5cdFx0XHR2YXIgd2lkZXN0TGFiZWxTaXplID0gbGFiZWxTaXplcy53aWRlc3Q7XHJcblx0XHRcdHZhciBoaWdoZXN0TGFiZWxTaXplID0gbGFiZWxTaXplcy5oaWdoZXN0O1xyXG5cdFx0XHR2YXIgbGluZVNwYWNlID0gdGlja0ZvbnRzLm1pbm9yLmxpbmVIZWlnaHQgKiAwLjQ7XHJcblx0XHRcdHZhciB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmc7XHJcblxyXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XHJcblx0XHRcdFx0Ly8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxyXG5cdFx0XHRcdHZhciBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xyXG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xyXG5cdFx0XHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XHJcblx0XHRcdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcclxuXHJcblx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gc2luUm90YXRpb24gKiB3aWRlc3RMYWJlbFNpemUud2lkdGhcclxuXHRcdFx0XHRcdCsgY29zUm90YXRpb24gKiAoaGlnaGVzdExhYmVsU2l6ZS5oZWlnaHQgLSAoaXNSb3RhdGVkID8gaGlnaGVzdExhYmVsU2l6ZS5vZmZzZXQgOiAwKSlcclxuXHRcdFx0XHRcdCsgKGlzUm90YXRlZCA/IDAgOiBsaW5lU3BhY2UpOyAvLyBwYWRkaW5nXHJcblxyXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xyXG5cclxuXHRcdFx0XHR2YXIgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XHJcblx0XHRcdFx0dmFyIG9mZnNldFJpZ2h0ID0gbWUucmlnaHQgLSBtZS5nZXRQaXhlbEZvclRpY2sobWUuZ2V0VGlja3MoKS5sZW5ndGggLSAxKTtcclxuXHRcdFx0XHR2YXIgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodDtcclxuXHJcblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcclxuXHRcdFx0XHQvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcclxuXHRcdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IGlzQm90dG9tID9cclxuXHRcdFx0XHRcdFx0Y29zUm90YXRpb24gKiBmaXJzdExhYmVsU2l6ZS53aWR0aCArIHNpblJvdGF0aW9uICogZmlyc3RMYWJlbFNpemUub2Zmc2V0IDpcclxuXHRcdFx0XHRcdFx0c2luUm90YXRpb24gKiAoZmlyc3RMYWJlbFNpemUuaGVpZ2h0IC0gZmlyc3RMYWJlbFNpemUub2Zmc2V0KTtcclxuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IGlzQm90dG9tID9cclxuXHRcdFx0XHRcdFx0c2luUm90YXRpb24gKiAobGFzdExhYmVsU2l6ZS5oZWlnaHQgLSBsYXN0TGFiZWxTaXplLm9mZnNldCkgOlxyXG5cdFx0XHRcdFx0XHRjb3NSb3RhdGlvbiAqIGxhc3RMYWJlbFNpemUud2lkdGggKyBzaW5Sb3RhdGlvbiAqIGxhc3RMYWJlbFNpemUub2Zmc2V0O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IGZpcnN0TGFiZWxTaXplLndpZHRoIC8gMjtcclxuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IGxhc3RMYWJlbFNpemUud2lkdGggLyAyO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQWRqdXN0IHBhZGRpbmcgdGFraW5nIGludG8gYWNjb3VudCBjaGFuZ2VzIGluIG9mZnNldHNcclxuXHRcdFx0XHQvLyBhbmQgYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXHJcblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0KSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApICsgMztcclxuXHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQpICogbWUud2lkdGggLyAobWUud2lkdGggLSBvZmZzZXRSaWdodCksIDApICsgMztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXHJcblx0XHRcdFx0Ly8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xyXG5cdFx0XHRcdHZhciBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6XHJcblx0XHRcdFx0XHQvLyB1c2UgbGluZVNwYWNlIGZvciBjb25zaXN0ZW5jeSB3aXRoIGhvcml6b250YWwgYXhpc1xyXG5cdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXHJcblx0XHRcdFx0XHR3aWRlc3RMYWJlbFNpemUud2lkdGggKyB0aWNrUGFkZGluZyArIGxpbmVTcGFjZTtcclxuXHJcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCk7XHJcblxyXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSBmaXJzdExhYmVsU2l6ZS5oZWlnaHQgLyAyO1xyXG5cdFx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSBsYXN0TGFiZWxTaXplLmhlaWdodCAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtZS5oYW5kbGVNYXJnaW5zKCk7XHJcblxyXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRtZS53aWR0aCA9IG1lLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIG1lLm1hcmdpbnMubGVmdCAtIG1lLm1hcmdpbnMucmlnaHQ7XHJcblx0XHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xyXG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gbWUubWFyZ2lucy50b3AgLSBtZS5tYXJnaW5zLmJvdHRvbTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhhbmRsZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGlmIChtZS5tYXJnaW5zKSB7XHJcblx0XHRcdG1lLm1hcmdpbnMubGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0LCBtZS5tYXJnaW5zLmxlZnQpO1xyXG5cdFx0XHRtZS5tYXJnaW5zLnRvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AsIG1lLm1hcmdpbnMudG9wKTtcclxuXHRcdFx0bWUubWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KG1lLnBhZGRpbmdSaWdodCwgbWUubWFyZ2lucy5yaWdodCk7XHJcblx0XHRcdG1lLm1hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSwgbWUubWFyZ2lucy5ib3R0b20pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFmdGVyRml0OiBmdW5jdGlvbigpIHtcclxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XHJcblx0fSxcclxuXHJcblx0Ly8gU2hhcmVkIE1ldGhvZHNcclxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XHJcblx0fSxcclxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxXaWR0aDtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3RcclxuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xyXG5cdFx0Ly8gTnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmaXJzdFxyXG5cdFx0aWYgKGlzTnVsbE9yVW5kZWYocmF3VmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiBOYU47XHJcblx0XHR9XHJcblx0XHQvLyBpc05hTihvYmplY3QpIHJldHVybnMgdHJ1ZSwgc28gbWFrZSBzdXJlIE5hTiBpcyBjaGVja2luZyBmb3IgYSBudW1iZXI7IERpc2NhcmQgSW5maW5pdGUgdmFsdWVzXHJcblx0XHRpZiAoKHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgfHwgcmF3VmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZShyYXdWYWx1ZSkpIHtcclxuXHRcdFx0cmV0dXJuIE5hTjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBpdCBpcyBpbiBmYWN0IGFuIG9iamVjdCwgZGl2ZSBpbiBvbmUgbW9yZSBsZXZlbFxyXG5cdFx0aWYgKHJhd1ZhbHVlKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdFx0aWYgKHJhd1ZhbHVlLnggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS54KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAocmF3VmFsdWUueSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS55KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFZhbHVlIGlzIGdvb2QsIHJldHVybiBpdFxyXG5cdFx0cmV0dXJuIHJhd1ZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdF9jb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGFiZWxzLCBpLCBpbGVuO1xyXG5cclxuXHRcdG1lLnRpY2tzID0gdGlja3MubWFwKGZ1bmN0aW9uKHRpY2spIHtcclxuXHRcdFx0cmV0dXJuIHRpY2sudmFsdWU7XHJcblx0XHR9KTtcclxuXHJcblx0XHRtZS5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcclxuXHJcblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aWNrIGxhYmVscyBidXQgZm9yIEJBQ0tXQVJEXHJcblx0XHQvLyBDT01QQVQsIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBjaGFuZ2VkIGJ5IGNhbGxpbmdcclxuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXHJcblx0XHRsYWJlbHMgPSBtZS5jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykgfHwgbWUudGlja3M7XHJcblxyXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcclxuXHJcblx0XHQvLyBCQUNLV0FSRCBDT01QQVQ6IHN5bmNocm9uaXplIGBfdGlja3NgIHdpdGggbGFiZWxzIChzbyBwb3RlbnRpYWxseSBgdGhpcy50aWNrc2ApXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdHRpY2tzW2ldLmxhYmVsID0gbGFiZWxzW2ldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYWJlbHM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0TGFiZWxTaXplczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fbGFiZWxTaXplcztcclxuXHJcblx0XHRpZiAoIWxhYmVsU2l6ZXMpIHtcclxuXHRcdFx0bWUuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gY29tcHV0ZUxhYmVsU2l6ZXMobWUuY3R4LCBwYXJzZVRpY2tGb250T3B0aW9ucyhtZS5vcHRpb25zLnRpY2tzKSwgbWUuZ2V0VGlja3MoKSwgbWUubG9uZ2VzdFRleHRDYWNoZSk7XHJcblx0XHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhYmVsU2l6ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcGFyc2VWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHZhciBzdGFydCwgZW5kLCBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0c3RhcnQgPSArdGhpcy5nZXRSaWdodFZhbHVlKHZhbHVlWzBdKTtcclxuXHRcdFx0ZW5kID0gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh2YWx1ZVsxXSk7XHJcblx0XHRcdG1pbiA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRtYXggPSBNYXRoLm1heChzdGFydCwgZW5kKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhbHVlID0gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XHJcblx0XHRcdHN0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRlbmQgPSB2YWx1ZTtcclxuXHRcdFx0bWluID0gdmFsdWU7XHJcblx0XHRcdG1heCA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG1pbjogbWluLFxyXG5cdFx0XHRtYXg6IG1heCxcclxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0XHRlbmQ6IGVuZFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQqIEBwcml2YXRlXHJcblx0Ki9cclxuXHRfZ2V0U2NhbGVMYWJlbDogZnVuY3Rpb24ocmF3VmFsdWUpIHtcclxuXHRcdHZhciB2ID0gdGhpcy5fcGFyc2VWYWx1ZShyYXdWYWx1ZSk7XHJcblx0XHRpZiAodi5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiAnWycgKyB2LnN0YXJ0ICsgJywgJyArIHYuZW5kICsgJ10nO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVc2VkIHRvIGdldCB0aGUgdmFsdWUgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGRhdGEgYXQgdGhlIGdpdmVuIGluZGV4XHJcblx0ICogQHBhcmFtIGluZGV4XHJcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxyXG5cdCAqL1xyXG5cdGdldExhYmVsRm9ySW5kZXg6IGhlbHBlcnMkMS5ub29wLFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxyXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xyXG5cdCAqIEBwYXJhbSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBpbmRleFxyXG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcclxuXHQgKi9cclxuXHRnZXRQaXhlbEZvclZhbHVlOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcclxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcGFyYW0gcGl4ZWxcclxuXHQgKi9cclxuXHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzJDEubm9vcCxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcclxuXHRcdHZhciBudW1UaWNrcyA9IG1lLl90aWNrcy5sZW5ndGg7XHJcblx0XHR2YXIgdGlja1dpZHRoID0gMSAvIE1hdGgubWF4KG51bVRpY2tzIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4IDwgMCB8fCBpbmRleCA+IG51bVRpY2tzIC0gMVxyXG5cdFx0XHQ/IG51bGxcclxuXHRcdFx0OiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoaW5kZXggKiB0aWNrV2lkdGggKyAob2Zmc2V0ID8gdGlja1dpZHRoIC8gMiA6IDApKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcclxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcclxuXHQgKi9cclxuXHRnZXRQaXhlbEZvckRlY2ltYWw6IGZ1bmN0aW9uKGRlY2ltYWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKG1lLl9yZXZlcnNlUGl4ZWxzKSB7XHJcblx0XHRcdGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWUuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogbWUuX2xlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRnZXREZWNpbWFsRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHR2YXIgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXHJcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXHJcblx0ICovXHJcblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0QmFzZVZhbHVlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWluID0gbWUubWluO1xyXG5cdFx0dmFyIG1heCA9IG1lLm1heDtcclxuXHJcblx0XHRyZXR1cm4gbWUuYmVnaW5BdFplcm8gPyAwIDpcclxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcclxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcclxuXHRcdFx0MDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2F1dG9Ta2lwOiBmdW5jdGlvbih0aWNrcykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgYXhpc0xlbmd0aCA9IG1lLl9sZW5ndGg7XHJcblx0XHR2YXIgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgYXhpc0xlbmd0aCAvIG1lLl90aWNrU2l6ZSgpICsgMTtcclxuXHRcdHZhciBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xyXG5cdFx0dmFyIG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XHJcblx0XHR2YXIgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XHJcblx0XHR2YXIgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcclxuXHRcdHZhciBpLCBpbGVuLCBzcGFjaW5nLCBhdmdNYWpvclNwYWNpbmc7XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIHRvbyBtYW55IG1ham9yIHRpY2tzIHRvIGRpc3BsYXkgdGhlbSBhbGxcclxuXHRcdGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XHJcblx0XHRcdHNraXBNYWpvcnModGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XHJcblx0XHRcdHJldHVybiBub25Ta2lwcGVkKHRpY2tzKTtcclxuXHRcdH1cclxuXHJcblx0XHRzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCBheGlzTGVuZ3RoLCB0aWNrc0xpbWl0KTtcclxuXHJcblx0XHRpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRcdHNraXAodGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0YXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpIDogbnVsbDtcclxuXHRcdFx0c2tpcCh0aWNrcywgc3BhY2luZywgaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xyXG5cdFx0XHRza2lwKHRpY2tzLCBzcGFjaW5nLCBsYXN0LCBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XHJcblx0XHRcdHJldHVybiBub25Ta2lwcGVkKHRpY2tzKTtcclxuXHRcdH1cclxuXHRcdHNraXAodGlja3MsIHNwYWNpbmcpO1xyXG5cdFx0cmV0dXJuIG5vblNraXBwZWQodGlja3MpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3RpY2tTaXplOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXHJcblx0XHR2YXIgcm90ID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcclxuXHRcdHZhciBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcclxuXHRcdHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcclxuXHJcblx0XHR2YXIgbGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XHJcblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xyXG5cdFx0dmFyIHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcclxuXHRcdHZhciBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXHJcblx0XHRyZXR1cm4gbWUuaXNIb3Jpem9udGFsKClcclxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXHJcblx0XHRcdDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5vcHRpb25zLmRpc3BsYXk7XHJcblx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcclxuXHJcblx0XHRpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XHJcblx0XHRcdHJldHVybiAhIWRpc3BsYXk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2hlbiAnYXV0bycsIHRoZSBzY2FsZSBpcyB2aXNpYmxlIGlmIGF0IGxlYXN0IG9uZSBhc3NvY2lhdGVkIGRhdGFzZXQgaXMgdmlzaWJsZS5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xyXG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcclxuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY29tcHV0ZUdyaWRMaW5lSXRlbXM6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGdyaWRMaW5lcyA9IG9wdGlvbnMuZ3JpZExpbmVzO1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHZhciBvZmZzZXRHcmlkTGluZXMgPSBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIHRpY2tzID0gbWUuX3RpY2tzVG9EcmF3O1xyXG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldEdyaWRMaW5lcyA/IDEgOiAwKTtcclxuXHJcblx0XHR2YXIgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkTGluZXMpO1xyXG5cdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xyXG5cdFx0dmFyIGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xyXG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XHJcblx0XHR2YXIgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHRcdHJldHVybiBhbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcclxuXHRcdH07XHJcblx0XHR2YXIgYm9yZGVyVmFsdWUsIGksIHRpY2ssIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcclxuXHRcdHZhciB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldDtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XHJcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5ib3R0b20pO1xyXG5cdFx0XHR0eTEgPSBtZS5ib3R0b20gLSB0bDtcclxuXHRcdFx0dHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR5MiA9IGNoYXJ0QXJlYS5ib3R0b207XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUudG9wKTtcclxuXHRcdFx0eTEgPSBjaGFydEFyZWEudG9wO1xyXG5cdFx0XHR5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xyXG5cdFx0XHR0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHR5MiA9IG1lLnRvcCArIHRsO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS5yaWdodCk7XHJcblx0XHRcdHR4MSA9IG1lLnJpZ2h0IC0gdGw7XHJcblx0XHRcdHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0eDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLmxlZnQpO1xyXG5cdFx0XHR4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xyXG5cdFx0XHR4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XHJcblx0XHRcdHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcclxuXHRcdFx0dHgyID0gbWUubGVmdCArIHRsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgKytpKSB7XHJcblx0XHRcdHRpY2sgPSB0aWNrc1tpXSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcclxuXHRcdFx0aWYgKGlzTnVsbE9yVW5kZWYodGljay5sYWJlbCkgJiYgaSA8IHRpY2tzLmxlbmd0aCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaSA9PT0gbWUuemVyb0xpbmVJbmRleCAmJiBvcHRpb25zLm9mZnNldCA9PT0gb2Zmc2V0R3JpZExpbmVzKSB7XHJcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XHJcblx0XHRcdFx0bGluZVdpZHRoID0gZ3JpZExpbmVzLnplcm9MaW5lV2lkdGg7XHJcblx0XHRcdFx0bGluZUNvbG9yID0gZ3JpZExpbmVzLnplcm9MaW5lQ29sb3I7XHJcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XHJcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpLCAxKTtcclxuXHRcdFx0XHRsaW5lQ29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCBpLCAncmdiYSgwLDAsMCwwLjEpJyk7XHJcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoIHx8IFtdO1xyXG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUobWUsIHRpY2suX2luZGV4IHx8IGksIG9mZnNldEdyaWRMaW5lcyk7XHJcblxyXG5cdFx0XHQvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXHJcblx0XHRcdGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhbGlnbmVkTGluZVZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xyXG5cclxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpdGVtcy5wdXNoKHtcclxuXHRcdFx0XHR0eDE6IHR4MSxcclxuXHRcdFx0XHR0eTE6IHR5MSxcclxuXHRcdFx0XHR0eDI6IHR4MixcclxuXHRcdFx0XHR0eTI6IHR5MixcclxuXHRcdFx0XHR4MTogeDEsXHJcblx0XHRcdFx0eTE6IHkxLFxyXG5cdFx0XHRcdHgyOiB4MixcclxuXHRcdFx0XHR5MjogeTIsXHJcblx0XHRcdFx0d2lkdGg6IGxpbmVXaWR0aCxcclxuXHRcdFx0XHRjb2xvcjogbGluZUNvbG9yLFxyXG5cdFx0XHRcdGJvcmRlckRhc2g6IGJvcmRlckRhc2gsXHJcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogYm9yZGVyRGFzaE9mZnNldCxcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aXRlbXMudGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcclxuXHRcdGl0ZW1zLmJvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIGl0ZW1zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NvbXB1dGVMYWJlbEl0ZW1zOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBvcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cdFx0dmFyIHRpY2tzID0gbWUuX3RpY2tzVG9EcmF3O1xyXG5cdFx0dmFyIGZvbnRzID0gcGFyc2VUaWNrRm9udE9wdGlvbnMob3B0aW9uVGlja3MpO1xyXG5cdFx0dmFyIHRpY2tQYWRkaW5nID0gb3B0aW9uVGlja3MucGFkZGluZztcclxuXHRcdHZhciB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZExpbmVzKTtcclxuXHRcdHZhciByb3RhdGlvbiA9IC1oZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xyXG5cdFx0dmFyIGl0ZW1zID0gW107XHJcblx0XHR2YXIgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XHJcblx0XHRcdHkgPSBtZS5ib3R0b20gLSB0bCAtIHRpY2tQYWRkaW5nO1xyXG5cdFx0XHR0ZXh0QWxpZ24gPSAhcm90YXRpb24gPyAnY2VudGVyJyA6ICdsZWZ0JztcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcblx0XHRcdHkgPSBtZS50b3AgKyB0bCArIHRpY2tQYWRkaW5nO1xyXG5cdFx0XHR0ZXh0QWxpZ24gPSAhcm90YXRpb24gPyAnY2VudGVyJyA6ICdyaWdodCc7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuXHRcdFx0eCA9IG1lLnJpZ2h0IC0gKGlzTWlycm9yZWQgPyAwIDogdGwpIC0gdGlja1BhZGRpbmc7XHJcblx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAnbGVmdCcgOiAncmlnaHQnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IG1lLmxlZnQgKyAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgKyB0aWNrUGFkZGluZztcclxuXHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR0aWNrID0gdGlja3NbaV07XHJcblx0XHRcdGxhYmVsID0gdGljay5sYWJlbDtcclxuXHJcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcclxuXHRcdFx0aWYgKGlzTnVsbE9yVW5kZWYobGFiZWwpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBpeGVsID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKHRpY2suX2luZGV4IHx8IGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XHJcblx0XHRcdGZvbnQgPSB0aWNrLm1ham9yID8gZm9udHMubWFqb3IgOiBmb250cy5taW5vcjtcclxuXHRcdFx0bGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcclxuXHRcdFx0bGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xyXG5cclxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRcdHggPSBwaXhlbDtcclxuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gcG9zaXRpb24gPT09ICd0b3AnXHJcblx0XHRcdFx0XHQ/ICgoIXJvdGF0aW9uID8gMC41IDogMSkgLSBsaW5lQ291bnQpICogbGluZUhlaWdodFxyXG5cdFx0XHRcdFx0OiAoIXJvdGF0aW9uID8gMC41IDogMCkgKiBsaW5lSGVpZ2h0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHkgPSBwaXhlbDtcclxuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGl0ZW1zLnB1c2goe1xyXG5cdFx0XHRcdHg6IHgsXHJcblx0XHRcdFx0eTogeSxcclxuXHRcdFx0XHRyb3RhdGlvbjogcm90YXRpb24sXHJcblx0XHRcdFx0bGFiZWw6IGxhYmVsLFxyXG5cdFx0XHRcdGZvbnQ6IGZvbnQsXHJcblx0XHRcdFx0dGV4dE9mZnNldDogdGV4dE9mZnNldCxcclxuXHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXRlbXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZHJhd0dyaWQ6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBncmlkTGluZXMgPSBtZS5vcHRpb25zLmdyaWRMaW5lcztcclxuXHJcblx0XHRpZiAoIWdyaWRMaW5lcy5kaXNwbGF5KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgYWxpZ25QaXhlbCA9IGhlbHBlcnMkMS5fYWxpZ25QaXhlbDtcclxuXHRcdHZhciBheGlzV2lkdGggPSBncmlkTGluZXMuZHJhd0JvcmRlciA/IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCAwLCAwKSA6IDA7XHJcblx0XHR2YXIgaXRlbXMgPSBtZS5fZ3JpZExpbmVJdGVtcyB8fCAobWUuX2dyaWRMaW5lSXRlbXMgPSBtZS5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XHJcblx0XHR2YXIgd2lkdGgsIGNvbG9yLCBpLCBpbGVuLCBpdGVtO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aXRlbSA9IGl0ZW1zW2ldO1xyXG5cdFx0XHR3aWR0aCA9IGl0ZW0ud2lkdGg7XHJcblx0XHRcdGNvbG9yID0gaXRlbS5jb2xvcjtcclxuXHJcblx0XHRcdGlmICh3aWR0aCAmJiBjb2xvcikge1xyXG5cdFx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG5cdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChpdGVtLmJvcmRlckRhc2gpO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gaXRlbS5ib3JkZXJEYXNoT2Zmc2V0O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdUaWNrcykge1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhpdGVtLnR4MSwgaXRlbS50eTEpO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhpdGVtLnR4MiwgaXRlbS50eTIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3T25DaGFydEFyZWEpIHtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oaXRlbS54MSwgaXRlbS55MSk7XHJcblx0XHRcdFx0XHRjdHgubGluZVRvKGl0ZW0ueDIsIGl0ZW0ueTIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXhpc1dpZHRoKSB7XHJcblx0XHRcdC8vIERyYXcgdGhlIGxpbmUgYXQgdGhlIGVkZ2Ugb2YgdGhlIGF4aXNcclxuXHRcdFx0dmFyIGZpcnN0TGluZVdpZHRoID0gYXhpc1dpZHRoO1xyXG5cdFx0XHR2YXIgbGFzdExpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpdGVtcy50aWNrc0xlbmd0aCAtIDEsIDEpO1xyXG5cdFx0XHR2YXIgYm9yZGVyVmFsdWUgPSBpdGVtcy5ib3JkZXJWYWx1ZTtcclxuXHRcdFx0dmFyIHgxLCB4MiwgeTEsIHkyO1xyXG5cclxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XHJcblx0XHRcdFx0eDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcclxuXHRcdFx0XHR5MSA9IHkyID0gYm9yZGVyVmFsdWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0eTEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcclxuXHRcdFx0XHR5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcclxuXHRcdFx0XHR4MSA9IHgyID0gYm9yZGVyVmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSBheGlzV2lkdGg7XHJcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xyXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuXHRcdFx0Y3R4LmxpbmVUbyh4MiwgeTIpO1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZHJhd0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHJcblx0XHRpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgaXRlbXMgPSBtZS5fbGFiZWxJdGVtcyB8fCAobWUuX2xhYmVsSXRlbXMgPSBtZS5fY29tcHV0ZUxhYmVsSXRlbXMoKSk7XHJcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgaXRlbSwgdGlja0ZvbnQsIGxhYmVsLCB5O1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aXRlbSA9IGl0ZW1zW2ldO1xyXG5cdFx0XHR0aWNrRm9udCA9IGl0ZW0uZm9udDtcclxuXHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcclxuXHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0Y3R4LnRyYW5zbGF0ZShpdGVtLngsIGl0ZW0ueSk7XHJcblx0XHRcdGN0eC5yb3RhdGUoaXRlbS5yb3RhdGlvbik7XHJcblx0XHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja0ZvbnQuY29sb3I7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGl0ZW0udGV4dEFsaWduO1xyXG5cclxuXHRcdFx0bGFiZWwgPSBpdGVtLmxhYmVsO1xyXG5cdFx0XHR5ID0gaXRlbS50ZXh0T2Zmc2V0O1xyXG5cdFx0XHRpZiAoaXNBcnJheShsYWJlbCkpIHtcclxuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXHJcblx0XHRcdFx0XHRjdHguZmlsbFRleHQoJycgKyBsYWJlbFtqXSwgMCwgeSk7XHJcblx0XHRcdFx0XHR5ICs9IHRpY2tGb250LmxpbmVIZWlnaHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN0eC5maWxsVGV4dChsYWJlbCwgMCwgeSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9kcmF3VGl0bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgc2NhbGVMYWJlbCA9IG9wdGlvbnMuc2NhbGVMYWJlbDtcclxuXHJcblx0XHRpZiAoIXNjYWxlTGFiZWwuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNjYWxlTGFiZWxGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRhKHNjYWxlTGFiZWwuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQoc2NhbGVMYWJlbCk7XHJcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcclxuXHRcdHZhciBoYWxmTGluZUhlaWdodCA9IHNjYWxlTGFiZWxGb250LmxpbmVIZWlnaHQgLyAyO1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuXHRcdHZhciByb3RhdGlvbiA9IDA7XHJcblx0XHR2YXIgc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZO1xyXG5cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRzY2FsZUxhYmVsWCA9IG1lLmxlZnQgKyBtZS53aWR0aCAvIDI7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxyXG5cdFx0XHRzY2FsZUxhYmVsWSA9IHBvc2l0aW9uID09PSAnYm90dG9tJ1xyXG5cdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cclxuXHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XHJcblx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XHJcblx0XHRcdFx0PyBtZS5sZWZ0ICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3BcclxuXHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XHJcblx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgbWUuaGVpZ2h0IC8gMjtcclxuXHRcdFx0cm90YXRpb24gPSBpc0xlZnQgPyAtMC41ICogTWF0aC5QSSA6IDAuNSAqIE1hdGguUEk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC50cmFuc2xhdGUoc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZKTtcclxuXHRcdGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHNjYWxlTGFiZWxGb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxyXG5cdFx0Y3R4LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5zdHJpbmc7XHJcblx0XHRjdHguZmlsbFRleHQoc2NhbGVMYWJlbC5sYWJlbFN0cmluZywgMCwgMCk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH0sXHJcblxyXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWUuX2RyYXdHcmlkKGNoYXJ0QXJlYSk7XHJcblx0XHRtZS5fZHJhd1RpdGxlKCk7XHJcblx0XHRtZS5fZHJhd0xhYmVscygpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2xheWVyczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcclxuXHRcdHZhciBneiA9IG9wdHMuZ3JpZExpbmVzICYmIG9wdHMuZ3JpZExpbmVzLnogfHwgMDtcclxuXHJcblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSB8fCB0eiA9PT0gZ3ogfHwgbWUuZHJhdyAhPT0gbWUuX2RyYXcpIHtcclxuXHRcdFx0Ly8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogZHJhdyBoYXMgYmVlbiBvdmVycmlkZGVuIGJ5IGN1c3RvbSBzY2FsZVxyXG5cdFx0XHRyZXR1cm4gW3tcclxuXHRcdFx0XHR6OiB0eixcclxuXHRcdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdG1lLmRyYXcuYXBwbHkobWUsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0ejogZ3osXHJcblx0XHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdG1lLl9kcmF3R3JpZC5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRtZS5fZHJhd1RpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB7XHJcblx0XHRcdHo6IHR6LFxyXG5cdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRtZS5fZHJhd0xhYmVscy5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXM6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRyZXR1cm4gbWUuY2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKG1ldGEpIHtcclxuXHRcdFx0XHRyZXR1cm4gKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSlcclxuXHRcdFx0XHRcdCYmIChpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZCk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5TY2FsZS5wcm90b3R5cGUuX2RyYXcgPSBTY2FsZS5wcm90b3R5cGUuZHJhdztcclxuXHJcbnZhciBjb3JlX3NjYWxlID0gU2NhbGU7XG5cbnZhciBpc051bGxPclVuZGVmJDEgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcclxuXHJcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xyXG5cdHBvc2l0aW9uOiAnYm90dG9tJ1xyXG59O1xyXG5cclxudmFyIHNjYWxlX2NhdGVnb3J5ID0gY29yZV9zY2FsZS5leHRlbmQoe1xyXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBsYWJlbHMgPSBtZS5fZ2V0TGFiZWxzKCk7XHJcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBtaW4gPSB0aWNrc09wdHMubWluO1xyXG5cdFx0dmFyIG1heCA9IHRpY2tzT3B0cy5tYXg7XHJcblx0XHR2YXIgbWluSW5kZXggPSAwO1xyXG5cdFx0dmFyIG1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XHJcblx0XHR2YXIgZmluZEluZGV4O1xyXG5cclxuXHRcdGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcclxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWluKTtcclxuXHRcdFx0aWYgKGZpbmRJbmRleCA+PSAwKSB7XHJcblx0XHRcdFx0bWluSW5kZXggPSBmaW5kSW5kZXg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWF4IHZhbHVlXHJcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1heCk7XHJcblx0XHRcdGlmIChmaW5kSW5kZXggPj0gMCkge1xyXG5cdFx0XHRcdG1heEluZGV4ID0gZmluZEluZGV4O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubWluSW5kZXggPSBtaW5JbmRleDtcclxuXHRcdG1lLm1heEluZGV4ID0gbWF4SW5kZXg7XHJcblx0XHRtZS5taW4gPSBsYWJlbHNbbWluSW5kZXhdO1xyXG5cdFx0bWUubWF4ID0gbGFiZWxzW21heEluZGV4XTtcclxuXHR9LFxyXG5cclxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cdFx0dmFyIG1pbkluZGV4ID0gbWUubWluSW5kZXg7XHJcblx0XHR2YXIgbWF4SW5kZXggPSBtZS5tYXhJbmRleDtcclxuXHJcblx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxyXG5cdFx0bWUudGlja3MgPSAobWluSW5kZXggPT09IDAgJiYgbWF4SW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW5JbmRleCwgbWF4SW5kZXggKyAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblxyXG5cdFx0aWYgKGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZUlkKCkgPT09IG1lLmlkKSB7XHJcblx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lLl9nZXRMYWJlbHMoKVtpbmRleF07XHJcblx0fSxcclxuXHJcblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xyXG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3M7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuX2NvbmZpZ3VyZS5jYWxsKG1lKTtcclxuXHJcblx0XHRpZiAoIW1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxyXG5cdFx0XHRtZS5fcmV2ZXJzZVBpeGVscyA9ICFtZS5fcmV2ZXJzZVBpeGVscztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRpY2tzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fc3RhcnRWYWx1ZSA9IG1lLm1pbkluZGV4IC0gKG9mZnNldCA/IDAuNSA6IDApO1xyXG5cdFx0bWUuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcclxuXHR9LFxyXG5cclxuXHQvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcclxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB2YWx1ZUNhdGVnb3J5LCBsYWJlbHMsIGlkeDtcclxuXHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMShpbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYkMShkYXRhc2V0SW5kZXgpKSB7XHJcblx0XHRcdHZhbHVlID0gbWUuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxyXG5cdFx0Ly8gbm90IHRoZSBpbmRleCBvZiB0aGUgc2NhbGUuIFdlIG5lZWQgdG8gY2hhbmdlIHRoYXQuXHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMSh2YWx1ZSkpIHtcclxuXHRcdFx0dmFsdWVDYXRlZ29yeSA9IG1lLmlzSG9yaXpvbnRhbCgpID8gdmFsdWUueCA6IHZhbHVlLnk7XHJcblx0XHR9XHJcblx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcclxuXHRcdFx0bGFiZWxzID0gbWUuX2dldExhYmVscygpO1xyXG5cdFx0XHR2YWx1ZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh2YWx1ZUNhdGVnb3J5LCB2YWx1ZSk7XHJcblx0XHRcdGlkeCA9IGxhYmVscy5pbmRleE9mKHZhbHVlKTtcclxuXHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XHJcblx0XHRcdGlmIChpc05hTihpbmRleCkpIHtcclxuXHRcdFx0XHRpbmRleCA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKChpbmRleCAtIG1lLl9zdGFydFZhbHVlKSAvIG1lLl92YWx1ZVJhbmdlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgdGlja3MgPSB0aGlzLnRpY2tzO1xyXG5cdFx0cmV0dXJuIGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDFcclxuXHRcdFx0PyBudWxsXHJcblx0XHRcdDogdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XSwgaW5kZXggKyB0aGlzLm1pbkluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB2YWx1ZSA9IE1hdGgucm91bmQobWUuX3N0YXJ0VmFsdWUgKyBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogbWUuX3ZhbHVlUmFuZ2UpO1xyXG5cdFx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgbWUudGlja3MubGVuZ3RoIC0gMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmJvdHRvbTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXHJcbnZhciBfZGVmYXVsdHMgPSBkZWZhdWx0Q29uZmlnO1xuc2NhbGVfY2F0ZWdvcnkuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuXG52YXIgbm9vcCA9IGhlbHBlcnMkMS5ub29wO1xyXG52YXIgaXNOdWxsT3JVbmRlZiQyID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWY7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzXHJcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xyXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGFycmF5IG9mIHRpY2sgdmFsdWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcclxuXHR2YXIgdGlja3MgPSBbXTtcclxuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcclxuXHQvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xyXG5cdC8vIGZvciBkZXRhaWxzLlxyXG5cclxuXHR2YXIgTUlOX1NQQUNJTkcgPSAxZS0xNDtcclxuXHR2YXIgc3RlcFNpemUgPSBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZTtcclxuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XHJcblx0dmFyIG1heE51bVNwYWNlcyA9IGdlbmVyYXRpb25PcHRpb25zLm1heFRpY2tzIC0gMTtcclxuXHR2YXIgbWluID0gZ2VuZXJhdGlvbk9wdGlvbnMubWluO1xyXG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XHJcblx0dmFyIHByZWNpc2lvbiA9IGdlbmVyYXRpb25PcHRpb25zLnByZWNpc2lvbjtcclxuXHR2YXIgcm1pbiA9IGRhdGFSYW5nZS5taW47XHJcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xyXG5cdHZhciBzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcclxuXHR2YXIgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XHJcblxyXG5cdC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXHJcblx0Ly8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xyXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZiQyKG1pbikgJiYgaXNOdWxsT3JVbmRlZiQyKG1heCkpIHtcclxuXHRcdHJldHVybiBbcm1pbiwgcm1heF07XHJcblx0fVxyXG5cclxuXHRudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XHJcblx0aWYgKG51bVNwYWNlcyA+IG1heE51bVNwYWNlcykge1xyXG5cdFx0Ly8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcclxuXHRcdHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xyXG5cdH1cclxuXHJcblx0aWYgKHN0ZXBTaXplIHx8IGlzTnVsbE9yVW5kZWYkMihwcmVjaXNpb24pKSB7XHJcblx0XHQvLyBJZiBhIHByZWNpc2lvbiBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgZmFjdG9yIGJhc2VkIG9uIHNwYWNpbmdcclxuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXHJcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcclxuXHRcdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XHJcblx0fVxyXG5cclxuXHRuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xyXG5cdG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcclxuXHJcblx0Ly8gSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGlzIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxyXG5cdGlmIChzdGVwU2l6ZSkge1xyXG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXHJcblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMihtaW4pICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtaW4gLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcclxuXHRcdFx0bmljZU1pbiA9IG1pbjtcclxuXHRcdH1cclxuXHRcdGlmICghaXNOdWxsT3JVbmRlZiQyKG1heCkgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1heCAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xyXG5cdFx0XHRuaWNlTWF4ID0gbWF4O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0bnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XHJcblx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxyXG5cdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcclxuXHRcdG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XHJcblx0fVxyXG5cclxuXHRuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcclxuXHRuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcclxuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYkMihtaW4pID8gbmljZU1pbiA6IG1pbik7XHJcblx0Zm9yICh2YXIgaiA9IDE7IGogPCBudW1TcGFjZXM7ICsraikge1xyXG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XHJcblx0fVxyXG5cdHRpY2tzLnB1c2goaXNOdWxsT3JVbmRlZiQyKG1heCkgPyBuaWNlTWF4IDogbWF4KTtcclxuXHJcblx0cmV0dXJuIHRpY2tzO1xyXG59XHJcblxyXG52YXIgc2NhbGVfbGluZWFyYmFzZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcclxuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuICt2YWx1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XHJcblxyXG5cdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcclxuXHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcclxuXHRcdC8vIGF4aXMsIHRoZXkgY2FuIG1hbnVhbGx5IG92ZXJyaWRlIGl0XHJcblx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcclxuXHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5taW4pO1xyXG5cdFx0XHR2YXIgbWF4U2lnbiA9IGhlbHBlcnMkMS5zaWduKG1lLm1heCk7XHJcblxyXG5cdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcclxuXHRcdFx0XHQvLyBtb3ZlIHRoZSB0b3AgdXAgdG8gMFxyXG5cdFx0XHRcdG1lLm1heCA9IDA7XHJcblx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcclxuXHRcdFx0XHQvLyBtb3ZlIHRoZSBib3R0b20gZG93biB0byAwXHJcblx0XHRcdFx0bWUubWluID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzZXRNaW4gPSB0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZDtcclxuXHRcdHZhciBzZXRNYXggPSB0aWNrT3B0cy5tYXggIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bWUubWluID0gdGlja09wdHMubWluO1xyXG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XHJcblx0XHRcdFx0bWUubWluID0gdGlja09wdHMuc3VnZ2VzdGVkTWluO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aWNrT3B0cy5tYXggIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XHJcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcclxuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCB0aWNrT3B0cy5zdWdnZXN0ZWRNYXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNldE1pbiAhPT0gc2V0TWF4KSB7XHJcblx0XHRcdC8vIFdlIHNldCB0aGUgbWluIG9yIHRoZSBtYXggYnV0IG5vdCBib3RoLlxyXG5cdFx0XHQvLyBTbyBlbnN1cmUgdGhhdCBvdXIgcmFuZ2UgaXMgZ29vZFxyXG5cdFx0XHQvLyBJbnZlcnRlZCBvciAwIGxlbmd0aCByYW5nZSBjYW4gaGFwcGVuIHdoZW5cclxuXHRcdFx0Ly8gdGlja3MubWluIGlzIHNldCwgYW5kIG5vIGRhdGFzZXRzIGFyZSB2aXNpYmxlXHJcblx0XHRcdGlmIChtZS5taW4gPj0gbWUubWF4KSB7XHJcblx0XHRcdFx0aWYgKHNldE1pbikge1xyXG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWluICsgMTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bWUubWluID0gbWUubWF4IC0gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcclxuXHRcdFx0bWUubWF4Kys7XHJcblxyXG5cdFx0XHRpZiAoIXRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XHJcblx0XHRcdFx0bWUubWluLS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XHJcblx0XHR2YXIgc3RlcFNpemUgPSB0aWNrT3B0cy5zdGVwU2l6ZTtcclxuXHRcdHZhciBtYXhUaWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdDtcclxuXHRcdHZhciBtYXhUaWNrcztcclxuXHJcblx0XHRpZiAoc3RlcFNpemUpIHtcclxuXHRcdFx0bWF4VGlja3MgPSBNYXRoLmNlaWwobWUubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcihtZS5taW4gLyBzdGVwU2l6ZSkgKyAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWF4VGlja3MgPSBtZS5fY29tcHV0ZVRpY2tMaW1pdCgpO1xyXG5cdFx0XHRtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4VGlja3NMaW1pdCkge1xyXG5cdFx0XHRtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF4VGlja3M7XHJcblx0fSxcclxuXHJcblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHR9LFxyXG5cclxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXHJcblxyXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XHJcblxyXG5cdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXHJcblx0XHQvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcclxuXHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXHJcblx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXHJcblx0XHR2YXIgbWF4VGlja3MgPSBtZS5nZXRUaWNrTGltaXQoKTtcclxuXHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xyXG5cclxuXHRcdHZhciBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcclxuXHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxyXG5cdFx0XHRtaW46IHRpY2tPcHRzLm1pbixcclxuXHRcdFx0bWF4OiB0aWNrT3B0cy5tYXgsXHJcblx0XHRcdHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxyXG5cdFx0XHRzdGVwU2l6ZTogaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZpeGVkU3RlcFNpemUsIHRpY2tPcHRzLnN0ZXBTaXplKVxyXG5cdFx0fTtcclxuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgbWUpO1xyXG5cclxuXHRcdG1lLmhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcygpO1xyXG5cclxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcclxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxyXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XHJcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcclxuXHJcblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcclxuXHRcdFx0bWUuZW5kID0gbWUubWluO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XHJcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0bWUudGlja3NBc051bWJlcnMgPSBtZS50aWNrcy5zbGljZSgpO1xyXG5cdFx0bWUuemVyb0xpbmVJbmRleCA9IG1lLnRpY2tzLmluZGV4T2YoMCk7XHJcblxyXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XHJcblx0fSxcclxuXHJcblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpY2tzID0gbWUuZ2V0VGlja3MoKTtcclxuXHRcdHZhciBzdGFydCA9IG1lLm1pbjtcclxuXHRcdHZhciBlbmQgPSBtZS5tYXg7XHJcblx0XHR2YXIgb2Zmc2V0O1xyXG5cclxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLl9jb25maWd1cmUuY2FsbChtZSk7XHJcblxyXG5cdFx0aWYgKG1lLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xyXG5cdFx0XHRvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xyXG5cdFx0XHRzdGFydCAtPSBvZmZzZXQ7XHJcblx0XHRcdGVuZCArPSBvZmZzZXQ7XHJcblx0XHR9XHJcblx0XHRtZS5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xyXG5cdFx0bWUuX2VuZFZhbHVlID0gZW5kO1xyXG5cdFx0bWUuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcclxuXHR9XHJcbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyQxID0ge1xyXG5cdHBvc2l0aW9uOiAnbGVmdCcsXHJcblx0dGlja3M6IHtcclxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXHJcblx0fVxyXG59O1xyXG5cclxudmFyIERFRkFVTFRfTUlOID0gMDtcclxudmFyIERFRkFVTFRfTUFYID0gMTtcclxuXHJcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja2VkLCBtZXRhKSB7XHJcblx0dmFyIGtleSA9IFtcclxuXHRcdG1ldGEudHlwZSxcclxuXHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcclxuXHRcdHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgPyBtZXRhLmluZGV4IDogJycsXHJcblx0XHRtZXRhLnN0YWNrXHJcblx0XS5qb2luKCcuJyk7XHJcblxyXG5cdGlmIChzdGFja3Nba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRzdGFja3Nba2V5XSA9IHtcclxuXHRcdFx0cG9zOiBbXSxcclxuXHRcdFx0bmVnOiBbXVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzdGFja3Nba2V5XTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhY2tEYXRhKHNjYWxlLCBzdGFja3MsIG1ldGEsIGRhdGEpIHtcclxuXHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XHJcblx0dmFyIHN0YWNrZWQgPSBvcHRzLnN0YWNrZWQ7XHJcblx0dmFyIHN0YWNrID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrZWQsIG1ldGEpO1xyXG5cdHZhciBwb3MgPSBzdGFjay5wb3M7XHJcblx0dmFyIG5lZyA9IHN0YWNrLm5lZztcclxuXHR2YXIgaWxlbiA9IGRhdGEubGVuZ3RoO1xyXG5cdHZhciBpLCB2YWx1ZTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0dmFsdWUgPSBzY2FsZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcclxuXHRcdGlmIChpc05hTih2YWx1ZS5taW4pIHx8IGlzTmFOKHZhbHVlLm1heCkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRwb3NbaV0gPSBwb3NbaV0gfHwgMDtcclxuXHRcdG5lZ1tpXSA9IG5lZ1tpXSB8fCAwO1xyXG5cclxuXHRcdGlmIChvcHRzLnJlbGF0aXZlUG9pbnRzKSB7XHJcblx0XHRcdHBvc1tpXSA9IDEwMDtcclxuXHRcdH0gZWxzZSBpZiAodmFsdWUubWluIDwgMCB8fCB2YWx1ZS5tYXggPCAwKSB7XHJcblx0XHRcdG5lZ1tpXSArPSB2YWx1ZS5taW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwb3NbaV0gKz0gdmFsdWUubWF4O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTWluTWF4KHNjYWxlLCBtZXRhLCBkYXRhKSB7XHJcblx0dmFyIGlsZW4gPSBkYXRhLmxlbmd0aDtcclxuXHR2YXIgaSwgdmFsdWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdHZhbHVlID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YVtpXSk7XHJcblx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0c2NhbGUubWluID0gTWF0aC5taW4oc2NhbGUubWluLCB2YWx1ZS5taW4pO1xyXG5cdFx0c2NhbGUubWF4ID0gTWF0aC5tYXgoc2NhbGUubWF4LCB2YWx1ZS5tYXgpO1xyXG5cdH1cclxufVxyXG5cclxudmFyIHNjYWxlX2xpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcclxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHR2YXIgbWV0YXNldHMgPSBtZS5fZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcclxuXHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XHJcblx0XHR2YXIgc3RhY2tzID0ge307XHJcblx0XHR2YXIgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuXHRcdHZhciBpLCBtZXRhLCBkYXRhLCB2YWx1ZXM7XHJcblxyXG5cdFx0bWUubWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cdFx0bWUubWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cclxuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyAhaGFzU3RhY2tzICYmIGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0XHRtZXRhID0gbWV0YXNldHNbaV07XHJcblx0XHRcdFx0aGFzU3RhY2tzID0gbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRtZXRhID0gbWV0YXNldHNbaV07XHJcblx0XHRcdGRhdGEgPSBkYXRhc2V0c1ttZXRhLmluZGV4XS5kYXRhO1xyXG5cdFx0XHRpZiAoaGFzU3RhY2tzKSB7XHJcblx0XHRcdFx0c3RhY2tEYXRhKG1lLCBzdGFja3MsIG1ldGEsIGRhdGEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHVwZGF0ZU1pbk1heChtZSwgbWV0YSwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRoZWxwZXJzJDEuZWFjaChzdGFja3MsIGZ1bmN0aW9uKHN0YWNrVmFsdWVzKSB7XHJcblx0XHRcdHZhbHVlcyA9IHN0YWNrVmFsdWVzLnBvcy5jb25jYXQoc3RhY2tWYWx1ZXMubmVnKTtcclxuXHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCBoZWxwZXJzJDEubWluKHZhbHVlcykpO1xyXG5cdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIGhlbHBlcnMkMS5tYXgodmFsdWVzKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEuaXNGaW5pdGUobWUubWluKSAmJiAhaXNOYU4obWUubWluKSA/IG1lLm1pbiA6IERFRkFVTFRfTUlOO1xyXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1heCkgJiYgIWlzTmFOKG1lLm1heCkgPyBtZS5tYXggOiBERUZBVUxUX01BWDtcclxuXHJcblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXHJcblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxyXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgdGlja0ZvbnQ7XHJcblxyXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XHJcblx0XHRcdHJldHVybiBNYXRoLmNlaWwobWUud2lkdGggLyA0MCk7XHJcblx0XHR9XHJcblx0XHR0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobWUub3B0aW9ucy50aWNrcyk7XHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLmhlaWdodCAvIHRpY2tGb250LmxpbmVIZWlnaHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIENhbGxlZCBhZnRlciB0aGUgdGlja3MgYXJlIGJ1aWx0LiBXZSBuZWVkXHJcblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHQvLyBXZSBhcmUgaW4gYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbi4gVGhlIHRvcCB2YWx1ZSBpcyB0aGUgaGlnaGVzdC4gU28gcmV2ZXJzZSB0aGUgYXJyYXlcclxuXHRcdFx0dGhpcy50aWNrcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldFNjYWxlTGFiZWwodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIFV0aWxzXHJcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKCgrbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSkgLSBtZS5fc3RhcnRWYWx1ZSkgLyBtZS5fdmFsdWVSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHR2YXIgdGlja3MgPSB0aGlzLnRpY2tzQXNOdW1iZXJzO1xyXG5cdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xyXG52YXIgX2RlZmF1bHRzJDEgPSBkZWZhdWx0Q29uZmlnJDE7XG5zY2FsZV9saW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRiID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG52YXIgbG9nMTAgPSBoZWxwZXJzJDEubWF0aC5sb2cxMDtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xyXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcclxuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcclxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcclxuXHR2YXIgdGlja3MgPSBbXTtcclxuXHJcblx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdCRiKGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XHJcblxyXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcclxuXHR2YXIgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcclxuXHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcclxuXHJcblx0aWYgKHRpY2tWYWwgPT09IDApIHtcclxuXHRcdGV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbk5vdFplcm8pKTtcclxuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcihkYXRhUmFuZ2UubWluTm90WmVybyAvIE1hdGgucG93KDEwLCBleHApKTtcclxuXHJcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xyXG5cdFx0dGlja1ZhbCA9IHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xyXG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcblx0fVxyXG5cdHZhciBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcclxuXHJcblx0ZG8ge1xyXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcclxuXHJcblx0XHQrK3NpZ25pZmljYW5kO1xyXG5cdFx0aWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xyXG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XHJcblx0XHRcdCsrZXhwO1xyXG5cdFx0XHRwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XHJcblx0XHR9XHJcblxyXG5cdFx0dGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XHJcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XHJcblxyXG5cdHZhciBsYXN0VGljayA9IHZhbHVlT3JEZWZhdWx0JGIoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcclxuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcclxuXHJcblx0cmV0dXJuIHRpY2tzO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdENvbmZpZyQyID0ge1xyXG5cdHBvc2l0aW9uOiAnbGVmdCcsXHJcblxyXG5cdC8vIGxhYmVsIHNldHRpbmdzXHJcblx0dGlja3M6IHtcclxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPKHYzKTogY2hhbmdlIHRoaXMgdG8gcG9zaXRpdmVPckRlZmF1bHRcclxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG5cdHJldHVybiBoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID49IDAgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcclxufVxyXG5cclxudmFyIHNjYWxlX2xvZ2FyaXRobWljID0gY29yZV9zY2FsZS5leHRlbmQoe1xyXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XHJcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcclxuXHRcdH1cclxuXHRcdHZhciBkYXRhc2V0SW5kZXgsIG1ldGEsIHZhbHVlLCBkYXRhLCBpLCBpbGVuO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSBSYW5nZVxyXG5cdFx0bWUubWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cdFx0bWUubWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cdFx0bWUubWluTm90WmVybyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xyXG5cdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZvciAoZGF0YXNldEluZGV4ID0gMDsgZGF0YXNldEluZGV4IDwgZGF0YXNldHMubGVuZ3RoOyBkYXRhc2V0SW5kZXgrKykge1xyXG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xyXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpICYmXHJcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xyXG5cdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcclxuXHJcblx0XHRcdGZvciAoZGF0YXNldEluZGV4ID0gMDsgZGF0YXNldEluZGV4IDwgZGF0YXNldHMubGVuZ3RoOyBkYXRhc2V0SW5kZXgrKykge1xyXG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xyXG5cdFx0XHRcdHZhciBrZXkgPSBbXHJcblx0XHRcdFx0XHRtZXRhLnR5cGUsXHJcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXHJcblx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXHJcblx0XHRcdFx0XHRtZXRhLnN0YWNrXHJcblx0XHRcdFx0XS5qb2luKCcuJyk7XHJcblxyXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XHJcblx0XHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSBbXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRkYXRhID0gZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhO1xyXG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG1lLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xyXG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxyXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4gfHwgdmFsdWUubWluIDwgMCB8fCB2YWx1ZS5tYXggPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWVzW2ldIHx8IDA7XHJcblx0XHRcdFx0XHRcdHZhbHVlc1tpXSArPSB2YWx1ZS5tYXg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xyXG5cdFx0XHRcdGlmICh2YWx1ZXNGb3JUeXBlLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xyXG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMkMS5tYXgodmFsdWVzRm9yVHlwZSk7XHJcblx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XHJcblx0XHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKGRhdGFzZXRJbmRleCA9IDA7IGRhdGFzZXRJbmRleCA8IGRhdGFzZXRzLmxlbmd0aDsgZGF0YXNldEluZGV4KyspIHtcclxuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xyXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YTtcclxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG1lLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xyXG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxyXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4gfHwgdmFsdWUubWluIDwgMCB8fCB2YWx1ZS5tYXggPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKHZhbHVlLm1pbiwgbWUubWluKTtcclxuXHRcdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgodmFsdWUubWF4LCBtZS5tYXgpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlLm1pbiAhPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBNYXRoLm1pbih2YWx1ZS5taW4sIG1lLm1pbk5vdFplcm8pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubWluID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbikgPyBtZS5taW4gOiBudWxsO1xyXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1heCkgPyBtZS5tYXggOiBudWxsO1xyXG5cdFx0bWUubWluTm90WmVybyA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5taW5Ob3RaZXJvKSA/IG1lLm1pbk5vdFplcm8gOiBudWxsO1xyXG5cclxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heFxyXG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XHJcblx0fSxcclxuXHJcblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdHZhciBERUZBVUxUX01JTiA9IDE7XHJcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxMDtcclxuXHJcblx0XHRtZS5taW4gPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4sIG1lLm1pbik7XHJcblx0XHRtZS5tYXggPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgsIG1lLm1heCk7XHJcblxyXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XHJcblx0XHRcdGlmIChtZS5taW4gIT09IDAgJiYgbWUubWluICE9PSBudWxsKSB7XHJcblx0XHRcdFx0bWUubWluID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWluKSkgLSAxKTtcclxuXHRcdFx0XHRtZS5tYXggPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChtZS5tYXgpKSArIDEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1lLm1pbiA9IERFRkFVTFRfTUlOO1xyXG5cdFx0XHRcdG1lLm1heCA9IERFRkFVTFRfTUFYO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAobWUubWluID09PSBudWxsKSB7XHJcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1heCkpIC0gMSk7XHJcblx0XHR9XHJcblx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XHJcblx0XHRcdG1lLm1heCA9IG1lLm1pbiAhPT0gMFxyXG5cdFx0XHRcdD8gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAobWUubWluKSkgKyAxKVxyXG5cdFx0XHRcdDogREVGQVVMVF9NQVg7XHJcblx0XHR9XHJcblx0XHRpZiAobWUubWluTm90WmVybyA9PT0gbnVsbCkge1xyXG5cdFx0XHRpZiAobWUubWluID4gMCkge1xyXG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBtZS5taW47XHJcblx0XHRcdH0gZWxzZSBpZiAobWUubWF4IDwgMSkge1xyXG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChtZS5tYXgpKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWUubWluTm90WmVybyA9IERFRkFVTFRfTUlOO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcclxuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cclxuXHRcdHZhciBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcclxuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxyXG5cdFx0XHRtYXg6IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1heClcclxuXHRcdH07XHJcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xyXG5cclxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcclxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxyXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XHJcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcclxuXHJcblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xyXG5cdFx0XHRyZXZlcnNlID0gIXJldmVyc2U7XHJcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xyXG5cdFx0XHRtZS5lbmQgPSBtZS5taW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcclxuXHRcdFx0bWUuZW5kID0gbWUubWF4O1xyXG5cdFx0fVxyXG5cdFx0aWYgKHJldmVyc2UpIHtcclxuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcclxuXHJcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0aGUgY29ycmVjdCB0b29sdGlwIGxhYmVsXHJcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldFNjYWxlTGFiZWwodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCB0aWNrLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIG5vdCB6ZXJvIHZhbHVlLlxyXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpcnN0IHRpY2sgdmFsdWUuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0Rmlyc3RUaWNrVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh2YWx1ZSkpO1xyXG5cdFx0dmFyIHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDEwLCBleHApKTtcclxuXHJcblx0XHRyZXR1cm4gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcclxuXHR9LFxyXG5cclxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgc3RhcnQgPSBtZS5taW47XHJcblx0XHR2YXIgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5fY29uZmlndXJlLmNhbGwobWUpO1xyXG5cclxuXHRcdGlmIChzdGFydCA9PT0gMCkge1xyXG5cdFx0XHRzdGFydCA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcclxuXHRcdFx0b2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYihtZS5vcHRpb25zLnRpY2tzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpIC8gbWUuX2xlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHRtZS5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcclxuXHRcdG1lLl92YWx1ZU9mZnNldCA9IG9mZnNldDtcclxuXHRcdG1lLl92YWx1ZVJhbmdlID0gKGxvZzEwKG1lLm1heCkgLSBsb2cxMChzdGFydCkpIC8gKDEgLSBvZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGRlY2ltYWwgPSAwO1xyXG5cclxuXHRcdHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA+IG1lLm1pbiAmJiB2YWx1ZSA+IDApIHtcclxuXHRcdFx0ZGVjaW1hbCA9IChsb2cxMCh2YWx1ZSkgLSBtZS5fc3RhcnRWYWx1ZSkgLyBtZS5fdmFsdWVSYW5nZSArIG1lLl92YWx1ZU9mZnNldDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgZGVjaW1hbCA9IG1lLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XHJcblx0XHRyZXR1cm4gZGVjaW1hbCA9PT0gMCAmJiBtZS5taW4gPT09IDBcclxuXHRcdFx0PyAwXHJcblx0XHRcdDogTWF0aC5wb3coMTAsIG1lLl9zdGFydFZhbHVlICsgKGRlY2ltYWwgLSBtZS5fdmFsdWVPZmZzZXQpICogbWUuX3ZhbHVlUmFuZ2UpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQyID0gZGVmYXVsdENvbmZpZyQyO1xuc2NhbGVfbG9nYXJpdGhtaWMuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDI7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRjID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xyXG52YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xyXG52YXIgcmVzb2x2ZSQ0ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcclxuXHJcbnZhciBkZWZhdWx0Q29uZmlnJDMgPSB7XHJcblx0ZGlzcGxheTogdHJ1ZSxcclxuXHJcblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcclxuXHRhbmltYXRlOiB0cnVlLFxyXG5cdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcclxuXHJcblx0YW5nbGVMaW5lczoge1xyXG5cdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdGNvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcclxuXHRcdGxpbmVXaWR0aDogMSxcclxuXHRcdGJvcmRlckRhc2g6IFtdLFxyXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXHJcblx0fSxcclxuXHJcblx0Z3JpZExpbmVzOiB7XHJcblx0XHRjaXJjdWxhcjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHQvLyBsYWJlbCBzZXR0aW5nc1xyXG5cdHRpY2tzOiB7XHJcblx0XHQvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxyXG5cdFx0c2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gU3RyaW5nIC0gVGhlIGNvbG91ciBvZiB0aGUgbGFiZWwgYmFja2Ryb3BcclxuXHRcdGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpJyxcclxuXHJcblx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcclxuXHRcdGJhY2tkcm9wUGFkZGluZ1k6IDIsXHJcblxyXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgdG8gdGhlIHNpZGUgb2YgdGhlIGxhYmVsIGluIHBpeGVsc1xyXG5cdFx0YmFja2Ryb3BQYWRkaW5nWDogMixcclxuXHJcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxyXG5cdH0sXHJcblxyXG5cdHBvaW50TGFiZWxzOiB7XHJcblx0XHQvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xyXG5cdFx0Zm9udFNpemU6IDEwLFxyXG5cclxuXHRcdC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xyXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XHJcblx0XHRcdHJldHVybiBsYWJlbDtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xyXG5cdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XHJcblxyXG5cdGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JGModGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSkgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMjtcclxuXHR9XHJcblx0cmV0dXJuIDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBsaW5lSGVpZ2h0LCBsYWJlbCkge1xyXG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHc6IGhlbHBlcnMkMS5sb25nZXN0VGV4dChjdHgsIGN0eC5mb250LCBsYWJlbCksXHJcblx0XHRcdGg6IGxhYmVsLmxlbmd0aCAqIGxpbmVIZWlnaHRcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dzogY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aCxcclxuXHRcdGg6IGxpbmVIZWlnaHRcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcclxuXHRpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcclxuXHRcdFx0ZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplLFxyXG5cdFx0XHRlbmQ6IHBvc1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRzdGFydDogcG9zLFxyXG5cdFx0ZW5kOiBwb3MgKyBzaXplXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcclxuXHJcblx0Ly8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxyXG5cdC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxyXG5cdC8vXHJcblx0Ly8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxyXG5cdC8vXHJcblx0Ly8gU29sdXRpb246XHJcblx0Ly9cclxuXHQvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcclxuXHQvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxyXG5cdC8vXHJcblx0Ly8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cclxuXHQvL1xyXG5cdC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxyXG5cdC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cclxuXHQvL1xyXG5cdC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XHJcblx0Ly8gYWxvbmcgd2l0aCBsYWJlbHMuXHJcblx0Ly9cclxuXHQvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXHJcblx0Ly8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXHJcblx0Ly9cclxuXHQvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcclxuXHQvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxyXG5cdC8vXHJcblx0Ly8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXHJcblxyXG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMpO1xyXG5cclxuXHQvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cclxuXHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcclxuXHR2YXIgZnVydGhlc3RMaW1pdHMgPSB7XHJcblx0XHRsOiAwLFxyXG5cdFx0cjogc2NhbGUud2lkdGgsXHJcblx0XHR0OiAwLFxyXG5cdFx0Yjogc2NhbGUuaGVpZ2h0IC0gc2NhbGUucGFkZGluZ1RvcFxyXG5cdH07XHJcblx0dmFyIGZ1cnRoZXN0QW5nbGVzID0ge307XHJcblx0dmFyIGksIHRleHRTaXplLCBwb2ludFBvc2l0aW9uO1xyXG5cclxuXHRzY2FsZS5jdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XHJcblx0c2NhbGUuX3BvaW50TGFiZWxTaXplcyA9IFtdO1xyXG5cclxuXHR2YXIgdmFsdWVDb3VudCA9IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcclxuXHRmb3IgKGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XHJcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIDUpO1xyXG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldKTtcclxuXHRcdHNjYWxlLl9wb2ludExhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcclxuXHJcblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcclxuXHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xyXG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpICUgMzYwO1xyXG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcclxuXHRcdHZhciB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xyXG5cclxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xyXG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcclxuXHRcdFx0ZnVydGhlc3RBbmdsZXMubCA9IGFuZ2xlUmFkaWFucztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaExpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5yKSB7XHJcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcclxuXHRcdFx0ZnVydGhlc3RBbmdsZXMuciA9IGFuZ2xlUmFkaWFucztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodkxpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLnQpIHtcclxuXHRcdFx0ZnVydGhlc3RMaW1pdHMudCA9IHZMaW1pdHMuc3RhcnQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xyXG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XHJcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmIgPSBhbmdsZVJhZGlhbnM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xyXG5cdGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XHJcblx0XHRyZXR1cm4gJ2NlbnRlcic7XHJcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xyXG5cdFx0cmV0dXJuICdsZWZ0JztcclxuXHR9XHJcblxyXG5cdHJldHVybiAncmlnaHQnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWxsVGV4dChjdHgsIHRleHQsIHBvc2l0aW9uLCBsaW5lSGVpZ2h0KSB7XHJcblx0dmFyIHkgPSBwb3NpdGlvbi55ICsgbGluZUhlaWdodCAvIDI7XHJcblx0dmFyIGksIGlsZW47XHJcblxyXG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0ZXh0KSkge1xyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCBwb3NpdGlvbi54LCB5KTtcclxuXHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRjdHguZmlsbFRleHQodGV4dCwgcG9zaXRpb24ueCwgeSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xyXG5cdGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xyXG5cdFx0cG9zaXRpb24ueSAtPSAodGV4dFNpemUuaCAvIDIpO1xyXG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xyXG5cdFx0cG9zaXRpb24ueSAtPSB0ZXh0U2l6ZS5oO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlKSB7XHJcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcclxuXHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XHJcblx0dmFyIHBvaW50TGFiZWxPcHRzID0gb3B0cy5wb2ludExhYmVscztcclxuXHR2YXIgdGlja0JhY2tkcm9wSGVpZ2h0ID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpO1xyXG5cdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcclxuXHR2YXIgcGxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChwb2ludExhYmVsT3B0cyk7XHJcblxyXG5cdGN0eC5zYXZlKCk7XHJcblxyXG5cdGN0eC5mb250ID0gcGxGb250LnN0cmluZztcclxuXHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblxyXG5cdGZvciAodmFyIGkgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0Ly8gRXh0cmEgcGl4ZWxzIG91dCBmb3Igc29tZSBsYWJlbCBzcGFjaW5nXHJcblx0XHR2YXIgZXh0cmEgPSAoaSA9PT0gMCA/IHRpY2tCYWNrZHJvcEhlaWdodCAvIDIgOiAwKTtcclxuXHRcdHZhciBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIDUpO1xyXG5cclxuXHRcdC8vIEtlZXAgdGhpcyBpbiBsb29wIHNpbmNlIHdlIG1heSBzdXBwb3J0IGFycmF5IHByb3BlcnRpZXMgaGVyZVxyXG5cdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XHJcblxyXG5cdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XHJcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XHJcblx0XHRjdHgudGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xyXG5cdFx0YWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCBzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldLCBwb2ludExhYmVsUG9zaXRpb24pO1xyXG5cdFx0ZmlsbFRleHQoY3R4LCBzY2FsZS5wb2ludExhYmVsc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uLCBwbEZvbnQubGluZUhlaWdodCk7XHJcblx0fVxyXG5cdGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgaW5kZXgpIHtcclxuXHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xyXG5cdHZhciBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcclxuXHR2YXIgdmFsdWVDb3VudCA9IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcclxuXHR2YXIgbGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmNvbG9yLCBpbmRleCAtIDEpO1xyXG5cdHZhciBsaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShncmlkTGluZU9wdHMubGluZVdpZHRoLCBpbmRleCAtIDEpO1xyXG5cdHZhciBwb2ludFBvc2l0aW9uO1xyXG5cclxuXHRpZiAoKCFjaXJjdWxhciAmJiAhdmFsdWVDb3VudCkgfHwgIWxpbmVDb2xvciB8fCAhbGluZVdpZHRoKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRjdHguc2F2ZSgpO1xyXG5cdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcclxuXHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcclxuXHRcdGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCB8fCBbXSk7XHJcblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XHJcblx0fVxyXG5cclxuXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0aWYgKGNpcmN1bGFyKSB7XHJcblx0XHQvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXHJcblx0XHRjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxyXG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcclxuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XHJcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XHJcblx0XHRcdGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LnN0cm9rZSgpO1xyXG5cdGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xyXG5cdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xyXG59XHJcblxyXG52YXIgc2NhbGVfcmFkaWFsTGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxyXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcclxuXHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcclxuXHRcdG1lLnBhZGRpbmdUb3AgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQobWUub3B0aW9ucykgLyAyO1xyXG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcclxuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAvIDIpO1xyXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wLCBtZS53aWR0aCkgLyAyO1xyXG5cdH0sXHJcblxyXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xyXG5cdFx0dmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblxyXG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcclxuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcblxyXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XHJcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcclxuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KHZhbHVlLCBtYXgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcclxuXHRcdG1lLm1heCA9IChtYXggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/IDAgOiBtYXgpO1xyXG5cclxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cclxuXHRcdG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXHJcblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XHJcblxyXG5cdFx0Ly8gUG9pbnQgbGFiZWxzXHJcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGxhYmVsID0gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIGFyZ3VtZW50cywgbWUpO1xyXG5cdFx0XHRyZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xyXG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xyXG5cdH0sXHJcblxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XHJcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgcmFkaXVzIHJlZHVjdGlvbnMgYW5kIGRldGVybWluZSBuZXcgcmFkaXVzIGFuZCBjZW50ZXIgcG9pbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldFJlZHVjdGlvbnM6IGZ1bmN0aW9uKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XHJcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBNYXRoLm1heChmdXJ0aGVzdExpbWl0cy5yIC0gbWUud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XHJcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uVG9wID0gLWZ1cnRoZXN0TGltaXRzLnQgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy50KTtcclxuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcclxuXHJcblx0XHRyYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkxlZnQpO1xyXG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xyXG5cdFx0cmFkaXVzUmVkdWN0aW9uVG9wID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblRvcCk7XHJcblx0XHRyYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcclxuXHJcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKFxyXG5cdFx0XHRNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25MZWZ0ICsgcmFkaXVzUmVkdWN0aW9uUmlnaHQpIC8gMiksXHJcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XHJcblx0XHRtZS5zZXRDZW50ZXJQb2ludChyYWRpdXNSZWR1Y3Rpb25MZWZ0LCByYWRpdXNSZWR1Y3Rpb25SaWdodCwgcmFkaXVzUmVkdWN0aW9uVG9wLCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xyXG5cdH0sXHJcblxyXG5cdHNldENlbnRlclBvaW50OiBmdW5jdGlvbihsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xyXG5cdFx0dmFyIG1heExlZnQgPSBsZWZ0TW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcclxuXHRcdHZhciBtYXhUb3AgPSB0b3BNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xyXG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XHJcblxyXG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IoKChtYXhMZWZ0ICsgbWF4UmlnaHQpIC8gMikgKyBtZS5sZWZ0KTtcclxuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcblx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gMzYwIC8gY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zIHx8IHt9O1xyXG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcclxuXHJcblx0XHQvLyBTdGFydCBmcm9tIHRoZSB0b3AgaW5zdGVhZCBvZiByaWdodCwgc28gcmVtb3ZlIGEgcXVhcnRlciBvZiB0aGUgY2lyY2xlXHJcblx0XHR2YXIgYW5nbGUgPSAoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlKSAlIDM2MDtcclxuXHJcblx0XHRyZXR1cm4gKGFuZ2xlIDwgMCA/IGFuZ2xlICsgMzYwIDogYW5nbGUpICogTWF0aC5QSSAqIDIgLyAzNjA7XHJcblx0fSxcclxuXHJcblx0Z2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcclxuXHRcdFx0cmV0dXJuIE5hTjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXHJcblx0XHR2YXIgc2NhbGluZ0ZhY3RvciA9IG1lLmRyYXdpbmdBcmVhIC8gKG1lLm1heCAtIG1lLm1pbik7XHJcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XHJcblx0XHRcdHJldHVybiAobWUubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3RvcjtcclxuXHR9LFxyXG5cclxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRoaXNBbmdsZSA9IG1lLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gKE1hdGguUEkgLyAyKTtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IE1hdGguY29zKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS54Q2VudGVyLFxyXG5cdFx0XHR5OiBNYXRoLnNpbih0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueUNlbnRlclxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhc2VQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgbWluID0gbWUubWluO1xyXG5cdFx0dmFyIG1heCA9IG1lLm1heDtcclxuXHJcblx0XHRyZXR1cm4gbWUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsXHJcblx0XHRcdG1lLmJlZ2luQXRaZXJvID8gMCA6XHJcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XHJcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XHJcblx0XHRcdDApO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdHcmlkOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xyXG5cdFx0dmFyIGFuZ2xlTGluZU9wdHMgPSBvcHRzLmFuZ2xlTGluZXM7XHJcblx0XHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkYyhhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aCwgZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCk7XHJcblx0XHR2YXIgbGluZUNvbG9yID0gdmFsdWVPckRlZmF1bHQkYyhhbmdsZUxpbmVPcHRzLmNvbG9yLCBncmlkTGluZU9wdHMuY29sb3IpO1xyXG5cdFx0dmFyIGksIG9mZnNldCwgcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xyXG5cdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XHJcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAwKSB7XHJcblx0XHRcdFx0XHRvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xyXG5cdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgb2Zmc2V0LCBpbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYW5nbGVMaW5lT3B0cy5kaXNwbGF5ICYmIGxpbmVXaWR0aCAmJiBsaW5lQ29sb3IpIHtcclxuXHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xyXG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XHJcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKHJlc29sdmUkNChbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoLCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaCwgW11dKSk7XHJcblx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ0KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChpID0gbWUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBtZS5taW4gOiBtZS5tYXgpO1xyXG5cdFx0XHRcdHBvc2l0aW9uID0gbWUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xyXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRjdHgubW92ZVRvKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XHJcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdMYWJlbHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBjdHggPSBtZS5jdHg7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG5cclxuXHRcdGlmICghdGlja09wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKDApO1xyXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XHJcblx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGModGlja09wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcclxuXHRcdHZhciBvZmZzZXQsIHdpZHRoO1xyXG5cclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcclxuXHRcdGN0eC50cmFuc2xhdGUobWUueENlbnRlciwgbWUueUNlbnRlcik7XHJcblx0XHRjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLnRpY2tzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcclxuXHRcdFx0aWYgKGluZGV4ID09PSAwICYmICF0aWNrT3B0cy5yZXZlcnNlKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xyXG5cclxuXHRcdFx0aWYgKHRpY2tPcHRzLnNob3dMYWJlbEJhY2tkcm9wKSB7XHJcblx0XHRcdFx0d2lkdGggPSBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xyXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrT3B0cy5iYWNrZHJvcENvbG9yO1xyXG5cclxuXHRcdFx0XHRjdHguZmlsbFJlY3QoXHJcblx0XHRcdFx0XHQtd2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcclxuXHRcdFx0XHRcdC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ksXHJcblx0XHRcdFx0XHR3aWR0aCArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ggKiAyLFxyXG5cdFx0XHRcdFx0dGlja0ZvbnQuc2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250Q29sb3I7XHJcblx0XHRcdGN0eC5maWxsVGV4dChsYWJlbCwgMCwgLW9mZnNldCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2RyYXdUaXRsZTogaGVscGVycyQxLm5vb3BcclxufSk7XHJcblxyXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcclxudmFyIF9kZWZhdWx0cyQzID0gZGVmYXVsdENvbmZpZyQzO1xuc2NhbGVfcmFkaWFsTGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQzO1xuXG52YXIgZGVwcmVjYXRlZCQxID0gaGVscGVycyQxLl9kZXByZWNhdGVkO1xyXG52YXIgcmVzb2x2ZSQ1ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcclxudmFyIHZhbHVlT3JEZWZhdWx0JGQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXHJcbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxO1xyXG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xyXG5cclxudmFyIElOVEVSVkFMUyA9IHtcclxuXHRtaWxsaXNlY29uZDoge1xyXG5cdFx0Y29tbW9uOiB0cnVlLFxyXG5cdFx0c2l6ZTogMSxcclxuXHRcdHN0ZXBzOiAxMDAwXHJcblx0fSxcclxuXHRzZWNvbmQ6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDEwMDAsXHJcblx0XHRzdGVwczogNjBcclxuXHR9LFxyXG5cdG1pbnV0ZToge1xyXG5cdFx0Y29tbW9uOiB0cnVlLFxyXG5cdFx0c2l6ZTogNjAwMDAsXHJcblx0XHRzdGVwczogNjBcclxuXHR9LFxyXG5cdGhvdXI6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDM2MDAwMDAsXHJcblx0XHRzdGVwczogMjRcclxuXHR9LFxyXG5cdGRheToge1xyXG5cdFx0Y29tbW9uOiB0cnVlLFxyXG5cdFx0c2l6ZTogODY0MDAwMDAsXHJcblx0XHRzdGVwczogMzBcclxuXHR9LFxyXG5cdHdlZWs6IHtcclxuXHRcdGNvbW1vbjogZmFsc2UsXHJcblx0XHRzaXplOiA2MDQ4MDAwMDAsXHJcblx0XHRzdGVwczogNFxyXG5cdH0sXHJcblx0bW9udGg6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDIuNjI4ZTksXHJcblx0XHRzdGVwczogMTJcclxuXHR9LFxyXG5cdHF1YXJ0ZXI6IHtcclxuXHRcdGNvbW1vbjogZmFsc2UsXHJcblx0XHRzaXplOiA3Ljg4NGU5LFxyXG5cdFx0c3RlcHM6IDRcclxuXHR9LFxyXG5cdHllYXI6IHtcclxuXHRcdGNvbW1vbjogdHJ1ZSxcclxuXHRcdHNpemU6IDMuMTU0ZTEwXHJcblx0fVxyXG59O1xyXG5cclxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcclxuXHJcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XHJcblx0cmV0dXJuIGEgLSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xyXG5cdHZhciBoYXNoID0ge307XHJcblx0dmFyIG91dCA9IFtdO1xyXG5cdHZhciBpLCBpbGVuLCBpdGVtO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRpdGVtID0gaXRlbXNbaV07XHJcblx0XHRpZiAoIWhhc2hbaXRlbV0pIHtcclxuXHRcdFx0aGFzaFtpdGVtXSA9IHRydWU7XHJcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG91dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWluKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGltZS5taW4sIG9wdGlvbnMudGlja3MubWluKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWF4KG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGltZS5tYXgsIG9wdGlvbnMudGlja3MubWF4KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXHJcbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXHJcbiAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxyXG4gKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcclxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXHJcbiAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzdHJpYnV0aW9uIC0gSWYgJ2xpbmVhcicsIHRpbWVzdGFtcHMgd2lsbCBiZSBzcHJlYWQgbGluZWFybHkgYWxvbmcgdGhlIG1pblxyXG4gKiBhbmQgbWF4IHJhbmdlLCBzbyBiYXNpY2FsbHksIHRoZSB0YWJsZSB3aWxsIGNvbnRhaW5zIG9ubHkgdHdvIGl0ZW1zOiB7bWluLCAwfSBhbmQge21heCwgMX0uXHJcbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcclxuICogY2FzZSwgb25seSB0aW1lc3RhbXBzIHRoYXQgYnJlYWsgdGhlIHRpbWUgbGluZWFyaXR5IGFyZSByZWdpc3RlcmVkLCBtZWFuaW5nIHRoYXQgaW4gdGhlXHJcbiAqIGJlc3QgY2FzZSwgYWxsIHRpbWVzdGFtcHMgYXJlIGxpbmVhciwgdGhlIHRhYmxlIGNvbnRhaW5zIG9ubHkgbWluIGFuZCBtYXguXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMsIG1pbiwgbWF4LCBkaXN0cmlidXRpb24pIHtcclxuXHRpZiAoZGlzdHJpYnV0aW9uID09PSAnbGluZWFyJyB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdHt0aW1lOiBtaW4sIHBvczogMH0sXHJcblx0XHRcdHt0aW1lOiBtYXgsIHBvczogMX1cclxuXHRcdF07XHJcblx0fVxyXG5cclxuXHR2YXIgdGFibGUgPSBbXTtcclxuXHR2YXIgaXRlbXMgPSBbbWluXTtcclxuXHR2YXIgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRjdXJyID0gdGltZXN0YW1wc1tpXTtcclxuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcclxuXHRcdFx0aXRlbXMucHVzaChjdXJyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGl0ZW1zLnB1c2gobWF4KTtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0bmV4dCA9IGl0ZW1zW2kgKyAxXTtcclxuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XHJcblx0XHRjdXJyID0gaXRlbXNbaV07XHJcblxyXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcclxuXHRcdGlmIChwcmV2ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gdW5kZWZpbmVkIHx8IE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XHJcblx0XHRcdHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0YWJsZTtcclxufVxyXG5cclxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuYW51amdha2hhci5jb20vMjAxNC8wMy8wMS9iaW5hcnktc2VhcmNoLWluLWphdmFzY3JpcHQvXHJcbmZ1bmN0aW9uIGxvb2t1cCh0YWJsZSwga2V5LCB2YWx1ZSkge1xyXG5cdHZhciBsbyA9IDA7XHJcblx0dmFyIGhpID0gdGFibGUubGVuZ3RoIC0gMTtcclxuXHR2YXIgbWlkLCBpMCwgaTE7XHJcblxyXG5cdHdoaWxlIChsbyA+PSAwICYmIGxvIDw9IGhpKSB7XHJcblx0XHRtaWQgPSAobG8gKyBoaSkgPj4gMTtcclxuXHRcdGkwID0gdGFibGVbbWlkIC0gMV0gfHwgbnVsbDtcclxuXHRcdGkxID0gdGFibGVbbWlkXTtcclxuXHJcblx0XHRpZiAoIWkwKSB7XHJcblx0XHRcdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGJlZm9yZSBmaXJzdCBpdGVtKVxyXG5cdFx0XHRyZXR1cm4ge2xvOiBudWxsLCBoaTogaTF9O1xyXG5cdFx0fSBlbHNlIGlmIChpMVtrZXldIDwgdmFsdWUpIHtcclxuXHRcdFx0bG8gPSBtaWQgKyAxO1xyXG5cdFx0fSBlbHNlIGlmIChpMFtrZXldID4gdmFsdWUpIHtcclxuXHRcdFx0aGkgPSBtaWQgLSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHtsbzogaTAsIGhpOiBpMX07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChhZnRlciBsYXN0IGl0ZW0pXHJcblx0cmV0dXJuIHtsbzogaTEsIGhpOiBudWxsfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWx1ZWAgdXNpbmcgdGhlIHRhYmxlIGl0ZW1zIGBza2V5YCB2YWx1ZXMgYW5kXHJcbiAqIHJldHVybnMgdGhlIGFzc29jaWF0ZWQgYHRrZXlgIHZhbHVlLiBGb3IgZXhhbXBsZSwgaW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgNDIsICdwb3MnKVxyXG4gKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBmb3IgYSB0aW1lc3RhbXAgZXF1YWwgdG8gNDIuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlcyBhdFxyXG4gKiBpbmRleCBbMCwgMV0gb3IgW24gLSAxLCBuXSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XHJcblx0dmFyIHJhbmdlID0gbG9va3VwKHRhYmxlLCBza2V5LCBzdmFsKTtcclxuXHJcblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXHJcblx0dmFyIHByZXYgPSAhcmFuZ2UubG8gPyB0YWJsZVswXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDJdIDogcmFuZ2UubG87XHJcblx0dmFyIG5leHQgPSAhcmFuZ2UubG8gPyB0YWJsZVsxXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDFdIDogcmFuZ2UuaGk7XHJcblxyXG5cdHZhciBzcGFuID0gbmV4dFtza2V5XSAtIHByZXZbc2tleV07XHJcblx0dmFyIHJhdGlvID0gc3BhbiA/IChzdmFsIC0gcHJldltza2V5XSkgLyBzcGFuIDogMDtcclxuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xyXG5cclxuXHRyZXR1cm4gcHJldlt0a2V5XSArIG9mZnNldDtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9UaW1lc3RhbXAoc2NhbGUsIGlucHV0KSB7XHJcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcclxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcclxuXHR2YXIgcGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XHJcblx0dmFyIGZvcm1hdCA9IHBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcclxuXHR2YXIgdmFsdWUgPSBpbnB1dDtcclxuXHJcblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdC8vIE9ubHkgcGFyc2UgaWYgaXRzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XHJcblx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpKSB7XHJcblx0XHR2YWx1ZSA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXHJcblx0XHRcdD8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgZm9ybWF0KVxyXG5cdFx0XHQ6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xyXG5cdH1cclxuXHJcblx0aWYgKHZhbHVlICE9PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gK3ZhbHVlO1xyXG5cdH1cclxuXHJcblx0Ly8gTGFiZWxzIGFyZSBpbiBhbiBpbmNvbXBhdGlibGUgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cclxuXHQvLyBUaGUgdXNlciBtaWdodCBzdGlsbCB1c2UgdGhlIGRlcHJlY2F0ZWQgYGZvcm1hdGAgb3B0aW9uIGZvciBwYXJzaW5nLlxyXG5cdGlmICghcGFyc2VyICYmIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdHZhbHVlID0gZm9ybWF0KGlucHV0KTtcclxuXHJcblx0XHQvLyBgZm9ybWF0YCBjb3VsZCByZXR1cm4gc29tZXRoaW5nIGVsc2UgdGhhbiBhIHRpbWVzdGFtcCwgaWYgc28sIHBhcnNlIGl0XHJcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuXHRcdFx0dmFsdWUgPSBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XHJcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGlucHV0KSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcclxuXHR2YXIgdmFsdWUgPSB0b1RpbWVzdGFtcChzY2FsZSwgc2NhbGUuZ2V0UmlnaHRWYWx1ZShpbnB1dCkpO1xyXG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxuXHJcblx0aWYgKG9wdGlvbnMucm91bmQpIHtcclxuXHRcdHZhbHVlID0gK3NjYWxlLl9hZGFwdGVyLnN0YXJ0T2YodmFsdWUsIG9wdGlvbnMucm91bmQpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xyXG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xyXG5cdHZhciBpLCBpbnRlcnZhbCwgZmFjdG9yO1xyXG5cclxuXHRmb3IgKGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xyXG5cdFx0aW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xyXG5cdFx0ZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE1BWF9JTlRFR0VSO1xyXG5cclxuXHRcdGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xyXG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xyXG59XHJcblxyXG4vKipcclxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XHJcblx0dmFyIGksIHVuaXQ7XHJcblxyXG5cdGZvciAoaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XHJcblx0XHR1bml0ID0gVU5JVFNbaV07XHJcblx0XHRpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcclxuXHRcdFx0cmV0dXJuIHVuaXQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcclxuXHRmb3IgKHZhciBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xyXG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcclxuICogYG1pbm9yYCB1bml0IHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cclxuICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxyXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShzY2FsZSwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XHJcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcclxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XHJcblx0dmFyIHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xyXG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xyXG5cdHZhciBzdGVwU2l6ZSA9IHJlc29sdmUkNShbdGltZU9wdHMuc3RlcFNpemUsIHRpbWVPcHRzLnVuaXRTdGVwU2l6ZSwgMV0pO1xyXG5cdHZhciB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcclxuXHR2YXIgZmlyc3QgPSBtaW47XHJcblx0dmFyIHRpY2tzID0gW107XHJcblx0dmFyIHRpbWU7XHJcblxyXG5cdC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cclxuXHRpZiAod2Vla2RheSkge1xyXG5cdFx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xyXG5cdH1cclxuXHJcblx0Ly8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxyXG5cdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xyXG5cclxuXHQvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xyXG5cdGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XHJcblx0XHR0aHJvdyBtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yO1xyXG5cdH1cclxuXHJcblx0Zm9yICh0aW1lID0gZmlyc3Q7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSkge1xyXG5cdFx0dGlja3MucHVzaCh0aW1lKTtcclxuXHR9XHJcblxyXG5cdGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcclxuXHRcdHRpY2tzLnB1c2godGltZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGlja3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZnJvbSBlZGdlcyBpbiB0aGUgZm9ybSBvZiB7c3RhcnQsIGVuZH1cclxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cclxuICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxyXG4gKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKHRhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpIHtcclxuXHR2YXIgc3RhcnQgPSAwO1xyXG5cdHZhciBlbmQgPSAwO1xyXG5cdHZhciBmaXJzdCwgbGFzdDtcclxuXHJcblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xyXG5cdFx0Zmlyc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzBdLCAncG9zJyk7XHJcblx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3RhcnQgPSAoaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1sxXSwgJ3BvcycpIC0gZmlyc3QpIC8gMjtcclxuXHRcdH1cclxuXHRcdGxhc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLCAncG9zJyk7XHJcblx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdGVuZCA9IGxhc3Q7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbmQgPSAobGFzdCAtIGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbdGlja3MubGVuZ3RoIC0gMl0sICdwb3MnKSkgLyAyO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xyXG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcblx0dmFyIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcclxuXHR2YXIgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xyXG5cdHZhciBtYWpvciwgaW5kZXg7XHJcblxyXG5cdGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcclxuXHRcdGluZGV4ID0gbWFwW21ham9yXTtcclxuXHRcdGlmIChpbmRleCA+PSAwKSB7XHJcblx0XHRcdHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0aWNrcztcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcclxuXHR2YXIgdGlja3MgPSBbXTtcclxuXHR2YXIgbWFwID0ge307XHJcblx0dmFyIGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xyXG5cdHZhciBpLCB2YWx1ZTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0dmFsdWUgPSB2YWx1ZXNbaV07XHJcblx0XHRtYXBbdmFsdWVdID0gaTtcclxuXHJcblx0XHR0aWNrcy5wdXNoKHtcclxuXHRcdFx0dmFsdWU6IHZhbHVlLFxyXG5cdFx0XHRtYWpvcjogZmFsc2VcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gV2Ugc2V0IHRoZSBtYWpvciB0aWNrcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSBjYWxsaW5nIHN0YXJ0T2YgZm9yIGV2ZXJ5IHRpY2tcclxuXHQvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xyXG5cdHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcclxufVxyXG5cclxudmFyIGRlZmF1bHRDb25maWckNCA9IHtcclxuXHRwb3NpdGlvbjogJ2JvdHRvbScsXHJcblxyXG5cdC8qKlxyXG5cdCAqIERhdGEgZGlzdHJpYnV0aW9uIGFsb25nIHRoZSBzY2FsZTpcclxuXHQgKiAtICdsaW5lYXInOiBkYXRhIGFyZSBzcHJlYWQgYWNjb3JkaW5nIHRvIHRoZWlyIHRpbWUgKGRpc3RhbmNlcyBjYW4gdmFyeSksXHJcblx0ICogLSAnc2VyaWVzJzogZGF0YSBhcmUgc3ByZWFkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGRpc3RyaWJ1dGlvbjogJ2xpbmVhcicsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcclxuXHQgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcclxuXHQgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcclxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxyXG5cdCAqIEBzaW5jZSAyLjcuMFxyXG5cdCAqL1xyXG5cdGJvdW5kczogJ2RhdGEnLFxyXG5cclxuXHRhZGFwdGVyczoge30sXHJcblx0dGltZToge1xyXG5cdFx0cGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgbW9tZW50XHJcblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cclxuXHRcdHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxyXG5cdFx0ZGlzcGxheUZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURURcclxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cclxuXHRcdG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXHJcblx0XHRkaXNwbGF5Rm9ybWF0czoge31cclxuXHR9LFxyXG5cdHRpY2tzOiB7XHJcblx0XHRhdXRvU2tpcDogZmFsc2UsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcclxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxyXG5cdFx0ICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXHJcblx0XHQgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXHJcblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xyXG5cdFx0ICogQHNpbmNlIDIuNy4wXHJcblx0XHQgKi9cclxuXHRcdHNvdXJjZTogJ2F1dG8nLFxyXG5cclxuXHRcdG1ham9yOiB7XHJcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxudmFyIHNjYWxlX3RpbWUgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLm1lcmdlVGlja3NPcHRpb25zKCk7XHJcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdGltZSA9IG9wdGlvbnMudGltZSB8fCAob3B0aW9ucy50aW1lID0ge30pO1xyXG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XHJcblxyXG5cdFx0Ly8gREVQUkVDQVRJT05TOiBvdXRwdXQgYSBtZXNzYWdlIG9ubHkgb25lIHRpbWUgcGVyIHVwZGF0ZVxyXG5cdFx0ZGVwcmVjYXRlZCQxKCd0aW1lIHNjYWxlJywgdGltZS5mb3JtYXQsICd0aW1lLmZvcm1hdCcsICd0aW1lLnBhcnNlcicpO1xyXG5cdFx0ZGVwcmVjYXRlZCQxKCd0aW1lIHNjYWxlJywgdGltZS5taW4sICd0aW1lLm1pbicsICd0aWNrcy5taW4nKTtcclxuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUubWF4LCAndGltZS5tYXgnLCAndGlja3MubWF4Jyk7XHJcblxyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYmVmb3JlIGludHJvZHVjaW5nIGFkYXB0ZXIsIGBkaXNwbGF5Rm9ybWF0c2Agd2FzXHJcblx0XHQvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXHJcblx0XHQvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXHJcblx0XHQvLyBtaXNzaW5nIGZvcm1hdHMgb24gdXBkYXRlXHJcblx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLnVwZGF0ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXHJcblx0ICovXHJcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcclxuXHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmF3VmFsdWUgPSByYXdWYWx1ZS50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCByYXdWYWx1ZSk7XHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XHJcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcclxuXHRcdHZhciBtaW4gPSBNQVhfSU5URUdFUjtcclxuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcclxuXHRcdHZhciB0aW1lc3RhbXBzID0gW107XHJcblx0XHR2YXIgZGF0YXNldHMgPSBbXTtcclxuXHRcdHZhciBsYWJlbHMgPSBbXTtcclxuXHRcdHZhciBpLCBqLCBpbGVuLCBqbGVuLCBkYXRhLCB0aW1lc3RhbXAsIGxhYmVsc0FkZGVkO1xyXG5cdFx0dmFyIGRhdGFMYWJlbHMgPSBtZS5fZ2V0TGFiZWxzKCk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFMYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRcdGxhYmVscy5wdXNoKHBhcnNlKG1lLCBkYXRhTGFiZWxzW2ldKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcclxuXHRcdFx0XHRkYXRhID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5kYXRhO1xyXG5cclxuXHRcdFx0XHQvLyBMZXQncyBjb25zaWRlciB0aGF0IGFsbCBkYXRhIGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxyXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNPYmplY3QoZGF0YVswXSkpIHtcclxuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcblx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKG1lLCBkYXRhW2pdKTtcclxuXHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKHRpbWVzdGFtcCk7XHJcblx0XHRcdFx0XHRcdGRhdGFzZXRzW2ldW2pdID0gdGltZXN0YW1wO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IGxhYmVscy5zbGljZSgwKTtcclxuXHRcdFx0XHRcdGlmICghbGFiZWxzQWRkZWQpIHtcclxuXHRcdFx0XHRcdFx0dGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KGxhYmVscyk7XHJcblx0XHRcdFx0XHRcdGxhYmVsc0FkZGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYWJlbHMubGVuZ3RoKSB7XHJcblx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgbGFiZWxzWzBdKTtcclxuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IGlsZW4gPiAxID8gYXJyYXlVbmlxdWUodGltZXN0YW1wcykuc29ydChzb3J0ZXIpIDogdGltZXN0YW1wcy5zb3J0KHNvcnRlcik7XHJcblx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgdGltZXN0YW1wc1swXSk7XHJcblx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcclxuXHRcdH1cclxuXHJcblx0XHRtaW4gPSBwYXJzZShtZSwgZ2V0TWluKG9wdGlvbnMpKSB8fCBtaW47XHJcblx0XHRtYXggPSBwYXJzZShtZSwgZ2V0TWF4KG9wdGlvbnMpKSB8fCBtYXg7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSB0aGVyZSBpcyBubyB2YWxpZCBtaW4vbWF4LCBzZXQgbGltaXRzIGJhc2VkIG9uIHVuaXQgdGltZSBvcHRpb25cclxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xyXG5cdFx0bWF4ID0gbWF4ID09PSBNSU5fSU5URUdFUiA/ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMSA6IG1heDtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxyXG5cdFx0bWUubWluID0gTWF0aC5taW4obWluLCBtYXgpO1xyXG5cdFx0bWUubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcclxuXHJcblx0XHQvLyBQUklWQVRFXHJcblx0XHRtZS5fdGFibGUgPSBbXTtcclxuXHRcdG1lLl90aW1lc3RhbXBzID0ge1xyXG5cdFx0XHRkYXRhOiB0aW1lc3RhbXBzLFxyXG5cdFx0XHRkYXRhc2V0czogZGF0YXNldHMsXHJcblx0XHRcdGxhYmVsczogbGFiZWxzXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciBtaW4gPSBtZS5taW47XHJcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuXHRcdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcclxuXHRcdHZhciB0aW1lc3RhbXBzID0gbWUuX3RpbWVzdGFtcHM7XHJcblx0XHR2YXIgdGlja3MgPSBbXTtcclxuXHRcdHZhciBjYXBhY2l0eSA9IG1lLmdldExhYmVsQ2FwYWNpdHkobWluKTtcclxuXHRcdHZhciBzb3VyY2UgPSB0aWNrT3B0cy5zb3VyY2U7XHJcblx0XHR2YXIgZGlzdHJpYnV0aW9uID0gb3B0aW9ucy5kaXN0cmlidXRpb247XHJcblx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xyXG5cclxuXHRcdGlmIChzb3VyY2UgPT09ICdkYXRhJyB8fCAoc291cmNlID09PSAnYXV0bycgJiYgZGlzdHJpYnV0aW9uID09PSAnc2VyaWVzJykpIHtcclxuXHRcdFx0dGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuZGF0YTtcclxuXHRcdH0gZWxzZSBpZiAoc291cmNlID09PSAnbGFiZWxzJykge1xyXG5cdFx0XHR0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5sYWJlbHM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWUsIG1pbiwgbWF4LCBjYXBhY2l0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XHJcblx0XHRcdG1pbiA9IHRpbWVzdGFtcHNbMF07XHJcblx0XHRcdG1heCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXHJcblx0XHRtaW4gPSBwYXJzZShtZSwgZ2V0TWluKG9wdGlvbnMpKSB8fCBtaW47XHJcblx0XHRtYXggPSBwYXJzZShtZSwgZ2V0TWF4KG9wdGlvbnMpKSB8fCBtYXg7XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIHRpY2tzIG91dHNpZGUgdGhlIG1pbi9tYXggcmFuZ2VcclxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xyXG5cdFx0XHRpZiAodGltZXN0YW1wID49IG1pbiAmJiB0aW1lc3RhbXAgPD0gbWF4KSB7XHJcblx0XHRcdFx0dGlja3MucHVzaCh0aW1lc3RhbXApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubWluID0gbWluO1xyXG5cdFx0bWUubWF4ID0gbWF4O1xyXG5cclxuXHRcdC8vIFBSSVZBVEVcclxuXHRcdC8vIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIHJlbGllcyBvbiB0aGUgbnVtYmVyIG9mIHRpY2tzIHNvIHdlIGRvbid0IHVzZSBpdCB3aGVuXHJcblx0XHQvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcclxuXHRcdG1lLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcclxuXHRcdFx0PyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1lLm1pbiwgbWUubWF4LCBjYXBhY2l0eSlcclxuXHRcdFx0OiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhtZSwgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCkpO1xyXG5cdFx0bWUuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IG1lLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcclxuXHRcdFx0OiBkZXRlcm1pbmVNYWpvclVuaXQobWUuX3VuaXQpO1xyXG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKTtcclxuXHRcdG1lLl9vZmZzZXRzID0gY29tcHV0ZU9mZnNldHMobWUuX3RhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XHJcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyhtZSwgdGlja3MsIG1lLl9tYWpvclVuaXQpO1xyXG5cdH0sXHJcblxyXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xyXG5cdFx0dmFyIGRhdGEgPSBtZS5jaGFydC5kYXRhO1xyXG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xyXG5cdFx0dmFyIGxhYmVsID0gZGF0YS5sYWJlbHMgJiYgaW5kZXggPCBkYXRhLmxhYmVscy5sZW5ndGggPyBkYXRhLmxhYmVsc1tpbmRleF0gOiAnJztcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcclxuXHJcblx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xyXG5cdFx0XHRsYWJlbCA9IG1lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcclxuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuIGxhYmVsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRpY2tGb3JtYXRGdW5jdGlvbjogZnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XHJcblx0XHR2YXIgbWlub3JGb3JtYXQgPSBmb3JtYXRzW21lLl91bml0XTtcclxuXHRcdHZhciBtYWpvclVuaXQgPSBtZS5fbWFqb3JVbml0O1xyXG5cdFx0dmFyIG1ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xyXG5cdFx0dmFyIHRpY2sgPSB0aWNrc1tpbmRleF07XHJcblx0XHR2YXIgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcclxuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XHJcblx0XHR2YXIgbmVzdGVkVGlja09wdHMgPSBtYWpvciA/IHRpY2tPcHRzLm1ham9yIDogdGlja09wdHMubWlub3I7XHJcblx0XHR2YXIgZm9ybWF0dGVyID0gcmVzb2x2ZSQ1KFtcclxuXHRcdFx0bmVzdGVkVGlja09wdHMuY2FsbGJhY2ssXHJcblx0XHRcdG5lc3RlZFRpY2tPcHRzLnVzZXJDYWxsYmFjayxcclxuXHRcdFx0dGlja09wdHMuY2FsbGJhY2ssXHJcblx0XHRcdHRpY2tPcHRzLnVzZXJDYWxsYmFja1xyXG5cdFx0XSk7XHJcblxyXG5cdFx0cmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihsYWJlbCwgaW5kZXgsIHRpY2tzKSA6IGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbih0aWNrcykge1xyXG5cdFx0dmFyIGxhYmVscyA9IFtdO1xyXG5cdFx0dmFyIGksIGlsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbih0aWNrc1tpXS52YWx1ZSwgaSwgdGlja3MpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGFiZWxzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb2Zmc2V0cyA9IG1lLl9vZmZzZXRzO1xyXG5cdFx0dmFyIHBvcyA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAndGltZScsIHRpbWUsICdwb3MnKTtcclxuXHRcdHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIHRpbWUgPSBudWxsO1xyXG5cclxuXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGltZSA9PT0gbnVsbCkge1xyXG5cdFx0XHR0aW1lID0gcGFyc2UobWUsIHZhbHVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGltZSAhPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JPZmZzZXQodGltZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xyXG5cdFx0cmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGggP1xyXG5cdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxyXG5cdFx0XHRudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcclxuXHRcdHZhciBwb3MgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcclxuXHRcdHZhciB0aW1lID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XHJcblxyXG5cdFx0Ly8gREVQUkVDQVRJT04sIHdlIHNob3VsZCByZXR1cm4gdGltZSBkaXJlY3RseVxyXG5cdFx0cmV0dXJuIG1lLl9hZGFwdGVyLl9jcmVhdGUodGltZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0TGFiZWxTaXplOiBmdW5jdGlvbihsYWJlbCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aWNrc09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xyXG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcclxuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xyXG5cdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cdFx0dmFyIHRpY2tGb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0JGQodGlja3NPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXHJcblx0XHRcdGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiB3aGF0IHRoZSBsYWJlbCB3aWR0aCBtaWdodCBiZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGFiZWxXaWR0aDogZnVuY3Rpb24obGFiZWwpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRMYWJlbFNpemUobGFiZWwpLnc7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRMYWJlbENhcGFjaXR5OiBmdW5jdGlvbihleGFtcGxlVGltZSkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcclxuXHRcdHZhciBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xyXG5cclxuXHRcdC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzdGltYXRpb25cclxuXHRcdHZhciBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcclxuXHRcdHZhciBleGFtcGxlTGFiZWwgPSBtZS50aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIFtleGFtcGxlVGltZV0sIG1lLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xyXG5cdFx0dmFyIHNpemUgPSBtZS5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XHJcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKG1lLmlzSG9yaXpvbnRhbCgpID8gbWUud2lkdGggLyBzaXplLncgOiBtZS5oZWlnaHQgLyBzaXplLmgpO1xyXG5cclxuXHRcdGlmIChtZS5vcHRpb25zLm9mZnNldCkge1xyXG5cdFx0XHRjYXBhY2l0eS0tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xyXG52YXIgX2RlZmF1bHRzJDQgPSBkZWZhdWx0Q29uZmlnJDQ7XG5zY2FsZV90aW1lLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQ0O1xuXG52YXIgc2NhbGVzID0ge1xyXG5cdGNhdGVnb3J5OiBzY2FsZV9jYXRlZ29yeSxcclxuXHRsaW5lYXI6IHNjYWxlX2xpbmVhcixcclxuXHRsb2dhcml0aG1pYzogc2NhbGVfbG9nYXJpdGhtaWMsXHJcblx0cmFkaWFsTGluZWFyOiBzY2FsZV9yYWRpYWxMaW5lYXIsXHJcblx0dGltZTogc2NhbGVfdGltZVxyXG59O1xuXG52YXIgRk9STUFUUyA9IHtcclxuXHRkYXRldGltZTogJ01NTSBELCBZWVlZLCBoOm1tOnNzIGEnLFxyXG5cdG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsXHJcblx0c2Vjb25kOiAnaDptbTpzcyBhJyxcclxuXHRtaW51dGU6ICdoOm1tIGEnLFxyXG5cdGhvdXI6ICdoQScsXHJcblx0ZGF5OiAnTU1NIEQnLFxyXG5cdHdlZWs6ICdsbCcsXHJcblx0bW9udGg6ICdNTU0gWVlZWScsXHJcblx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJyxcclxuXHR5ZWFyOiAnWVlZWSdcclxufTtcclxuXHJcbmNvcmVfYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGUodHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHtcclxuXHRfaWQ6ICdtb21lbnQnLCAvLyBERUJVRyBPTkxZXHJcblxyXG5cdGZvcm1hdHM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIEZPUk1BVFM7XHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcclxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlLCBmb3JtYXQpO1xyXG5cdFx0fSBlbHNlIGlmICghKHZhbHVlIGluc3RhbmNlb2YgbW9tZW50KSkge1xyXG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWUuaXNWYWxpZCgpID8gdmFsdWUudmFsdWVPZigpIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRmb3JtYXQ6IGZ1bmN0aW9uKHRpbWUsIGZvcm1hdCkge1xyXG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xyXG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5hZGQoYW1vdW50LCB1bml0KS52YWx1ZU9mKCk7XHJcblx0fSxcclxuXHJcblx0ZGlmZjogZnVuY3Rpb24obWF4LCBtaW4sIHVuaXQpIHtcclxuXHRcdHJldHVybiBtb21lbnQobWF4KS5kaWZmKG1vbWVudChtaW4pLCB1bml0KTtcclxuXHR9LFxyXG5cclxuXHRzdGFydE9mOiBmdW5jdGlvbih0aW1lLCB1bml0LCB3ZWVrZGF5KSB7XHJcblx0XHR0aW1lID0gbW9tZW50KHRpbWUpO1xyXG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xyXG5cdFx0XHRyZXR1cm4gdGltZS5pc29XZWVrZGF5KHdlZWtkYXkpLnZhbHVlT2YoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xyXG5cdH0sXHJcblxyXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XHJcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmVuZE9mKHVuaXQpLnZhbHVlT2YoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBERVBSRUNBVElPTlNcclxuXHJcblx0LyoqXHJcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCkuXHJcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcclxuXHRcdHJldHVybiBtb21lbnQodGltZSk7XHJcblx0fSxcclxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XHJcblx0cGx1Z2luczoge1xyXG5cdFx0ZmlsbGVyOiB7XHJcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgbWFwcGVycyA9IHtcclxuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5maWxsO1xyXG5cdFx0dmFyIGNoYXJ0ID0gc291cmNlLmNoYXJ0O1xyXG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XHJcblx0XHR2YXIgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XHJcblx0XHR2YXIgcG9pbnRzID0gKHZpc2libGUgJiYgbWV0YS5kYXRhc2V0Ll9jaGlsZHJlbikgfHwgW107XHJcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xyXG5cclxuXHRcdHJldHVybiAhbGVuZ3RoID8gbnVsbCA6IGZ1bmN0aW9uKHBvaW50LCBpKSB7XHJcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kYXJ5OiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdHZhciBib3VuZGFyeSA9IHNvdXJjZS5ib3VuZGFyeTtcclxuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcclxuXHRcdHZhciB5ID0gYm91bmRhcnkgPyBib3VuZGFyeS55IDogbnVsbDtcclxuXHJcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoYm91bmRhcnkpKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihwb2ludCwgaSkge1xyXG5cdFx0XHRcdHJldHVybiBib3VuZGFyeVtpXTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiB4ID09PSBudWxsID8gcG9pbnQueCA6IHgsXHJcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxyXG5mdW5jdGlvbiBkZWNvZGVGaWxsKGVsLCBpbmRleCwgY291bnQpIHtcclxuXHR2YXIgbW9kZWwgPSBlbC5fbW9kZWwgfHwge307XHJcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xyXG5cdHZhciB0YXJnZXQ7XHJcblxyXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGZpbGwgPSAhIW1vZGVsLmJhY2tncm91bmRDb2xvcjtcclxuXHR9XHJcblxyXG5cdGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRpZiAoZmlsbCA9PT0gdHJ1ZSkge1xyXG5cdFx0cmV0dXJuICdvcmlnaW4nO1xyXG5cdH1cclxuXHJcblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XHJcblx0aWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcclxuXHRcdGlmIChmaWxsWzBdID09PSAnLScgfHwgZmlsbFswXSA9PT0gJysnKSB7XHJcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChmaWxsKSB7XHJcblx0Ly8gY29tcGF0aWJpbGl0eVxyXG5cdGNhc2UgJ2JvdHRvbSc6XHJcblx0XHRyZXR1cm4gJ3N0YXJ0JztcclxuXHRjYXNlICd0b3AnOlxyXG5cdFx0cmV0dXJuICdlbmQnO1xyXG5cdGNhc2UgJ3plcm8nOlxyXG5cdFx0cmV0dXJuICdvcmlnaW4nO1xyXG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXHJcblx0Y2FzZSAnb3JpZ2luJzpcclxuXHRjYXNlICdzdGFydCc6XHJcblx0Y2FzZSAnZW5kJzpcclxuXHRcdHJldHVybiBmaWxsO1xyXG5cdC8vIGludmFsaWQgZmlsbCB2YWx1ZXNcclxuXHRkZWZhdWx0OlxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xyXG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XHJcblx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcclxuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xyXG5cdHZhciB0YXJnZXQgPSBudWxsO1xyXG5cdHZhciBob3Jpem9udGFsO1xyXG5cclxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogdW50aWwgdjMsIHdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBib3VuZGFyeSB2YWx1ZXMgc2V0IG9uXHJcblx0Ly8gdGhlIG1vZGVsIChzY2FsZVRvcCwgc2NhbGVCb3R0b20gYW5kIHNjYWxlWmVybykgYmVjYXVzZSBzb21lIGV4dGVybmFsIHBsdWdpbnMgYW5kXHJcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXHJcblxyXG5cdGlmIChmaWxsID09PSAnc3RhcnQnKSB7XHJcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XHJcblx0fSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xyXG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVUb3AgPT09IHVuZGVmaW5lZCA/IHNjYWxlLnRvcCA6IG1vZGVsLnNjYWxlVG9wO1xyXG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlWmVybztcclxuXHR9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xyXG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XHJcblx0fVxyXG5cclxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XHJcblx0XHRpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XHJcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiBob3Jpem9udGFsID8gdGFyZ2V0IDogbnVsbCxcclxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xyXG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGU7XHJcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xyXG5cdHZhciBsZW5ndGggPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XHJcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuXHR2YXIgdGFyZ2V0ID0gW107XHJcblx0dmFyIHN0YXJ0LCBlbmQsIGNlbnRlciwgaSwgcG9pbnQ7XHJcblxyXG5cdGlmICghbGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN0YXJ0ID0gb3B0aW9ucy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xyXG5cdGVuZCA9IG9wdGlvbnMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcclxuXHRjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG5cdFx0cG9pbnQgPSBmaWxsID09PSAnc3RhcnQnIHx8IGZpbGwgPT09ICdlbmQnXHJcblx0XHRcdD8gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIGZpbGwgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZClcclxuXHRcdFx0OiBzY2FsZS5nZXRCYXNlUG9zaXRpb24oaSk7XHJcblx0XHRpZiAob3B0aW9ucy5ncmlkTGluZXMuY2lyY3VsYXIpIHtcclxuXHRcdFx0cG9pbnQuY3ggPSBjZW50ZXIueDtcclxuXHRcdFx0cG9pbnQuY3kgPSBjZW50ZXIueTtcclxuXHRcdFx0cG9pbnQuYW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpIC0gTWF0aC5QSSAvIDI7XHJcblx0XHR9XHJcblx0XHR0YXJnZXQucHVzaChwb2ludCk7XHJcblx0fVxyXG5cdHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcclxuXHR2YXIgc2NhbGUgPSBzb3VyY2UuZWwuX3NjYWxlIHx8IHt9O1xyXG5cclxuXHRpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XHJcblx0XHRyZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcclxuXHR9XHJcblx0cmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcclxuXHR2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XHJcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuXHR2YXIgdmlzaXRlZCA9IFtpbmRleF07XHJcblx0dmFyIHRhcmdldDtcclxuXHJcblx0aWYgKCFwcm9wYWdhdGUpIHtcclxuXHRcdHJldHVybiBmaWxsO1xyXG5cdH1cclxuXHJcblx0d2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcclxuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcclxuXHRcdFx0cmV0dXJuIGZpbGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcclxuXHRcdGlmICghdGFyZ2V0KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcclxuXHRcdFx0cmV0dXJuIGZpbGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmlzaXRlZC5wdXNoKGZpbGwpO1xyXG5cdFx0ZmlsbCA9IHRhcmdldC5maWxsO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNYXBwZXIoc291cmNlKSB7XHJcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuXHR2YXIgdHlwZSA9ICdkYXRhc2V0JztcclxuXHJcblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcclxuXHRcdHR5cGUgPSAnYm91bmRhcnknO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1hcHBlcnNbdHlwZV0oc291cmNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEcmF3YWJsZShwb2ludCkge1xyXG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xyXG5cdHZhciBpLCBjeCwgY3ksIHI7XHJcblxyXG5cdGlmICghbGVuMCB8fCAhbGVuMSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Ly8gYnVpbGRpbmcgZmlyc3QgYXJlYSBjdXJ2ZSAobm9ybWFsKVxyXG5cdGN0eC5tb3ZlVG8oY3VydmUwWzBdLngsIGN1cnZlMFswXS55KTtcclxuXHRmb3IgKGkgPSAxOyBpIDwgbGVuMDsgKytpKSB7XHJcblx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMFtpIC0gMV0sIGN1cnZlMFtpXSk7XHJcblx0fVxyXG5cclxuXHRpZiAoY3VydmUxWzBdLmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGN4ID0gY3VydmUxWzBdLmN4O1xyXG5cdFx0Y3kgPSBjdXJ2ZTFbMF0uY3k7XHJcblx0XHRyID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnZlMVswXS54IC0gY3gsIDIpICsgTWF0aC5wb3coY3VydmUxWzBdLnkgLSBjeSwgMikpO1xyXG5cdFx0Zm9yIChpID0gbGVuMSAtIDE7IGkgPiAwOyAtLWkpIHtcclxuXHRcdFx0Y3R4LmFyYyhjeCwgY3ksIHIsIGN1cnZlMVtpXS5hbmdsZSwgY3VydmUxW2kgLSAxXS5hbmdsZSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHQvLyBqb2luaW5nIHRoZSB0d28gYXJlYSBjdXJ2ZXNcclxuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcclxuXHJcblx0Ly8gYnVpbGRpbmcgb3Bwb3NpdGUgYXJlYSBjdXJ2ZSAocmV2ZXJzZSlcclxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xyXG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTFbaV0sIGN1cnZlMVtpIC0gMV0sIHRydWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgcG9pbnRzLCBtYXBwZXIsIHZpZXcsIGNvbG9yLCBsb29wKSB7XHJcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcclxuXHR2YXIgc3BhbiA9IHZpZXcuc3BhbkdhcHM7XHJcblx0dmFyIGN1cnZlMCA9IFtdO1xyXG5cdHZhciBjdXJ2ZTEgPSBbXTtcclxuXHR2YXIgbGVuMCA9IDA7XHJcblx0dmFyIGxlbjEgPSAwO1xyXG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDEsIGxvb3BPZmZzZXQ7XHJcblxyXG5cdGN0eC5iZWdpblBhdGgoKTtcclxuXHJcblx0Zm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XHJcblx0XHRpbmRleCA9IGkgJSBjb3VudDtcclxuXHRcdHAwID0gcG9pbnRzW2luZGV4XS5fdmlldztcclxuXHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XHJcblx0XHRkMCA9IGlzRHJhd2FibGUocDApO1xyXG5cdFx0ZDEgPSBpc0RyYXdhYmxlKHAxKTtcclxuXHJcblx0XHRpZiAobG9vcCAmJiBsb29wT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgZDApIHtcclxuXHRcdFx0bG9vcE9mZnNldCA9IGkgKyAxO1xyXG5cdFx0XHRpbGVuID0gY291bnQgKyBsb29wT2Zmc2V0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkMCAmJiBkMSkge1xyXG5cdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xyXG5cdFx0XHRsZW4xID0gY3VydmUxLnB1c2gocDEpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW4wICYmIGxlbjEpIHtcclxuXHRcdFx0aWYgKCFzcGFuKSB7XHJcblx0XHRcdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XHJcblx0XHRcdFx0bGVuMCA9IGxlbjEgPSAwO1xyXG5cdFx0XHRcdGN1cnZlMCA9IFtdO1xyXG5cdFx0XHRcdGN1cnZlMSA9IFtdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChkMCkge1xyXG5cdFx0XHRcdFx0Y3VydmUwLnB1c2gocDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoZDEpIHtcclxuXHRcdFx0XHRcdGN1cnZlMS5wdXNoKHAxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xyXG5cclxuXHRjdHguY2xvc2VQYXRoKCk7XHJcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG5cdGN0eC5maWxsKCk7XHJcbn1cclxuXHJcbnZhciBwbHVnaW5fZmlsbGVyID0ge1xyXG5cdGlkOiAnZmlsbGVyJyxcclxuXHJcblx0YWZ0ZXJEYXRhc2V0c1VwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XHJcblx0XHR2YXIgcHJvcGFnYXRlID0gb3B0aW9ucy5wcm9wYWdhdGU7XHJcblx0XHR2YXIgc291cmNlcyA9IFtdO1xyXG5cdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRlbCA9IG1ldGEuZGF0YXNldDtcclxuXHRcdFx0c291cmNlID0gbnVsbDtcclxuXHJcblx0XHRcdGlmIChlbCAmJiBlbC5fbW9kZWwgJiYgZWwgaW5zdGFuY2VvZiBlbGVtZW50cy5MaW5lKSB7XHJcblx0XHRcdFx0c291cmNlID0ge1xyXG5cdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcclxuXHRcdFx0XHRcdGZpbGw6IGRlY29kZUZpbGwoZWwsIGksIGNvdW50KSxcclxuXHRcdFx0XHRcdGNoYXJ0OiBjaGFydCxcclxuXHRcdFx0XHRcdGVsOiBlbFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcclxuXHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcclxuXHRcdFx0aWYgKCFzb3VyY2UpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c291cmNlLmZpbGwgPSByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIHByb3BhZ2F0ZSk7XHJcblx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xyXG5cdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YmVmb3JlRGF0YXNldHNEcmF3OiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XHJcblx0XHR2YXIgbWV0YSwgaSwgZWwsIHZpZXcsIHBvaW50cywgbWFwcGVyLCBjb2xvcjtcclxuXHJcblx0XHRmb3IgKGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdFx0XHRtZXRhID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcclxuXHJcblx0XHRcdGlmICghbWV0YSB8fCAhbWV0YS52aXNpYmxlKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVsID0gbWV0YS5lbDtcclxuXHRcdFx0dmlldyA9IGVsLl92aWV3O1xyXG5cdFx0XHRwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XHJcblx0XHRcdG1hcHBlciA9IG1ldGEubWFwcGVyO1xyXG5cdFx0XHRjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcclxuXHJcblx0XHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY3R4LCBjaGFydC5jaGFydEFyZWEpO1xyXG5cdFx0XHRcdGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgZWwuX2xvb3ApO1xyXG5cdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgZ2V0UnRsSGVscGVyJDEgPSBoZWxwZXJzJDEucnRsLmdldFJ0bEFkYXB0ZXI7XHJcbnZhciBub29wJDEgPSBoZWxwZXJzJDEubm9vcDtcclxudmFyIHZhbHVlT3JEZWZhdWx0JGUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHRsZWdlbmQ6IHtcclxuXHRcdGRpc3BsYXk6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcCcsXHJcblx0XHRhbGlnbjogJ2NlbnRlcicsXHJcblx0XHRmdWxsV2lkdGg6IHRydWUsXHJcblx0XHRyZXZlcnNlOiBmYWxzZSxcclxuXHRcdHdlaWdodDogMTAwMCxcclxuXHJcblx0XHQvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcclxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcclxuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XHJcblx0XHRcdHZhciBjaSA9IHRoaXMuY2hhcnQ7XHJcblx0XHRcdHZhciBtZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xyXG5cclxuXHRcdFx0Ly8gU2VlIGNvbnRyb2xsZXIuaXNEYXRhc2V0VmlzaWJsZSBjb21tZW50XHJcblx0XHRcdG1ldGEuaGlkZGVuID0gbWV0YS5oaWRkZW4gPT09IG51bGwgPyAhY2kuZGF0YS5kYXRhc2V0c1tpbmRleF0uaGlkZGVuIDogbnVsbDtcclxuXHJcblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxyXG5cdFx0XHRjaS51cGRhdGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0b25Ib3ZlcjogbnVsbCxcclxuXHRcdG9uTGVhdmU6IG51bGwsXHJcblxyXG5cdFx0bGFiZWxzOiB7XHJcblx0XHRcdGJveFdpZHRoOiA0MCxcclxuXHRcdFx0cGFkZGluZzogMTAsXHJcblx0XHRcdC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxyXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcclxuXHRcdFx0Ly8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxyXG5cdFx0XHQvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxyXG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxyXG5cdFx0XHQvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXHJcblx0XHRcdC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcclxuXHRcdFx0Ly8gbGluZURhc2hcclxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgOlxyXG5cdFx0XHQvLyBsaW5lSm9pbiA6XHJcblx0XHRcdC8vIGxpbmVXaWR0aCA6XHJcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0XHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XHJcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZCB8fCB7fTtcclxuXHRcdFx0XHR2YXIgdXNlUG9pbnRTdHlsZSA9IG9wdGlvbnMubGFiZWxzICYmIG9wdGlvbnMubGFiZWxzLnVzZVBvaW50U3R5bGU7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKGZ1bmN0aW9uKG1ldGEpIHtcclxuXHRcdFx0XHRcdHZhciBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0dGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXHJcblx0XHRcdFx0XHRcdGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxyXG5cdFx0XHRcdFx0XHRoaWRkZW46ICFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKG1ldGEuaW5kZXgpLFxyXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcclxuXHRcdFx0XHRcdFx0bGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXHJcblx0XHRcdFx0XHRcdGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxyXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxyXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxyXG5cdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IHN0eWxlLnBvaW50U3R5bGUsXHJcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcclxuXHJcblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXHJcblx0XHRcdFx0XHRcdGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xyXG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcclxuXHRcdHZhciBpLCBpbGVuLCBsaXN0SXRlbSwgbGlzdEl0ZW1TcGFuO1xyXG5cclxuXHRcdGxpc3Quc2V0QXR0cmlidXRlKCdjbGFzcycsIGNoYXJ0LmlkICsgJy1sZWdlbmQnKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcblx0XHRcdGxpc3RJdGVtID0gbGlzdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpKTtcclxuXHRcdFx0bGlzdEl0ZW1TcGFuID0gbGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKTtcclxuXHRcdFx0bGlzdEl0ZW1TcGFuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXRzW2ldLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdFx0aWYgKGRhdGFzZXRzW2ldLmxhYmVsKSB7XHJcblx0XHRcdFx0bGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YXNldHNbaV0ubGFiZWwpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaXN0Lm91dGVySFRNTDtcclxuXHR9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cclxuICogQHBhcmFtIHtvYmplY3R9IGxhYmVsb3B0cyAtIHRoZSBsYWJlbCBvcHRpb25zIG9uIHRoZSBsZWdlbmRcclxuICogQHBhcmFtIHtudW1iZXJ9IGZvbnRTaXplIC0gdGhlIGxhYmVsIGZvbnQgc2l6ZVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSkge1xyXG5cdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSAmJiBsYWJlbE9wdHMuYm94V2lkdGggPiBmb250U2l6ZSA/XHJcblx0XHRmb250U2l6ZSA6XHJcblx0XHRsYWJlbE9wdHMuYm94V2lkdGg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXHJcbiAqL1xyXG52YXIgTGVnZW5kID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdGhlbHBlcnMkMS5leHRlbmQobWUsIGNvbmZpZyk7XHJcblxyXG5cdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXHJcblx0XHRtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xyXG5cclxuXHRcdC8qKlxyXG4gXHRcdCAqIEBwcml2YXRlXHJcbiBcdFx0ICovXHJcblx0XHRtZS5faG92ZXJlZEl0ZW0gPSBudWxsO1xyXG5cclxuXHRcdC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcclxuXHRcdG1lLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXHJcblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cclxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBsZWdlbmQgdHlwZVxyXG5cclxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMSxcclxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcclxuXHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xyXG5cdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcclxuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcclxuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xyXG5cclxuXHRcdC8vIERpbWVuc2lvbnNcclxuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xyXG5cdFx0Ly8gTGFiZWxzXHJcblx0XHRtZS5iZWZvcmVCdWlsZExhYmVscygpO1xyXG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcclxuXHJcblx0XHQvLyBGaXRcclxuXHRcdG1lLmJlZm9yZUZpdCgpO1xyXG5cdFx0bWUuZml0KCk7XHJcblx0XHRtZS5hZnRlckZpdCgpO1xyXG5cdFx0Ly9cclxuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XHJcblx0fSxcclxuXHRhZnRlclVwZGF0ZTogbm9vcCQxLFxyXG5cclxuXHQvL1xyXG5cclxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDEsXHJcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cclxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cclxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcclxuXHRcdFx0bWUubGVmdCA9IDA7XHJcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XHJcblxyXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cclxuXHRcdFx0bWUudG9wID0gMDtcclxuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcclxuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcclxuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xyXG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcclxuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xyXG5cclxuXHRcdC8vIFJlc2V0IG1pblNpemVcclxuXHRcdG1lLm1pblNpemUgPSB7XHJcblx0XHRcdHdpZHRoOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IDBcclxuXHRcdH07XHJcblx0fSxcclxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMSxcclxuXHRidWlsZExhYmVsczogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGxhYmVsT3B0cyA9IG1lLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xyXG5cdFx0dmFyIGxlZ2VuZEl0ZW1zID0gaGVscGVycyQxLmNhbGxiYWNrKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW21lLmNoYXJ0XSwgbWUpIHx8IFtdO1xyXG5cclxuXHRcdGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XHJcblx0XHRcdGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xyXG5cdFx0XHRsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWUubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcclxuXHR9LFxyXG5cdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AkMSxcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlRml0OiBub29wJDEsXHJcblx0Zml0OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XHJcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcclxuXHJcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xyXG5cclxuXHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XHJcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcclxuXHJcblx0XHQvLyBSZXNldCBoaXQgYm94ZXNcclxuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XHJcblxyXG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xyXG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcclxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gMTAgOiAwO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XHJcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxyXG5cdFx0aWYgKCFkaXNwbGF5KSB7XHJcblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aCA9IG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0ID0gMDtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xyXG5cclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0Ly8gTGFiZWxzXHJcblxyXG5cdFx0XHQvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcclxuXHRcdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzID0gWzBdO1xyXG5cdFx0XHR2YXIgdG90YWxIZWlnaHQgPSAwO1xyXG5cclxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5cclxuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcclxuXHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XHJcblxyXG5cdFx0XHRcdGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIHdpZHRoICsgMiAqIGxhYmVsT3B0cy5wYWRkaW5nID4gbWluU2l6ZS53aWR0aCkge1xyXG5cdFx0XHRcdFx0dG90YWxIZWlnaHQgKz0gZm9udFNpemUgKyBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXHJcblx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XHJcblx0XHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IHRvdGFsSGVpZ2h0O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHR2YXIgY29sdW1uV2lkdGhzID0gbWUuY29sdW1uV2lkdGhzID0gW107XHJcblx0XHRcdHZhciBjb2x1bW5IZWlnaHRzID0gbWUuY29sdW1uSGVpZ2h0cyA9IFtdO1xyXG5cdFx0XHR2YXIgdG90YWxXaWR0aCA9IGxhYmVsT3B0cy5wYWRkaW5nO1xyXG5cdFx0XHR2YXIgY3VycmVudENvbFdpZHRoID0gMDtcclxuXHRcdFx0dmFyIGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xyXG5cclxuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcclxuXHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcclxuXHRcdFx0XHR2YXIgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xyXG5cclxuXHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxyXG5cdFx0XHRcdGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgZm9udFNpemUgKyAyICogdlBhZGRpbmcgPiBtaW5TaXplLmhlaWdodCkge1xyXG5cdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7IC8vIHByZXZpb3VzIGNvbHVtbiB3aWR0aFxyXG5cdFx0XHRcdFx0Y29sdW1uSGVpZ2h0cy5wdXNoKGN1cnJlbnRDb2xIZWlnaHQpO1xyXG5cdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcclxuXHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gR2V0IG1heCB3aWR0aFxyXG5cdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcclxuXHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ICs9IGZvbnRTaXplICsgdlBhZGRpbmc7XHJcblxyXG5cdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXHJcblx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XHJcblx0XHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdFx0d2lkdGg6IGl0ZW1XaWR0aCxcclxuXHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xyXG5cdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xyXG5cdFx0XHRjb2x1bW5IZWlnaHRzLnB1c2goY3VycmVudENvbEhlaWdodCk7XHJcblx0XHRcdG1pblNpemUud2lkdGggKz0gdG90YWxXaWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XHJcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcclxuXHR9LFxyXG5cdGFmdGVyRml0OiBub29wJDEsXHJcblxyXG5cdC8vIFNoYXJlZCBNZXRob2RzXHJcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgbGVnZW5kIG9uIHRoZSBjYW52YXNcclxuXHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XHJcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcclxuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7XHJcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xyXG5cdFx0dmFyIGxlZ2VuZEhlaWdodCA9IG1lLmhlaWdodDtcclxuXHRcdHZhciBjb2x1bW5IZWlnaHRzID0gbWUuY29sdW1uSGVpZ2h0cztcclxuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xyXG5cdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzO1xyXG5cclxuXHRcdGlmICghb3B0cy5kaXNwbGF5KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcnRsSGVscGVyID0gZ2V0UnRsSGVscGVyJDEob3B0cy5ydGwsIG1lLmxlZnQsIG1lLm1pblNpemUud2lkdGgpO1xyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBmb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRlKGxhYmVsT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xyXG5cdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcclxuXHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xyXG5cdFx0dmFyIGN1cnNvcjtcclxuXHJcblx0XHQvLyBDYW52YXMgc2V0dXBcclxuXHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblx0XHRjdHgubGluZVdpZHRoID0gMC41O1xyXG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxyXG5cdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xyXG5cclxuXHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xyXG5cdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XHJcblxyXG5cdFx0Ly8gY3VycmVudCBwb3NpdGlvblxyXG5cdFx0dmFyIGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XHJcblx0XHRcdGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU2V0IHRoZSBjdHggZm9yIHRoZSBib3hcclxuXHRcdFx0Y3R4LnNhdmUoKTtcclxuXHJcblx0XHRcdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xyXG5cdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XHJcblx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaE9mZnNldCk7XHJcblx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcclxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xyXG5cclxuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xyXG5cdFx0XHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxyXG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZURhc2gsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2gpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGxhYmVsT3B0cyAmJiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xyXG5cdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xyXG5cdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcclxuXHRcdFx0XHR2YXIgcmFkaXVzID0gYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMjtcclxuXHRcdFx0XHR2YXIgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xyXG5cdFx0XHRcdHZhciBjZW50ZXJZID0geSArIGZvbnRTaXplIC8gMjtcclxuXHJcblx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcclxuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZLCBsZWdlbmRJdGVtLnJvdGF0aW9uKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXHJcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKSwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcclxuXHRcdFx0XHRpZiAobGluZVdpZHRoICE9PSAwKSB7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCksIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpIHtcclxuXHRcdFx0dmFyIGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcclxuXHRcdFx0dmFyIHhMZWZ0ID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoICsgaGFsZkZvbnRTaXplKTtcclxuXHRcdFx0dmFyIHlNaWRkbGUgPSB5ICsgaGFsZkZvbnRTaXplO1xyXG5cclxuXHRcdFx0Y3R4LmZpbGxUZXh0KGxlZ2VuZEl0ZW0udGV4dCwgeExlZnQsIHlNaWRkbGUpO1xyXG5cclxuXHRcdFx0aWYgKGxlZ2VuZEl0ZW0uaGlkZGVuKSB7XHJcblx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cclxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDI7XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XHJcblx0XHRcdFx0Y3R4LmxpbmVUbyhydGxIZWxwZXIueFBsdXMoeExlZnQsIHRleHRXaWR0aCksIHlNaWRkbGUpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgYWxpZ25tZW50T2Zmc2V0ID0gZnVuY3Rpb24oZGltZW5zaW9uLCBibG9ja1NpemUpIHtcclxuXHRcdFx0c3dpdGNoIChvcHRzLmFsaWduKSB7XHJcblx0XHRcdGNhc2UgJ3N0YXJ0JzpcclxuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdGNhc2UgJ2VuZCc6XHJcblx0XHRcdFx0cmV0dXJuIGRpbWVuc2lvbiAtIGJsb2NrU2l6ZTtcclxuXHRcdFx0ZGVmYXVsdDogLy8gY2VudGVyXHJcblx0XHRcdFx0cmV0dXJuIChkaW1lbnNpb24gLSBibG9ja1NpemUgKyBsYWJlbE9wdHMucGFkZGluZykgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEhvcml6b250YWxcclxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcclxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0Y3Vyc29yID0ge1xyXG5cdFx0XHRcdHg6IG1lLmxlZnQgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kV2lkdGgsIGxpbmVXaWR0aHNbMF0pLFxyXG5cdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxyXG5cdFx0XHRcdGxpbmU6IDBcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1cnNvciA9IHtcclxuXHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXHJcblx0XHRcdFx0eTogbWUudG9wICsgYWxpZ25tZW50T2Zmc2V0KGxlZ2VuZEhlaWdodCwgY29sdW1uSGVpZ2h0c1swXSksXHJcblx0XHRcdFx0bGluZTogMFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGhlbHBlcnMkMS5ydGwub3ZlcnJpZGVUZXh0RGlyZWN0aW9uKG1lLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcclxuXHJcblx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xyXG5cdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XHJcblx0XHRcdHZhciB3aWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyB0ZXh0V2lkdGg7XHJcblx0XHRcdHZhciB4ID0gY3Vyc29yLng7XHJcblx0XHRcdHZhciB5ID0gY3Vyc29yLnk7XHJcblxyXG5cdFx0XHRydGxIZWxwZXIuc2V0V2lkdGgobWUubWluU2l6ZS53aWR0aCk7XHJcblxyXG5cdFx0XHQvLyBVc2UgKG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSBhbmQgKG1lLnRvcCArIG1lLm1pblNpemUuaGVpZ2h0KVxyXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIG1lLnJpZ2h0IGFuZCBtZS5ib3R0b20gYmVjYXVzZSBtZS53aWR0aCBhbmQgbWUuaGVpZ2h0XHJcblx0XHRcdC8vIG1heSBoYXZlIGJlZW4gY2hhbmdlZCBzaW5jZSBtZS5taW5TaXplIHdhcyBjYWxjdWxhdGVkXHJcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcclxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmcgPiBtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkge1xyXG5cdFx0XHRcdFx0eSA9IGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdFx0XHRjdXJzb3IubGluZSsrO1xyXG5cdFx0XHRcdFx0eCA9IGN1cnNvci54ID0gbWUubGVmdCArIGFsaWdubWVudE9mZnNldChsZWdlbmRXaWR0aCwgbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChpID4gMCAmJiB5ICsgaXRlbUhlaWdodCA+IG1lLnRvcCArIG1lLm1pblNpemUuaGVpZ2h0KSB7XHJcblx0XHRcdFx0eCA9IGN1cnNvci54ID0geCArIG1lLmNvbHVtbldpZHRoc1tjdXJzb3IubGluZV0gKyBsYWJlbE9wdHMucGFkZGluZztcclxuXHRcdFx0XHRjdXJzb3IubGluZSsrO1xyXG5cdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGFsaWdubWVudE9mZnNldChsZWdlbmRIZWlnaHQsIGNvbHVtbkhlaWdodHNbY3Vyc29yLmxpbmVdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJlYWxYID0gcnRsSGVscGVyLngoeCk7XHJcblxyXG5cdFx0XHRkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcclxuXHJcblx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihyZWFsWCwgaGl0Ym94ZXNbaV0ud2lkdGgpO1xyXG5cdFx0XHRoaXRib3hlc1tpXS50b3AgPSB5O1xyXG5cclxuXHRcdFx0Ly8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXHJcblx0XHRcdGZpbGxUZXh0KHJlYWxYLCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xyXG5cclxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xyXG5cdFx0XHRcdGN1cnNvci54ICs9IHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGVscGVycyQxLnJ0bC5yZXN0b3JlVGV4dERpcmVjdGlvbihtZS5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZ2V0TGVnZW5kSXRlbUF0OiBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XHJcblxyXG5cdFx0aWYgKHggPj0gbWUubGVmdCAmJiB4IDw9IG1lLnJpZ2h0ICYmIHkgPj0gbWUudG9wICYmIHkgPD0gbWUuYm90dG9tKSB7XHJcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXHJcblx0XHRcdGxoID0gbWUubGVnZW5kSGl0Qm94ZXM7XHJcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xyXG5cclxuXHRcdFx0XHRpZiAoeCA+PSBoaXRCb3gubGVmdCAmJiB4IDw9IGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoICYmIHkgPj0gaGl0Qm94LnRvcCAmJiB5IDw9IGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XHJcblx0XHRcdFx0XHRyZXR1cm4gbWUubGVnZW5kSXRlbXNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlIGFuIGV2ZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXHJcblx0ICovXHJcblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2NsaWNrJyA6IGUudHlwZTtcclxuXHRcdHZhciBob3ZlcmVkSXRlbTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdGlmICghb3B0cy5vbkNsaWNrKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcclxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xyXG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRvcHRzLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIGhvdmVyZWRJdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdHMub25MZWF2ZSAmJiBob3ZlcmVkSXRlbSAhPT0gbWUuX2hvdmVyZWRJdGVtKSB7XHJcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xyXG5cdFx0XHRcdFx0b3B0cy5vbkxlYXZlLmNhbGwobWUsIGUubmF0aXZlLCBtZS5faG92ZXJlZEl0ZW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xyXG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRvcHRzLm9uSG92ZXIuY2FsbChtZSwgZS5uYXRpdmUsIGhvdmVyZWRJdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpIHtcclxuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XHJcblx0XHRjdHg6IGNoYXJ0LmN0eCxcclxuXHRcdG9wdGlvbnM6IGxlZ2VuZE9wdHMsXHJcblx0XHRjaGFydDogY2hhcnRcclxuXHR9KTtcclxuXHJcblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcclxuXHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xyXG5cdGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcclxufVxyXG5cclxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XHJcblx0aWQ6ICdsZWdlbmQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcclxuXHQgKiBDaGFydC5MZWdlbmQgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIExlZ2VuZCBhcyBwYXJ0IG9mXHJcblx0ICogdGhlIHBsdWdpbiwgd2hpY2ggb25lIHdpbGwgYmUgcmUtZXhwb3NlZCBpbiB0aGUgY2hhcnQuanMgZmlsZS5cclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9lbGVtZW50OiBMZWdlbmQsXHJcblxyXG5cdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xyXG5cclxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XHJcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcclxuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XHJcblxyXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcclxuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcclxuXHJcblx0XHRcdGlmIChsZWdlbmQpIHtcclxuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xyXG5cdFx0XHRcdGxlZ2VuZC5vcHRpb25zID0gbGVnZW5kT3B0cztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGxlZ2VuZCkge1xyXG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xyXG5cdFx0XHRkZWxldGUgY2hhcnQubGVnZW5kO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XHJcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xyXG5cdFx0aWYgKGxlZ2VuZCkge1xyXG5cdFx0XHRsZWdlbmQuaGFuZGxlRXZlbnQoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xuXG52YXIgbm9vcCQyID0gaGVscGVycyQxLm5vb3A7XHJcblxyXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcclxuXHR0aXRsZToge1xyXG5cdFx0ZGlzcGxheTogZmFsc2UsXHJcblx0XHRmb250U3R5bGU6ICdib2xkJyxcclxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcclxuXHRcdHBhZGRpbmc6IDEwLFxyXG5cdFx0cG9zaXRpb246ICd0b3AnLFxyXG5cdFx0dGV4dDogJycsXHJcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXHJcbiAqL1xyXG52YXIgVGl0bGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKG1lLCBjb25maWcpO1xyXG5cclxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxyXG5cdFx0bWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcclxuXHR9LFxyXG5cclxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxyXG5cclxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcclxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcclxuXHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xyXG5cdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcclxuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcclxuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xyXG5cclxuXHRcdC8vIERpbWVuc2lvbnNcclxuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcclxuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xyXG5cdFx0Ly8gTGFiZWxzXHJcblx0XHRtZS5iZWZvcmVCdWlsZExhYmVscygpO1xyXG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcclxuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcclxuXHJcblx0XHQvLyBGaXRcclxuXHRcdG1lLmJlZm9yZUZpdCgpO1xyXG5cdFx0bWUuZml0KCk7XHJcblx0XHRtZS5hZnRlckZpdCgpO1xyXG5cdFx0Ly9cclxuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XHJcblxyXG5cdH0sXHJcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMixcclxuXHJcblx0Ly9cclxuXHJcblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQyLFxyXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XHJcblx0XHRcdG1lLmxlZnQgPSAwO1xyXG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXHJcblx0XHRcdG1lLnRvcCA9IDA7XHJcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXNldCBwYWRkaW5nXHJcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcclxuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XHJcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcclxuXHJcblx0XHQvLyBSZXNldCBtaW5TaXplXHJcblx0XHRtZS5taW5TaXplID0ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0aGVpZ2h0OiAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDIsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDIsXHJcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcclxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDIsXHJcblxyXG5cdC8vXHJcblxyXG5cdGJlZm9yZUZpdDogbm9vcCQyLFxyXG5cdGZpdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xyXG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge307XHJcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHR2YXIgbGluZUNvdW50LCB0ZXh0U2l6ZTtcclxuXHJcblx0XHRpZiAoIW9wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGggPSBtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IDA7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XHJcblx0XHR0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0cykubGluZUhlaWdodCArIG9wdHMucGFkZGluZyAqIDI7XHJcblxyXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoID0gaXNIb3Jpem9udGFsID8gbWUubWF4V2lkdGggOiB0ZXh0U2l6ZTtcclxuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0ID0gaXNIb3Jpem9udGFsID8gdGV4dFNpemUgOiBtZS5tYXhIZWlnaHQ7XHJcblx0fSxcclxuXHRhZnRlckZpdDogbm9vcCQyLFxyXG5cclxuXHQvLyBTaGFyZWQgTWV0aG9kc1xyXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdFx0cmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcclxuXHR9LFxyXG5cclxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSB0aXRsZSBibG9jayBvbiB0aGUgY2FudmFzXHJcblx0ZHJhdzogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcclxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcclxuXHJcblx0XHRpZiAoIW9wdHMuZGlzcGxheSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcclxuXHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcclxuXHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcclxuXHRcdHZhciByb3RhdGlvbiA9IDA7XHJcblx0XHR2YXIgdG9wID0gbWUudG9wO1xyXG5cdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xyXG5cdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcclxuXHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xyXG5cdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcclxuXHJcblx0XHRjdHguZmlsbFN0eWxlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXHJcblx0XHRjdHguZm9udCA9IGZvbnRPcHRzLnN0cmluZztcclxuXHJcblx0XHQvLyBIb3Jpem9udGFsXHJcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcclxuXHRcdFx0dGl0bGVYID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSAvIDIpOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcclxuXHRcdFx0dGl0bGVZID0gdG9wICsgb2Zmc2V0O1xyXG5cdFx0XHRtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRpdGxlWCA9IG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IGxlZnQgKyBvZmZzZXQgOiByaWdodCAtIG9mZnNldDtcclxuXHRcdFx0dGl0bGVZID0gdG9wICsgKChib3R0b20gLSB0b3ApIC8gMik7XHJcblx0XHRcdG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xyXG5cdFx0XHRyb3RhdGlvbiA9IE1hdGguUEkgKiAob3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gLTAuNSA6IDAuNSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xyXG5cdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XHJcblx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblxyXG5cdFx0dmFyIHRleHQgPSBvcHRzLnRleHQ7XHJcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcclxuXHRcdFx0dmFyIHkgPSAwO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgMCwgeSwgbWF4V2lkdGgpO1xyXG5cdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDAsIG1heFdpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpIHtcclxuXHR2YXIgdGl0bGUgPSBuZXcgVGl0bGUoe1xyXG5cdFx0Y3R4OiBjaGFydC5jdHgsXHJcblx0XHRvcHRpb25zOiB0aXRsZU9wdHMsXHJcblx0XHRjaGFydDogY2hhcnRcclxuXHR9KTtcclxuXHJcblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XHJcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xyXG5cdGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcclxufVxyXG5cclxudmFyIHBsdWdpbl90aXRsZSA9IHtcclxuXHRpZDogJ3RpdGxlJyxcclxuXHJcblx0LyoqXHJcblx0ICogQmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2luY2UgMi4xLjUsIHRoZSB0aXRsZSBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcclxuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxyXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXHJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC8yNjQwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZWxlbWVudDogVGl0bGUsXHJcblxyXG5cdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHR2YXIgdGl0bGVPcHRzID0gY2hhcnQub3B0aW9ucy50aXRsZTtcclxuXHJcblx0XHRpZiAodGl0bGVPcHRzKSB7XHJcblx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xyXG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XHJcblx0XHR2YXIgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XHJcblxyXG5cdFx0aWYgKHRpdGxlT3B0cykge1xyXG5cdFx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aXRsZU9wdHMsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLnRpdGxlKTtcclxuXHJcblx0XHRcdGlmICh0aXRsZUJsb2NrKSB7XHJcblx0XHRcdFx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGVCbG9jaywgdGl0bGVPcHRzKTtcclxuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICh0aXRsZUJsb2NrKSB7XHJcblx0XHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xyXG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcclxuXHRcdH1cclxuXHR9XHJcbn07XG5cbnZhciBwbHVnaW5zID0ge307XHJcbnZhciBmaWxsZXIgPSBwbHVnaW5fZmlsbGVyO1xyXG52YXIgbGVnZW5kID0gcGx1Z2luX2xlZ2VuZDtcclxudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnRcclxuICovXHJcblxyXG5cclxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMgPSBoZWxwZXJzJDE7XHJcblxyXG4vLyBAdG9kbyBkaXNwYXRjaCB0aGVzZSBoZWxwZXJzIGludG8gYXBwcm9wcmlhdGVkIGhlbHBlcnMvaGVscGVycy4qIGZpbGUgYW5kIHdyaXRlIHVuaXQgdGVzdHMhXHJcbmNvcmVfaGVscGVycygpO1xyXG5cclxuY29yZV9jb250cm9sbGVyLl9hZGFwdGVycyA9IGNvcmVfYWRhcHRlcnM7XHJcbmNvcmVfY29udHJvbGxlci5BbmltYXRpb24gPSBjb3JlX2FuaW1hdGlvbjtcclxuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XHJcbmNvcmVfY29udHJvbGxlci5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xyXG5jb3JlX2NvbnRyb2xsZXIuRGF0YXNldENvbnRyb2xsZXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyO1xyXG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xyXG5jb3JlX2NvbnRyb2xsZXIuRWxlbWVudCA9IGNvcmVfZWxlbWVudDtcclxuY29yZV9jb250cm9sbGVyLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XHJcbmNvcmVfY29udHJvbGxlci5sYXlvdXRzID0gY29yZV9sYXlvdXRzO1xyXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0gPSBwbGF0Zm9ybTtcclxuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XHJcbmNvcmVfY29udHJvbGxlci5TY2FsZSA9IGNvcmVfc2NhbGU7XHJcbmNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UgPSBjb3JlX3NjYWxlU2VydmljZTtcclxuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcclxuY29yZV9jb250cm9sbGVyLlRvb2x0aXAgPSBjb3JlX3Rvb2x0aXA7XHJcblxyXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcclxuXHJcbmNvcmVfY29udHJvbGxlci5oZWxwZXJzLmVhY2goc2NhbGVzLCBmdW5jdGlvbihzY2FsZSwgdHlwZSkge1xyXG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XHJcbn0pO1xyXG5cclxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxyXG5cclxuXHJcbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xyXG5cclxuZm9yICh2YXIgayBpbiBwbHVnaW5zKSB7XHJcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcclxuXHRcdGNvcmVfY29udHJvbGxlci5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbnNba10pO1xyXG5cdH1cclxufVxyXG5cclxuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtLmluaXRpYWxpemUoKTtcclxuXHJcbnZhciBzcmMgPSBjb3JlX2NvbnRyb2xsZXI7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcclxufVxyXG5cclxuLy8gREVQUkVDQVRJT05TXHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkNoYXJ0XHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICogQG5hbWVzcGFjZSBDaGFydC5MZWdlbmRcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpdGxlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxyXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpblNlcnZpY2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXHJcbiAqIGVmZmVjdCwgaW5zdGVhZCBzaW1wbHkgY3JlYXRlL3JlZ2lzdGVyIHBsdWdpbnMgdmlhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuICogQGludGVyZmFjZSBDaGFydC5QbHVnaW5CYXNlXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLlBsdWdpbkJhc2UgPSBjb3JlX2NvbnRyb2xsZXIuRWxlbWVudC5leHRlbmQoe30pO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMgaW5zdGVhZC5cclxuICogQG5hbWVzcGFjZSBDaGFydC5jYW52YXNIZWxwZXJzXHJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLmNhbnZhc0hlbHBlcnMgPSBjb3JlX2NvbnRyb2xsZXIuaGVscGVycy5jYW52YXM7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5sYXlvdXRzIGluc3RlYWQuXHJcbiAqIEBuYW1lc3BhY2UgQ2hhcnQubGF5b3V0U2VydmljZVxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXHJcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvcmVfY29udHJvbGxlci5sYXlvdXRTZXJ2aWNlID0gY29yZV9jb250cm9sbGVyLmxheW91dHM7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cclxuICogQG5hbWVzcGFjZSBDaGFydC5MaW5lYXJTY2FsZUJhc2VcclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcclxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29yZV9jb250cm9sbGVyLkxpbmVhclNjYWxlQmFzZSA9IHNjYWxlX2xpbmVhcmJhc2U7XHJcblxyXG4vKipcclxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluc3RlYWQgd2Ugc2hvdWxkIGNyZWF0ZSBhIG5ldyBDaGFydFxyXG4gKiBieSBzZXR0aW5nIHRoZSB0eXBlIGluIHRoZSBjb25maWcgKGBuZXcgQ2hhcnQoaWQsIHt0eXBlOiAne2NoYXJ0LXR5cGV9J31gKS5cclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxyXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXHJcbiAqL1xyXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxyXG5cdFtcclxuXHRcdCdCYXInLFxyXG5cdFx0J0J1YmJsZScsXHJcblx0XHQnRG91Z2hudXQnLFxyXG5cdFx0J0xpbmUnLFxyXG5cdFx0J1BvbGFyQXJlYScsXHJcblx0XHQnUmFkYXInLFxyXG5cdFx0J1NjYXR0ZXInXHJcblx0XSxcclxuXHRmdW5jdGlvbihrbGFzcykge1xyXG5cdFx0Y29yZV9jb250cm9sbGVyW2tsYXNzXSA9IGZ1bmN0aW9uKGN0eCwgY2ZnKSB7XHJcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XHJcblx0XHRcdFx0dHlwZToga2xhc3MuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrbGFzcy5zbGljZSgxKVxyXG5cdFx0XHR9KSk7XHJcblx0XHR9O1xyXG5cdH1cclxuKTtcblxucmV0dXJuIHNyYztcblxufSkpKTtcbiIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykubnVtYnJvPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGEobyx1LGMpe2Z1bmN0aW9uIHModCxlKXtpZighdVt0XSl7aWYoIW9bdF0pe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWUmJnIpcmV0dXJuIHIodCwhMCk7aWYobClyZXR1cm4gbCh0LCEwKTt2YXIgbj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3QrXCInXCIpO3Rocm93IG4uY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixufXZhciBpPXVbdF09e2V4cG9ydHM6e319O29bdF1bMF0uY2FsbChpLmV4cG9ydHMsZnVuY3Rpb24oZSl7cmV0dXJuIHMob1t0XVsxXVtlXXx8ZSl9LGksaS5leHBvcnRzLGEsbyx1LGMpfXJldHVybiB1W3RdLmV4cG9ydHN9Zm9yKHZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsZT0wO2U8Yy5sZW5ndGg7ZSsrKXMoY1tlXSk7cmV0dXJuIHN9KHsxOltmdW5jdGlvbihlLHIsdCl7IWZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3ZhciB0LFQ9L14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksQz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3IsVT1NYXRoLmNlaWwsUj1NYXRoLmZsb29yLEk9XCJbQmlnTnVtYmVyIEVycm9yXSBcIiwkPUkrXCJOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiBcIixHPTFlMTQsVj0xNCxxPTkwMDcxOTkyNTQ3NDA5OTEsWj1bMSwxMCwxMDAsMWUzLDFlNCwxZTUsMWU2LDFlNywxZTgsMWU5LDFlMTAsMWUxMSwxZTEyLDFlMTNdLHo9MWU3LFc9MWU5O2Z1bmN0aW9uIEgoZSl7dmFyIHQ9MHxlO3JldHVybiAwPGV8fGU9PT10P3Q6dC0xfWZ1bmN0aW9uIFkoZSl7Zm9yKHZhciB0LHIsbj0xLGk9ZS5sZW5ndGgsYT1lWzBdK1wiXCI7bjxpOyl7Zm9yKHQ9ZVtuKytdK1wiXCIscj1WLXQubGVuZ3RoO3ItLTt0PVwiMFwiK3QpO2ErPXR9Zm9yKGk9YS5sZW5ndGg7NDg9PT1hLmNoYXJDb2RlQXQoLS1pKTspO3JldHVybiBhLnNsaWNlKDAsaSsxfHwxKX1mdW5jdGlvbiBLKGUsdCl7dmFyIHIsbixpPWUuYyxhPXQuYyxvPWUucyx1PXQucyxjPWUuZSxzPXQuZTtpZighb3x8IXUpcmV0dXJuIG51bGw7aWYocj1pJiYhaVswXSxuPWEmJiFhWzBdLHJ8fG4pcmV0dXJuIHI/bj8wOi11Om87aWYobyE9dSlyZXR1cm4gbztpZihyPW88MCxuPWM9PXMsIWl8fCFhKXJldHVybiBuPzA6IWlecj8xOi0xO2lmKCFuKXJldHVybiBzPGNecj8xOi0xO2Zvcih1PShjPWkubGVuZ3RoKTwocz1hLmxlbmd0aCk/YzpzLG89MDtvPHU7bysrKWlmKGlbb10hPWFbb10pcmV0dXJuIGlbb10+YVtvXV5yPzE6LTE7cmV0dXJuIGM9PXM/MDpzPGNecj8xOi0xfWZ1bmN0aW9uIEooZSx0LHIsbil7aWYoZTx0fHxyPGV8fGUhPT1SKGUpKXRocm93IEVycm9yKEkrKG58fFwiQXJndW1lbnRcIikrKFwibnVtYmVyXCI9PXR5cGVvZiBlP2U8dHx8cjxlP1wiIG91dCBvZiByYW5nZTogXCI6XCIgbm90IGFuIGludGVnZXI6IFwiOlwiIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6IFwiKStTdHJpbmcoZSkpfWZ1bmN0aW9uIFgoZSl7dmFyIHQ9ZS5jLmxlbmd0aC0xO3JldHVybiBIKGUuZS9WKT09dCYmZS5jW3RdJTIhPTB9ZnVuY3Rpb24gUShlLHQpe3JldHVybigxPGUubGVuZ3RoP2UuY2hhckF0KDApK1wiLlwiK2Uuc2xpY2UoMSk6ZSkrKHQ8MD9cImVcIjpcImUrXCIpK3R9ZnVuY3Rpb24gZWUoZSx0LHIpe3ZhciBuLGk7aWYodDwwKXtmb3IoaT1yK1wiLlwiOysrdDtpKz1yKTtlPWkrZX1lbHNlIGlmKCsrdD4obj1lLmxlbmd0aCkpe2ZvcihpPXIsdC09bjstLXQ7aSs9cik7ZSs9aX1lbHNlIHQ8biYmKGU9ZS5zbGljZSgwLHQpK1wiLlwiK2Uuc2xpY2UodCkpO3JldHVybiBlfSh0PWZ1bmN0aW9uIGUodCl7dmFyIHYsZixnLHIscyxtLG8sdSxjLGwscCxuPUEucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpBLHRvU3RyaW5nOm51bGwsdmFsdWVPZjpudWxsfSxoPW5ldyBBKDEpLHk9MjAsYj00LGQ9LTcsdz0yMSxTPS0xZTcsTz0xZTcseD0hMSxhPTEsTj0wLEI9e3ByZWZpeDpcIlwiLGdyb3VwU2l6ZTozLHNlY29uZGFyeUdyb3VwU2l6ZTowLGdyb3VwU2VwYXJhdG9yOlwiLFwiLGRlY2ltYWxTZXBhcmF0b3I6XCIuXCIsZnJhY3Rpb25Hcm91cFNpemU6MCxmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOlwiwqBcIixzdWZmaXg6XCJcIn0sTT1cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO2Z1bmN0aW9uIEEoZSx0KXt2YXIgcixuLGksYSxvLHUsYyxzLGw9dGhpcztpZighKGwgaW5zdGFuY2VvZiBBKSlyZXR1cm4gbmV3IEEoZSx0KTtpZihudWxsPT10KXtpZihlJiYhMD09PWUuX2lzQmlnTnVtYmVyKXJldHVybiBsLnM9ZS5zLHZvaWQoIWUuY3x8ZS5lPk8/bC5jPWwuZT1udWxsOmUuZTxTP2wuYz1bbC5lPTBdOihsLmU9ZS5lLGwuYz1lLmMuc2xpY2UoKSkpO2lmKCh1PVwibnVtYmVyXCI9PXR5cGVvZiBlKSYmMCplPT0wKXtpZihsLnM9MS9lPDA/KGU9LWUsLTEpOjEsZT09PX5+ZSl7Zm9yKGE9MCxvPWU7MTA8PW87by89MTAsYSsrKTtyZXR1cm4gdm9pZChPPGE/bC5jPWwuZT1udWxsOihsLmU9YSxsLmM9W2VdKSl9cz1TdHJpbmcoZSl9ZWxzZXtpZighVC50ZXN0KHM9U3RyaW5nKGUpKSlyZXR1cm4gZyhsLHMsdSk7bC5zPTQ1PT1zLmNoYXJDb2RlQXQoMCk/KHM9cy5zbGljZSgxKSwtMSk6MX0tMTwoYT1zLmluZGV4T2YoXCIuXCIpKSYmKHM9cy5yZXBsYWNlKFwiLlwiLFwiXCIpKSwwPChvPXMuc2VhcmNoKC9lL2kpKT8oYTwwJiYoYT1vKSxhKz0rcy5zbGljZShvKzEpLHM9cy5zdWJzdHJpbmcoMCxvKSk6YTwwJiYoYT1zLmxlbmd0aCl9ZWxzZXtpZihKKHQsMixNLmxlbmd0aCxcIkJhc2VcIiksMTA9PXQpcmV0dXJuIGoobD1uZXcgQShlKSx5K2wuZSsxLGIpO2lmKHM9U3RyaW5nKGUpLHU9XCJudW1iZXJcIj09dHlwZW9mIGUpe2lmKDAqZSE9MClyZXR1cm4gZyhsLHMsdSx0KTtpZihsLnM9MS9lPDA/KHM9cy5zbGljZSgxKSwtMSk6MSxBLkRFQlVHJiYxNTxzLnJlcGxhY2UoL14wXFwuMCp8XFwuLyxcIlwiKS5sZW5ndGgpdGhyb3cgRXJyb3IoJCtlKX1lbHNlIGwucz00NT09PXMuY2hhckNvZGVBdCgwKT8ocz1zLnNsaWNlKDEpLC0xKToxO2ZvcihyPU0uc2xpY2UoMCx0KSxhPW89MCxjPXMubGVuZ3RoO288YztvKyspaWYoci5pbmRleE9mKG49cy5jaGFyQXQobykpPDApe2lmKFwiLlwiPT1uKXtpZihhPG8pe2E9Yztjb250aW51ZX19ZWxzZSBpZighaSYmKHM9PXMudG9VcHBlckNhc2UoKSYmKHM9cy50b0xvd2VyQ2FzZSgpKXx8cz09cy50b0xvd2VyQ2FzZSgpJiYocz1zLnRvVXBwZXJDYXNlKCkpKSl7aT0hMCxvPS0xLGE9MDtjb250aW51ZX1yZXR1cm4gZyhsLFN0cmluZyhlKSx1LHQpfXU9ITEsLTE8KGE9KHM9ZihzLHQsMTAsbC5zKSkuaW5kZXhPZihcIi5cIikpP3M9cy5yZXBsYWNlKFwiLlwiLFwiXCIpOmE9cy5sZW5ndGh9Zm9yKG89MDs0OD09PXMuY2hhckNvZGVBdChvKTtvKyspO2ZvcihjPXMubGVuZ3RoOzQ4PT09cy5jaGFyQ29kZUF0KC0tYyk7KTtpZihzPXMuc2xpY2UobywrK2MpKXtpZihjLT1vLHUmJkEuREVCVUcmJjE1PGMmJihxPGV8fGUhPT1SKGUpKSl0aHJvdyBFcnJvcigkK2wucyplKTtpZigoYT1hLW8tMSk+TylsLmM9bC5lPW51bGw7ZWxzZSBpZihhPFMpbC5jPVtsLmU9MF07ZWxzZXtpZihsLmU9YSxsLmM9W10sbz0oYSsxKSVWLGE8MCYmKG8rPVYpLG88Yyl7Zm9yKG8mJmwuYy5wdXNoKCtzLnNsaWNlKDAsbykpLGMtPVY7bzxjOylsLmMucHVzaCgrcy5zbGljZShvLG8rPVYpKTtvPVYtKHM9cy5zbGljZShvKSkubGVuZ3RofWVsc2Ugby09Yztmb3IoO28tLTtzKz1cIjBcIik7bC5jLnB1c2goK3MpfX1lbHNlIGwuYz1bbC5lPTBdfWZ1bmN0aW9uIEQoZSx0LHIsbil7Zm9yKHZhciBpLGEsbz1bMF0sdT0wLGM9ZS5sZW5ndGg7dTxjOyl7Zm9yKGE9by5sZW5ndGg7YS0tO29bYV0qPXQpO2ZvcihvWzBdKz1uLmluZGV4T2YoZS5jaGFyQXQodSsrKSksaT0wO2k8by5sZW5ndGg7aSsrKW9baV0+ci0xJiYobnVsbD09b1tpKzFdJiYob1tpKzFdPTApLG9baSsxXSs9b1tpXS9yfDAsb1tpXSU9cil9cmV0dXJuIG8ucmV2ZXJzZSgpfWZ1bmN0aW9uIEUoZSx0LHIpe3ZhciBuLGksYSxvLHU9MCxjPWUubGVuZ3RoLHM9dCV6LGw9dC96fDA7Zm9yKGU9ZS5zbGljZSgpO2MtLTspdT0oKGk9cyooYT1lW2NdJXopKyhuPWwqYSsobz1lW2NdL3p8MCkqcykleip6K3UpL3J8MCkrKG4venwwKStsKm8sZVtjXT1pJXI7cmV0dXJuIHUmJihlPVt1XS5jb25jYXQoZSkpLGV9ZnVuY3Rpb24gRihlLHQscixuKXt2YXIgaSxhO2lmKHIhPW4pYT1uPHI/MTotMTtlbHNlIGZvcihpPWE9MDtpPHI7aSsrKWlmKGVbaV0hPXRbaV0pe2E9ZVtpXT50W2ldPzE6LTE7YnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gayhlLHQscixuKXtmb3IodmFyIGk9MDtyLS07KWVbcl0tPWksaT1lW3JdPHRbcl0/MTowLGVbcl09aSpuK2Vbcl0tdFtyXTtmb3IoOyFlWzBdJiYxPGUubGVuZ3RoO2Uuc3BsaWNlKDAsMSkpO31mdW5jdGlvbiBpKGUsdCxyLG4pe3ZhciBpLGEsbyx1LGM7aWYobnVsbD09cj9yPWI6SihyLDAsOCksIWUuYylyZXR1cm4gZS50b1N0cmluZygpO2lmKGk9ZS5jWzBdLG89ZS5lLG51bGw9PXQpYz1ZKGUuYyksYz0xPT1ufHwyPT1uJiYobzw9ZHx8dzw9byk/UShjLG8pOmVlKGMsbyxcIjBcIik7ZWxzZSBpZihhPShlPWoobmV3IEEoZSksdCxyKSkuZSx1PShjPVkoZS5jKSkubGVuZ3RoLDE9PW58fDI9PW4mJih0PD1hfHxhPD1kKSl7Zm9yKDt1PHQ7Yys9XCIwXCIsdSsrKTtjPVEoYyxhKX1lbHNlIGlmKHQtPW8sYz1lZShjLGEsXCIwXCIpLHU8YSsxKXtpZigwPC0tdClmb3IoYys9XCIuXCI7dC0tO2MrPVwiMFwiKTt9ZWxzZSBpZigwPCh0Kz1hLXUpKWZvcihhKzE9PXUmJihjKz1cIi5cIik7dC0tO2MrPVwiMFwiKTtyZXR1cm4gZS5zPDAmJmk/XCItXCIrYzpjfWZ1bmN0aW9uIF8oZSx0KXtmb3IodmFyIHIsbj0xLGk9bmV3IEEoZVswXSk7bjxlLmxlbmd0aDtuKyspe2lmKCEocj1uZXcgQShlW25dKSkucyl7aT1yO2JyZWFrfXQuY2FsbChpLHIpJiYoaT1yKX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCxyKXtmb3IodmFyIG49MSxpPXQubGVuZ3RoOyF0Wy0taV07dC5wb3AoKSk7Zm9yKGk9dFswXTsxMDw9aTtpLz0xMCxuKyspO3JldHVybihyPW4rcipWLTEpPk8/ZS5jPWUuZT1udWxsOnI8Uz9lLmM9W2UuZT0wXTooZS5lPXIsZS5jPXQpLGV9ZnVuY3Rpb24gaihlLHQscixuKXt2YXIgaSxhLG8sdSxjLHMsbCxmPWUuYyxnPVo7aWYoZil7ZTp7Zm9yKGk9MSx1PWZbMF07MTA8PXU7dS89MTAsaSsrKTtpZigoYT10LWkpPDApYSs9VixvPXQsbD0oYz1mW3M9MF0pL2dbaS1vLTFdJTEwfDA7ZWxzZSBpZigocz1VKChhKzEpL1YpKT49Zi5sZW5ndGgpe2lmKCFuKWJyZWFrIGU7Zm9yKDtmLmxlbmd0aDw9cztmLnB1c2goMCkpO2M9bD0wLG89KGElPVYpLVYrKGk9MSl9ZWxzZXtmb3IoYz11PWZbc10saT0xOzEwPD11O3UvPTEwLGkrKyk7bD0obz0oYSU9ViktVitpKTwwPzA6Yy9nW2ktby0xXSUxMHwwfWlmKG49bnx8dDwwfHxudWxsIT1mW3MrMV18fChvPDA/YzpjJWdbaS1vLTFdKSxuPXI8ND8obHx8bikmJigwPT1yfHxyPT0oZS5zPDA/MzoyKSk6NTxsfHw1PT1sJiYoND09cnx8bnx8Nj09ciYmKDA8YT8wPG8/Yy9nW2ktb106MDpmW3MtMV0pJTEwJjF8fHI9PShlLnM8MD84OjcpKSx0PDF8fCFmWzBdKXJldHVybiBmLmxlbmd0aD0wLG4/KHQtPWUuZSsxLGZbMF09Z1soVi10JVYpJVZdLGUuZT0tdHx8MCk6ZlswXT1lLmU9MCxlO2lmKDA9PWE/KGYubGVuZ3RoPXMsdT0xLHMtLSk6KGYubGVuZ3RoPXMrMSx1PWdbVi1hXSxmW3NdPTA8bz9SKGMvZ1tpLW9dJWdbb10pKnU6MCksbilmb3IoOzspe2lmKDA9PXMpe2ZvcihhPTEsbz1mWzBdOzEwPD1vO28vPTEwLGErKyk7Zm9yKG89ZlswXSs9dSx1PTE7MTA8PW87by89MTAsdSsrKTthIT11JiYoZS5lKyssZlswXT09RyYmKGZbMF09MSkpO2JyZWFrfWlmKGZbc10rPXUsZltzXSE9RylicmVhaztmW3MtLV09MCx1PTF9Zm9yKGE9Zi5sZW5ndGg7MD09PWZbLS1hXTtmLnBvcCgpKTt9ZS5lPk8/ZS5jPWUuZT1udWxsOmUuZTxTJiYoZS5jPVtlLmU9MF0pfXJldHVybiBlfWZ1bmN0aW9uIFAoZSl7dmFyIHQscj1lLmU7cmV0dXJuIG51bGw9PT1yP2UudG9TdHJpbmcoKToodD1ZKGUuYyksdD1yPD1kfHx3PD1yP1EodCxyKTplZSh0LHIsXCIwXCIpLGUuczwwP1wiLVwiK3Q6dCl9cmV0dXJuIEEuY2xvbmU9ZSxBLlJPVU5EX1VQPTAsQS5ST1VORF9ET1dOPTEsQS5ST1VORF9DRUlMPTIsQS5ST1VORF9GTE9PUj0zLEEuUk9VTkRfSEFMRl9VUD00LEEuUk9VTkRfSEFMRl9ET1dOPTUsQS5ST1VORF9IQUxGX0VWRU49NixBLlJPVU5EX0hBTEZfQ0VJTD03LEEuUk9VTkRfSEFMRl9GTE9PUj04LEEuRVVDTElEPTksQS5jb25maWc9QS5zZXQ9ZnVuY3Rpb24oZSl7dmFyIHQscjtpZihudWxsIT1lKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBFcnJvcihJK1wiT2JqZWN0IGV4cGVjdGVkOiBcIitlKTtpZihlLmhhc093blByb3BlcnR5KHQ9XCJERUNJTUFMX1BMQUNFU1wiKSYmKEoocj1lW3RdLDAsVyx0KSx5PXIpLGUuaGFzT3duUHJvcGVydHkodD1cIlJPVU5ESU5HX01PREVcIikmJihKKHI9ZVt0XSwwLDgsdCksYj1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJFWFBPTkVOVElBTF9BVFwiKSYmKChyPWVbdF0pJiZyLnBvcD8oSihyWzBdLC1XLDAsdCksSihyWzFdLDAsVyx0KSxkPXJbMF0sdz1yWzFdKTooSihyLC1XLFcsdCksZD0tKHc9cjwwPy1yOnIpKSksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiUkFOR0VcIikpaWYoKHI9ZVt0XSkmJnIucG9wKUooclswXSwtVywtMSx0KSxKKHJbMV0sMSxXLHQpLFM9clswXSxPPXJbMV07ZWxzZXtpZihKKHIsLVcsVyx0KSwhcil0aHJvdyBFcnJvcihJK3QrXCIgY2Fubm90IGJlIHplcm86IFwiK3IpO1M9LShPPXI8MD8tcjpyKX1pZihlLmhhc093blByb3BlcnR5KHQ9XCJDUllQVE9cIikpe2lmKChyPWVbdF0pIT09ISFyKXRocm93IEVycm9yKEkrdCtcIiBub3QgdHJ1ZSBvciBmYWxzZTogXCIrcik7aWYocil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNyeXB0b3x8IWNyeXB0b3x8IWNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJiFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgeD0hcixFcnJvcihJK1wiY3J5cHRvIHVuYXZhaWxhYmxlXCIpO3g9cn1lbHNlIHg9cn1pZihlLmhhc093blByb3BlcnR5KHQ9XCJNT0RVTE9fTU9ERVwiKSYmKEoocj1lW3RdLDAsOSx0KSxhPXIpLGUuaGFzT3duUHJvcGVydHkodD1cIlBPV19QUkVDSVNJT05cIikmJihKKHI9ZVt0XSwwLFcsdCksTj1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJGT1JNQVRcIikpe2lmKFwib2JqZWN0XCIhPXR5cGVvZihyPWVbdF0pKXRocm93IEVycm9yKEkrdCtcIiBub3QgYW4gb2JqZWN0OiBcIityKTtCPXJ9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiQUxQSEFCRVRcIikpe2lmKFwic3RyaW5nXCIhPXR5cGVvZihyPWVbdF0pfHwvXi4kfFsrLS5cXHNdfCguKS4qXFwxLy50ZXN0KHIpKXRocm93IEVycm9yKEkrdCtcIiBpbnZhbGlkOiBcIityKTtNPXJ9fXJldHVybntERUNJTUFMX1BMQUNFUzp5LFJPVU5ESU5HX01PREU6YixFWFBPTkVOVElBTF9BVDpbZCx3XSxSQU5HRTpbUyxPXSxDUllQVE86eCxNT0RVTE9fTU9ERTphLFBPV19QUkVDSVNJT046TixGT1JNQVQ6QixBTFBIQUJFVDpNfX0sQS5pc0JpZ051bWJlcj1mdW5jdGlvbihlKXtpZighZXx8ITAhPT1lLl9pc0JpZ051bWJlcilyZXR1cm4hMTtpZighQS5ERUJVRylyZXR1cm4hMDt2YXIgdCxyLG49ZS5jLGk9ZS5lLGE9ZS5zO2U6aWYoXCJbb2JqZWN0IEFycmF5XVwiPT17fS50b1N0cmluZy5jYWxsKG4pKXtpZigoMT09PWF8fC0xPT09YSkmJi1XPD1pJiZpPD1XJiZpPT09UihpKSl7aWYoMD09PW5bMF0pe2lmKDA9PT1pJiYxPT09bi5sZW5ndGgpcmV0dXJuITA7YnJlYWsgZX1pZigodD0oaSsxKSVWKTwxJiYodCs9ViksU3RyaW5nKG5bMF0pLmxlbmd0aD09dCl7Zm9yKHQ9MDt0PG4ubGVuZ3RoO3QrKylpZigocj1uW3RdKTwwfHxHPD1yfHxyIT09UihyKSlicmVhayBlO2lmKDAhPT1yKXJldHVybiEwfX19ZWxzZSBpZihudWxsPT09biYmbnVsbD09PWkmJihudWxsPT09YXx8MT09PWF8fC0xPT09YSkpcmV0dXJuITA7dGhyb3cgRXJyb3IoSStcIkludmFsaWQgQmlnTnVtYmVyOiBcIitlKX0sQS5tYXhpbXVtPUEubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIF8oYXJndW1lbnRzLG4ubHQpfSxBLm1pbmltdW09QS5taW49ZnVuY3Rpb24oKXtyZXR1cm4gXyhhcmd1bWVudHMsbi5ndCl9LEEucmFuZG9tPShyPTkwMDcxOTkyNTQ3NDA5OTIscz1NYXRoLnJhbmRvbSgpKnImMjA5NzE1MT9mdW5jdGlvbigpe3JldHVybiBSKE1hdGgucmFuZG9tKCkqcil9OmZ1bmN0aW9uKCl7cmV0dXJuIDgzODg2MDgqKDEwNzM3NDE4MjQqTWF0aC5yYW5kb20oKXwwKSsoODM4ODYwOCpNYXRoLnJhbmRvbSgpfDApfSxmdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG89MCx1PVtdLGM9bmV3IEEoaCk7aWYobnVsbD09ZT9lPXk6SihlLDAsVyksaT1VKGUvVikseClpZihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXtmb3IodD1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShpKj0yKSk7bzxpOyk5ZTE1PD0oYT0xMzEwNzIqdFtvXSsodFtvKzFdPj4+MTEpKT8ocj1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSksdFtvXT1yWzBdLHRbbysxXT1yWzFdKToodS5wdXNoKGElMWUxNCksbys9Mik7bz1pLzJ9ZWxzZXtpZighY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IHg9ITEsRXJyb3IoSStcImNyeXB0byB1bmF2YWlsYWJsZVwiKTtmb3IodD1jcnlwdG8ucmFuZG9tQnl0ZXMoaSo9Nyk7bzxpOyk5ZTE1PD0oYT0yODE0NzQ5NzY3MTA2NTYqKDMxJnRbb10pKzEwOTk1MTE2Mjc3NzYqdFtvKzFdKzQyOTQ5NjcyOTYqdFtvKzJdKzE2Nzc3MjE2KnRbbyszXSsodFtvKzRdPDwxNikrKHRbbys1XTw8OCkrdFtvKzZdKT9jcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSh0LG8pOih1LnB1c2goYSUxZTE0KSxvKz03KTtvPWkvN31pZigheClmb3IoO288aTspKGE9cygpKTw5ZTE1JiYodVtvKytdPWElMWUxNCk7Zm9yKGk9dVstLW9dLGUlPVYsaSYmZSYmKGE9WltWLWVdLHVbb109UihpL2EpKmEpOzA9PT11W29dO3UucG9wKCksby0tKTtpZihvPDApdT1bbj0wXTtlbHNle2ZvcihuPS0xOzA9PT11WzBdO3Uuc3BsaWNlKDAsMSksbi09Vik7Zm9yKG89MSxhPXVbMF07MTA8PWE7YS89MTAsbysrKTtvPFYmJihuLT1WLW8pfXJldHVybiBjLmU9bixjLmM9dSxjfSksQS5zdW09ZnVuY3Rpb24oKXtmb3IodmFyIGU9MSx0PWFyZ3VtZW50cyxyPW5ldyBBKHRbMF0pO2U8dC5sZW5ndGg7KXI9ci5wbHVzKHRbZSsrXSk7cmV0dXJuIHJ9LG09XCIwMTIzNDU2Nzg5XCIsZj1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBhLG8sdSxjLHMsbCxmLGcscD1lLmluZGV4T2YoXCIuXCIpLGQ9eSxoPWI7Zm9yKDA8PXAmJihjPU4sTj0wLGU9ZS5yZXBsYWNlKFwiLlwiLFwiXCIpLGw9KGc9bmV3IEEodCkpLnBvdyhlLmxlbmd0aC1wKSxOPWMsZy5jPUQoZWUoWShsLmMpLGwuZSxcIjBcIiksMTAscixtKSxnLmU9Zy5jLmxlbmd0aCksdT1jPShmPUQoZSx0LHIsaT8oYT1NLG0pOihhPW0sTSkpKS5sZW5ndGg7MD09ZlstLWNdO2YucG9wKCkpO2lmKCFmWzBdKXJldHVybiBhLmNoYXJBdCgwKTtpZihwPDA/LS11OihsLmM9ZixsLmU9dSxsLnM9bixmPShsPXYobCxnLGQsaCxyKSkuYyxzPWwucix1PWwuZSkscD1mW289dStkKzFdLGM9ci8yLHM9c3x8bzwwfHxudWxsIT1mW28rMV0scz1oPDQ/KG51bGwhPXB8fHMpJiYoMD09aHx8aD09KGwuczwwPzM6MikpOmM8cHx8cD09YyYmKDQ9PWh8fHN8fDY9PWgmJjEmZltvLTFdfHxoPT0obC5zPDA/ODo3KSksbzwxfHwhZlswXSllPXM/ZWUoYS5jaGFyQXQoMSksLWQsYS5jaGFyQXQoMCkpOmEuY2hhckF0KDApO2Vsc2V7aWYoZi5sZW5ndGg9byxzKWZvcigtLXI7KytmWy0tb10+cjspZltvXT0wLG98fCgrK3UsZj1bMV0uY29uY2F0KGYpKTtmb3IoYz1mLmxlbmd0aDshZlstLWNdOyk7Zm9yKHA9MCxlPVwiXCI7cDw9YztlKz1hLmNoYXJBdChmW3ArK10pKTtlPWVlKGUsdSxhLmNoYXJBdCgwKSl9cmV0dXJuIGV9LHY9ZnVuY3Rpb24oZSx0LHIsbixpKXt2YXIgYSxvLHUsYyxzLGwsZixnLHAsZCxoLHYsbSx5LGIsdyxTLE89ZS5zPT10LnM/MTotMSx4PWUuYyxOPXQuYztpZighKHgmJnhbMF0mJk4mJk5bMF0pKXJldHVybiBuZXcgQShlLnMmJnQucyYmKHg/IU58fHhbMF0hPU5bMF06Tik/eCYmMD09eFswXXx8IU4/MCpPOk8vMDpOYU4pO2ZvcihwPShnPW5ldyBBKE8pKS5jPVtdLE89cisobz1lLmUtdC5lKSsxLGl8fChpPUcsbz1IKGUuZS9WKS1IKHQuZS9WKSxPPU8vVnwwKSx1PTA7Tlt1XT09KHhbdV18fDApO3UrKyk7aWYoTlt1XT4oeFt1XXx8MCkmJm8tLSxPPDApcC5wdXNoKDEpLGM9ITA7ZWxzZXtmb3IoeT14Lmxlbmd0aCx3PU4ubGVuZ3RoLE8rPTIsMTwocz1SKGkvKE5bdT0wXSsxKSkpJiYoTj1FKE4scyxpKSx4PUUoeCxzLGkpLHc9Ti5sZW5ndGgseT14Lmxlbmd0aCksbT13LGg9KGQ9eC5zbGljZSgwLHcpKS5sZW5ndGg7aDx3O2RbaCsrXT0wKTtTPU4uc2xpY2UoKSxTPVswXS5jb25jYXQoUyksYj1OWzBdLE5bMV0+PWkvMiYmYisrO2Rve2lmKHM9MCwoYT1GKE4sZCx3LGgpKTwwKXtpZih2PWRbMF0sdyE9aCYmKHY9dippKyhkWzFdfHwwKSksMTwocz1SKHYvYikpKWZvcihpPD1zJiYocz1pLTEpLGY9KGw9RShOLHMsaSkpLmxlbmd0aCxoPWQubGVuZ3RoOzE9PUYobCxkLGYsaCk7KXMtLSxrKGwsdzxmP1M6TixmLGkpLGY9bC5sZW5ndGgsYT0xO2Vsc2UgMD09cyYmKGE9cz0xKSxmPShsPU4uc2xpY2UoKSkubGVuZ3RoO2lmKGY8aCYmKGw9WzBdLmNvbmNhdChsKSksayhkLGwsaCxpKSxoPWQubGVuZ3RoLC0xPT1hKWZvcig7RihOLGQsdyxoKTwxOylzKyssayhkLHc8aD9TOk4saCxpKSxoPWQubGVuZ3RofWVsc2UgMD09PWEmJihzKyssZD1bMF0pO3BbdSsrXT1zLGRbMF0/ZFtoKytdPXhbbV18fDA6KGQ9W3hbbV1dLGg9MSl9d2hpbGUoKG0rKzx5fHxudWxsIT1kWzBdKSYmTy0tKTtjPW51bGwhPWRbMF0scFswXXx8cC5zcGxpY2UoMCwxKX1pZihpPT1HKXtmb3IodT0xLE89cFswXTsxMDw9TztPLz0xMCx1KyspO2ooZyxyKyhnLmU9dStvKlYtMSkrMSxuLGMpfWVsc2UgZy5lPW8sZy5yPStjO3JldHVybiBnfSxvPS9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksdT0vXihbXi5dKylcXC4kLyxjPS9eXFwuKFteLl0rKSQvLGw9L14tPyhJbmZpbml0eXxOYU4pJC8scD0vXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2csZz1mdW5jdGlvbihlLHQscixuKXt2YXIgaSxhPXI/dDp0LnJlcGxhY2UocCxcIlwiKTtpZihsLnRlc3QoYSkpZS5zPWlzTmFOKGEpP251bGw6YTwwPy0xOjE7ZWxzZXtpZighciYmKGE9YS5yZXBsYWNlKG8sZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpPVwieFwiPT0ocj1yLnRvTG93ZXJDYXNlKCkpPzE2OlwiYlwiPT1yPzI6OCxuJiZuIT1pP2U6dH0pLG4mJihpPW4sYT1hLnJlcGxhY2UodSxcIiQxXCIpLnJlcGxhY2UoYyxcIjAuJDFcIikpLHQhPWEpKXJldHVybiBuZXcgQShhLGkpO2lmKEEuREVCVUcpdGhyb3cgRXJyb3IoSStcIk5vdCBhXCIrKG4/XCIgYmFzZSBcIituOlwiXCIpK1wiIG51bWJlcjogXCIrdCk7ZS5zPW51bGx9ZS5jPWUuZT1udWxsfSxuLmFic29sdXRlVmFsdWU9bi5hYnM9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgQSh0aGlzKTtyZXR1cm4gZS5zPDAmJihlLnM9MSksZX0sbi5jb21wYXJlZFRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEsodGhpcyxuZXcgQShlLHQpKX0sbi5kZWNpbWFsUGxhY2VzPW4uZHA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk7aWYobnVsbCE9ZSlyZXR1cm4gSihlLDAsVyksbnVsbD09dD90PWI6Sih0LDAsOCksaihuZXcgQSh0aGlzKSxlK3RoaXMuZSsxLHQpO2lmKCEocj10aGlzLmMpKXJldHVybiBudWxsO2lmKG49KChpPXIubGVuZ3RoLTEpLUgodGhpcy5lL1YpKSpWLGk9cltpXSlmb3IoO2klMTA9PTA7aS89MTAsbi0tKTtyZXR1cm4gbjwwJiYobj0wKSxufSxuLmRpdmlkZWRCeT1uLmRpdj1mdW5jdGlvbihlLHQpe3JldHVybiB2KHRoaXMsbmV3IEEoZSx0KSx5LGIpfSxuLmRpdmlkZWRUb0ludGVnZXJCeT1uLmlkaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdih0aGlzLG5ldyBBKGUsdCksMCwxKX0sbi5leHBvbmVudGlhdGVkQnk9bi5wb3c9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSxvLHUsYyxzLGw9dGhpcztpZigoZT1uZXcgQShlKSkuYyYmIWUuaXNJbnRlZ2VyKCkpdGhyb3cgRXJyb3IoSStcIkV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiBcIitQKGUpKTtpZihudWxsIT10JiYodD1uZXcgQSh0KSksbz0xNDxlLmUsIWwuY3x8IWwuY1swXXx8MT09bC5jWzBdJiYhbC5lJiYxPT1sLmMubGVuZ3RofHwhZS5jfHwhZS5jWzBdKXJldHVybiBzPW5ldyBBKE1hdGgucG93KCtQKGwpLG8/Mi1YKGUpOitQKGUpKSksdD9zLm1vZCh0KTpzO2lmKHU9ZS5zPDAsdCl7aWYodC5jPyF0LmNbMF06IXQucylyZXR1cm4gbmV3IEEoTmFOKTsobj0hdSYmbC5pc0ludGVnZXIoKSYmdC5pc0ludGVnZXIoKSkmJihsPWwubW9kKHQpKX1lbHNle2lmKDk8ZS5lJiYoMDxsLmV8fGwuZTwtMXx8KDA9PWwuZT8xPGwuY1swXXx8byYmMjRlNzw9bC5jWzFdOmwuY1swXTw4ZTEzfHxvJiZsLmNbMF08PTk5OTk5NzVlNykpKXJldHVybiBhPWwuczwwJiZYKGUpPy0wOjAsLTE8bC5lJiYoYT0xL2EpLG5ldyBBKHU/MS9hOmEpO04mJihhPVUoTi9WKzIpKX1mb3IoYz1vPyhyPW5ldyBBKC41KSx1JiYoZS5zPTEpLFgoZSkpOihpPU1hdGguYWJzKCtQKGUpKSklMixzPW5ldyBBKGgpOzspe2lmKGMpe2lmKCEocz1zLnRpbWVzKGwpKS5jKWJyZWFrO2E/cy5jLmxlbmd0aD5hJiYocy5jLmxlbmd0aD1hKTpuJiYocz1zLm1vZCh0KSl9aWYoaSl7aWYoMD09PShpPVIoaS8yKSkpYnJlYWs7Yz1pJTJ9ZWxzZSBpZihqKGU9ZS50aW1lcyhyKSxlLmUrMSwxKSwxNDxlLmUpYz1YKGUpO2Vsc2V7aWYoMD09KGk9K1AoZSkpKWJyZWFrO2M9aSUyfWw9bC50aW1lcyhsKSxhP2wuYyYmbC5jLmxlbmd0aD5hJiYobC5jLmxlbmd0aD1hKTpuJiYobD1sLm1vZCh0KSl9cmV0dXJuIG4/czoodSYmKHM9aC5kaXYocykpLHQ/cy5tb2QodCk6YT9qKHMsTixiLHZvaWQgMCk6cyl9LG4uaW50ZWdlclZhbHVlPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBKHRoaXMpO3JldHVybiBudWxsPT1lP2U9YjpKKGUsMCw4KSxqKHQsdC5lKzEsZSl9LG4uaXNFcXVhbFRvPW4uZXE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PUsodGhpcyxuZXcgQShlLHQpKX0sbi5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jfSxuLmlzR3JlYXRlclRoYW49bi5ndD1mdW5jdGlvbihlLHQpe3JldHVybiAwPEsodGhpcyxuZXcgQShlLHQpKX0sbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvPW4uZ3RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT0odD1LKHRoaXMsbmV3IEEoZSx0KSkpfHwwPT09dH0sbi5pc0ludGVnZXI9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmSCh0aGlzLmUvVik+dGhpcy5jLmxlbmd0aC0yfSxuLmlzTGVzc1RoYW49bi5sdD1mdW5jdGlvbihlLHQpe3JldHVybiBLKHRoaXMsbmV3IEEoZSx0KSk8MH0sbi5pc0xlc3NUaGFuT3JFcXVhbFRvPW4ubHRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT0odD1LKHRoaXMsbmV3IEEoZSx0KSkpfHwwPT09dH0sbi5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LG4uaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MH0sbi5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5zfSxuLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiYwPT10aGlzLmNbMF19LG4ubWludXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSxvPXRoaXMsdT1vLnM7aWYodD0oZT1uZXcgQShlLHQpKS5zLCF1fHwhdClyZXR1cm4gbmV3IEEoTmFOKTtpZih1IT10KXJldHVybiBlLnM9LXQsby5wbHVzKGUpO3ZhciBjPW8uZS9WLHM9ZS5lL1YsbD1vLmMsZj1lLmM7aWYoIWN8fCFzKXtpZighbHx8IWYpcmV0dXJuIGw/KGUucz0tdCxlKTpuZXcgQShmP286TmFOKTtpZighbFswXXx8IWZbMF0pcmV0dXJuIGZbMF0/KGUucz0tdCxlKTpuZXcgQShsWzBdP286Mz09Yj8tMDowKX1pZihjPUgoYykscz1IKHMpLGw9bC5zbGljZSgpLHU9Yy1zKXtmb3IoKGk9KGE9dTwwKT8odT0tdSxsKToocz1jLGYpKS5yZXZlcnNlKCksdD11O3QtLTtpLnB1c2goMCkpO2kucmV2ZXJzZSgpfWVsc2UgZm9yKG49KGE9KHU9bC5sZW5ndGgpPCh0PWYubGVuZ3RoKSk/dTp0LHU9dD0wO3Q8bjt0KyspaWYobFt0XSE9Zlt0XSl7YT1sW3RdPGZbdF07YnJlYWt9aWYoYSYmKGk9bCxsPWYsZj1pLGUucz0tZS5zKSwwPCh0PShuPWYubGVuZ3RoKS0ocj1sLmxlbmd0aCkpKWZvcig7dC0tO2xbcisrXT0wKTtmb3IodD1HLTE7dTxuOyl7aWYobFstLW5dPGZbbl0pe2ZvcihyPW47ciYmIWxbLS1yXTtsW3JdPXQpOy0tbFtyXSxsW25dKz1HfWxbbl0tPWZbbl19Zm9yKDswPT1sWzBdO2wuc3BsaWNlKDAsMSksLS1zKTtyZXR1cm4gbFswXT9MKGUsbCxzKTooZS5zPTM9PWI/LTE6MSxlLmM9W2UuZT0wXSxlKX0sbi5tb2R1bG89bi5tb2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9dGhpcztyZXR1cm4gZT1uZXcgQShlLHQpLCFpLmN8fCFlLnN8fGUuYyYmIWUuY1swXT9uZXcgQShOYU4pOiFlLmN8fGkuYyYmIWkuY1swXT9uZXcgQShpKTooOT09YT8obj1lLnMsZS5zPTEscj12KGksZSwwLDMpLGUucz1uLHIucyo9bik6cj12KGksZSwwLGEpLChlPWkubWludXMoci50aW1lcyhlKSkpLmNbMF18fDEhPWF8fChlLnM9aS5zKSxlKX0sbi5tdWx0aXBsaWVkQnk9bi50aW1lcz1mdW5jdGlvbihlLHQpe3ZhciByLG4saSxhLG8sdSxjLHMsbCxmLGcscCxkLGgsdixtPXRoaXMseT1tLmMsYj0oZT1uZXcgQShlLHQpKS5jO2lmKCEoeSYmYiYmeVswXSYmYlswXSkpcmV0dXJuIW0uc3x8IWUuc3x8eSYmIXlbMF0mJiFifHxiJiYhYlswXSYmIXk/ZS5jPWUuZT1lLnM9bnVsbDooZS5zKj1tLnMseSYmYj8oZS5jPVswXSxlLmU9MCk6ZS5jPWUuZT1udWxsKSxlO2ZvcihuPUgobS5lL1YpK0goZS5lL1YpLGUucyo9bS5zLChjPXkubGVuZ3RoKTwoZj1iLmxlbmd0aCkmJihkPXkseT1iLGI9ZCxpPWMsYz1mLGY9aSksaT1jK2YsZD1bXTtpLS07ZC5wdXNoKDApKTtmb3IoaD1HLHY9eixpPWY7MDw9LS1pOyl7Zm9yKHI9MCxnPWJbaV0ldixwPWJbaV0vdnwwLGE9aSsobz1jKTtpPGE7KXI9KChzPWcqKHM9eVstLW9dJXYpKyh1PXAqcysobD15W29dL3Z8MCkqZykldip2K2RbYV0rcikvaHwwKSsodS92fDApK3AqbCxkW2EtLV09cyVoO2RbYV09cn1yZXR1cm4gcj8rK246ZC5zcGxpY2UoMCwxKSxMKGUsZCxuKX0sbi5uZWdhdGVkPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IEEodGhpcyk7cmV0dXJuIGUucz0tZS5zfHxudWxsLGV9LG4ucGx1cz1mdW5jdGlvbihlLHQpe3ZhciByLG49dGhpcyxpPW4ucztpZih0PShlPW5ldyBBKGUsdCkpLnMsIWl8fCF0KXJldHVybiBuZXcgQShOYU4pO2lmKGkhPXQpcmV0dXJuIGUucz0tdCxuLm1pbnVzKGUpO3ZhciBhPW4uZS9WLG89ZS5lL1YsdT1uLmMsYz1lLmM7aWYoIWF8fCFvKXtpZighdXx8IWMpcmV0dXJuIG5ldyBBKGkvMCk7aWYoIXVbMF18fCFjWzBdKXJldHVybiBjWzBdP2U6bmV3IEEodVswXT9uOjAqaSl9aWYoYT1IKGEpLG89SChvKSx1PXUuc2xpY2UoKSxpPWEtbyl7Zm9yKChyPTA8aT8obz1hLGMpOihpPS1pLHUpKS5yZXZlcnNlKCk7aS0tO3IucHVzaCgwKSk7ci5yZXZlcnNlKCl9Zm9yKChpPXUubGVuZ3RoKS0odD1jLmxlbmd0aCk8MCYmKHI9YyxjPXUsdT1yLHQ9aSksaT0wO3Q7KWk9KHVbLS10XT11W3RdK2NbdF0raSkvR3wwLHVbdF09Rz09PXVbdF0/MDp1W3RdJUc7cmV0dXJuIGkmJih1PVtpXS5jb25jYXQodSksKytvKSxMKGUsdSxvKX0sbi5wcmVjaXNpb249bi5zZD1mdW5jdGlvbihlLHQpe3ZhciByLG4saTtpZihudWxsIT1lJiZlIT09ISFlKXJldHVybiBKKGUsMSxXKSxudWxsPT10P3Q9YjpKKHQsMCw4KSxqKG5ldyBBKHRoaXMpLGUsdCk7aWYoIShyPXRoaXMuYykpcmV0dXJuIG51bGw7aWYobj0oaT1yLmxlbmd0aC0xKSpWKzEsaT1yW2ldKXtmb3IoO2klMTA9PTA7aS89MTAsbi0tKTtmb3IoaT1yWzBdOzEwPD1pO2kvPTEwLG4rKyk7fXJldHVybiBlJiZ0aGlzLmUrMT5uJiYobj10aGlzLmUrMSksbn0sbi5zaGlmdGVkQnk9ZnVuY3Rpb24oZSl7cmV0dXJuIEooZSwtcSxxKSx0aGlzLnRpbWVzKFwiMWVcIitlKX0sbi5zcXVhcmVSb290PW4uc3FydD1mdW5jdGlvbigpe3ZhciBlLHQscixuLGksYT10aGlzLG89YS5jLHU9YS5zLGM9YS5lLHM9eSs0LGw9bmV3IEEoXCIwLjVcIik7aWYoMSE9PXV8fCFvfHwhb1swXSlyZXR1cm4gbmV3IEEoIXV8fHU8MCYmKCFvfHxvWzBdKT9OYU46bz9hOjEvMCk7aWYoKHI9MD09KHU9TWF0aC5zcXJ0KCtQKGEpKSl8fHU9PTEvMD8oKCh0PVkobykpLmxlbmd0aCtjKSUyPT0wJiYodCs9XCIwXCIpLHU9TWF0aC5zcXJ0KCt0KSxjPUgoKGMrMSkvMiktKGM8MHx8YyUyKSxuZXcgQSh0PXU9PTEvMD9cIjFlXCIrYzoodD11LnRvRXhwb25lbnRpYWwoKSkuc2xpY2UoMCx0LmluZGV4T2YoXCJlXCIpKzEpK2MpKTpuZXcgQSh1K1wiXCIpKS5jWzBdKWZvcigodT0oYz1yLmUpK3MpPDMmJih1PTApOzspaWYoaT1yLHI9bC50aW1lcyhpLnBsdXModihhLGkscywxKSkpLFkoaS5jKS5zbGljZSgwLHUpPT09KHQ9WShyLmMpKS5zbGljZSgwLHUpKXtpZihyLmU8YyYmLS11LFwiOTk5OVwiIT0odD10LnNsaWNlKHUtMyx1KzEpKSYmKG58fFwiNDk5OVwiIT10KSl7K3QmJigrdC5zbGljZSgxKXx8XCI1XCIhPXQuY2hhckF0KDApKXx8KGoocixyLmUreSsyLDEpLGU9IXIudGltZXMocikuZXEoYSkpO2JyZWFrfWlmKCFuJiYoaihpLGkuZSt5KzIsMCksaS50aW1lcyhpKS5lcShhKSkpe3I9aTticmVha31zKz00LHUrPTQsbj0xfXJldHVybiBqKHIsci5lK3krMSxiLGUpfSxuLnRvRXhwb25lbnRpYWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9ZSYmKEooZSwwLFcpLGUrKyksaSh0aGlzLGUsdCwxKX0sbi50b0ZpeGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJihKKGUsMCxXKSxlPWUrdGhpcy5lKzEpLGkodGhpcyxlLHQpfSxuLnRvRm9ybWF0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbjtpZihudWxsPT1yKW51bGwhPWUmJnQmJlwib2JqZWN0XCI9PXR5cGVvZiB0PyhyPXQsdD1udWxsKTplJiZcIm9iamVjdFwiPT10eXBlb2YgZT8ocj1lLGU9dD1udWxsKTpyPUI7ZWxzZSBpZihcIm9iamVjdFwiIT10eXBlb2Ygcil0aHJvdyBFcnJvcihJK1wiQXJndW1lbnQgbm90IGFuIG9iamVjdDogXCIrcik7aWYobj10aGlzLnRvRml4ZWQoZSx0KSx0aGlzLmMpe3ZhciBpLGE9bi5zcGxpdChcIi5cIiksbz0rci5ncm91cFNpemUsdT0rci5zZWNvbmRhcnlHcm91cFNpemUsYz1yLmdyb3VwU2VwYXJhdG9yfHxcIlwiLHM9YVswXSxsPWFbMV0sZj10aGlzLnM8MCxnPWY/cy5zbGljZSgxKTpzLHA9Zy5sZW5ndGg7aWYodSYmKGk9byxvPXUscC09dT1pKSwwPG8mJjA8cCl7Zm9yKGk9cCVvfHxvLHM9Zy5zdWJzdHIoMCxpKTtpPHA7aSs9bylzKz1jK2cuc3Vic3RyKGksbyk7MDx1JiYocys9YytnLnNsaWNlKGkpKSxmJiYocz1cIi1cIitzKX1uPWw/cysoci5kZWNpbWFsU2VwYXJhdG9yfHxcIlwiKSsoKHU9K3IuZnJhY3Rpb25Hcm91cFNpemUpP2wucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXGR7XCIrdStcIn1cXFxcQlwiLFwiZ1wiKSxcIiQmXCIrKHIuZnJhY3Rpb25Hcm91cFNlcGFyYXRvcnx8XCJcIikpOmwpOnN9cmV0dXJuKHIucHJlZml4fHxcIlwiKStuKyhyLnN1ZmZpeHx8XCJcIil9LG4udG9GcmFjdGlvbj1mdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG8sdSxjLHMsbCxmLGcscD10aGlzLGQ9cC5jO2lmKG51bGwhPWUmJighKHU9bmV3IEEoZSkpLmlzSW50ZWdlcigpJiYodS5jfHwxIT09dS5zKXx8dS5sdChoKSkpdGhyb3cgRXJyb3IoSStcIkFyZ3VtZW50IFwiKyh1LmlzSW50ZWdlcigpP1wib3V0IG9mIHJhbmdlOiBcIjpcIm5vdCBhbiBpbnRlZ2VyOiBcIikrUCh1KSk7aWYoIWQpcmV0dXJuIG5ldyBBKHApO2Zvcih0PW5ldyBBKGgpLHM9cj1uZXcgQShoKSxuPWM9bmV3IEEoaCksZz1ZKGQpLGE9dC5lPWcubGVuZ3RoLXAuZS0xLHQuY1swXT1aWyhvPWElVik8MD9WK286b10sZT0hZXx8MDx1LmNvbXBhcmVkVG8odCk/MDxhP3Q6czp1LG89TyxPPTEvMCx1PW5ldyBBKGcpLGMuY1swXT0wO2w9dih1LHQsMCwxKSwxIT0oaT1yLnBsdXMobC50aW1lcyhuKSkpLmNvbXBhcmVkVG8oZSk7KXI9bixuPWkscz1jLnBsdXMobC50aW1lcyhpPXMpKSxjPWksdD11Lm1pbnVzKGwudGltZXMoaT10KSksdT1pO3JldHVybiBpPXYoZS5taW51cyhyKSxuLDAsMSksYz1jLnBsdXMoaS50aW1lcyhzKSkscj1yLnBsdXMoaS50aW1lcyhuKSksYy5zPXMucz1wLnMsZj12KHMsbixhKj0yLGIpLm1pbnVzKHApLmFicygpLmNvbXBhcmVkVG8odihjLHIsYSxiKS5taW51cyhwKS5hYnMoKSk8MT9bcyxuXTpbYyxyXSxPPW8sZn0sbi50b051bWJlcj1mdW5jdGlvbigpe3JldHVybitQKHRoaXMpfSxuLnRvUHJlY2lzaW9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJkooZSwxLFcpLGkodGhpcyxlLHQsMil9LG4udG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQscj10aGlzLG49ci5zLGk9ci5lO3JldHVybiBudWxsPT09aT9uPyh0PVwiSW5maW5pdHlcIixuPDAmJih0PVwiLVwiK3QpKTp0PVwiTmFOXCI6KHQ9bnVsbD09ZT9pPD1kfHx3PD1pP1EoWShyLmMpLGkpOmVlKFkoci5jKSxpLFwiMFwiKToxMD09PWU/ZWUoWSgocj1qKG5ldyBBKHIpLHkraSsxLGIpKS5jKSxyLmUsXCIwXCIpOihKKGUsMixNLmxlbmd0aCxcIkJhc2VcIiksZihlZShZKHIuYyksaSxcIjBcIiksMTAsZSxuLCEwKSksbjwwJiZyLmNbMF0mJih0PVwiLVwiK3QpKSx0fSxuLnZhbHVlT2Y9bi50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gUCh0aGlzKX0sbi5faXNCaWdOdW1iZXI9ITAsQyYmKG5bU3ltYm9sLnRvU3RyaW5nVGFnXT1cIkJpZ051bWJlclwiLG5bU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXT1uLnZhbHVlT2YpLG51bGwhPXQmJkEuc2V0KHQpLEF9KCkpLmRlZmF1bHQ9dC5CaWdOdW1iZXI9dCx2b2lkIDAhPT1yJiZyLmV4cG9ydHM/ci5leHBvcnRzPXQ6KGU9ZXx8KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmP3NlbGY6d2luZG93KSkuQmlnTnVtYmVyPXR9KHRoaXMpfSx7fV0sMjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz17bGFuZ3VhZ2VUYWc6XCJlbi1VU1wiLGRlbGltaXRlcnM6e3Rob3VzYW5kczpcIixcIixkZWNpbWFsOlwiLlwifSxhYmJyZXZpYXRpb25zOnt0aG91c2FuZDpcImtcIixtaWxsaW9uOlwibVwiLGJpbGxpb246XCJiXCIsdHJpbGxpb246XCJ0XCJ9LHNwYWNlU2VwYXJhdGVkOiExLG9yZGluYWw6ZnVuY3Rpb24oZSl7dmFyIHQ9ZSUxMDtyZXR1cm4gMT09fn4oZSUxMDAvMTApP1widGhcIjoxPT10P1wic3RcIjoyPT10P1wibmRcIjozPT10P1wicmRcIjpcInRoXCJ9LGJ5dGVzOntiaW5hcnlTdWZmaXhlczpbXCJCXCIsXCJLaUJcIixcIk1pQlwiLFwiR2lCXCIsXCJUaUJcIixcIlBpQlwiLFwiRWlCXCIsXCJaaUJcIixcIllpQlwiXSxkZWNpbWFsU3VmZml4ZXM6W1wiQlwiLFwiS0JcIixcIk1CXCIsXCJHQlwiLFwiVEJcIixcIlBCXCIsXCJFQlwiLFwiWkJcIixcIllCXCJdfSxjdXJyZW5jeTp7c3ltYm9sOlwiJFwiLHBvc2l0aW9uOlwicHJlZml4XCIsY29kZTpcIlVTRFwifSxjdXJyZW5jeUZvcm1hdDp7dGhvdXNhbmRTZXBhcmF0ZWQ6ITAsdG90YWxMZW5ndGg6NCxzcGFjZVNlcGFyYXRlZDohMCxzcGFjZVNlcGFyYXRlZEN1cnJlbmN5OiEwfSxmb3JtYXRzOntmb3VyRGlnaXRzOnt0b3RhbExlbmd0aDo0LHNwYWNlU2VwYXJhdGVkOiEwfSxmdWxsV2l0aFR3b0RlY2ltYWxzOntvdXRwdXQ6XCJjdXJyZW5jeVwiLHRob3VzYW5kU2VwYXJhdGVkOiEwLG1hbnRpc3NhOjJ9LGZ1bGxXaXRoVHdvRGVjaW1hbHNOb0N1cnJlbmN5Ont0aG91c2FuZFNlcGFyYXRlZDohMCxtYW50aXNzYToyfSxmdWxsV2l0aE5vRGVjaW1hbHM6e291dHB1dDpcImN1cnJlbmN5XCIsdGhvdXNhbmRTZXBhcmF0ZWQ6ITAsbWFudGlzc2E6MH19fX0se31dLDM6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBJKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSkpcmV0dXJuO3ZhciByPVtdLG49ITAsaT0hMSxhPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShuPShvPXUubmV4dCgpKS5kb25lKSYmKHIucHVzaChvLnZhbHVlKSwhdHx8ci5sZW5ndGghPT10KTtuPSEwKTt9Y2F0Y2goZSl7aT0hMCxhPWV9ZmluYWxseXt0cnl7bnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IGF9fXJldHVybiByfShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfXZhciAkPWUoXCIuL2dsb2JhbFN0YXRlXCIpLG89ZShcIi4vdmFsaWRhdGluZ1wiKSx1PWUoXCIuL3BhcnNpbmdcIiksaT1lKFwiYmlnbnVtYmVyLmpzXCIpLEc9e3RyaWxsaW9uOk1hdGgucG93KDEwLDEyKSxiaWxsaW9uOk1hdGgucG93KDEwLDkpLG1pbGxpb246TWF0aC5wb3coMTAsNiksdGhvdXNhbmQ6TWF0aC5wb3coMTAsMyl9LFY9e3RvdGFsTGVuZ3RoOjAsY2hhcmFjdGVyaXN0aWM6MCxmb3JjZUF2ZXJhZ2U6ITEsYXZlcmFnZTohMSxtYW50aXNzYTotMSxvcHRpb25hbE1hbnRpc3NhOiEwLHRob3VzYW5kU2VwYXJhdGVkOiExLHNwYWNlU2VwYXJhdGVkOiExLG5lZ2F0aXZlOlwic2lnblwiLGZvcmNlU2lnbjohMSxyb3VuZGluZ0Z1bmN0aW9uOk1hdGgucm91bmQsc3BhY2VTZXBhcmF0ZWRBYmJyZXZpYXRpb246ITF9LG49JC5jdXJyZW50Qnl0ZXMoKSxkPW4uYmluYXJ5U3VmZml4ZXMsaD1uLmRlY2ltYWxTdWZmaXhlcyxhPXtnZW5lcmFsOntzY2FsZToxMDI0LHN1ZmZpeGVzOmgsbWFya2VyOlwiYmRcIn0sYmluYXJ5OntzY2FsZToxMDI0LHN1ZmZpeGVzOmQsbWFya2VyOlwiYlwifSxkZWNpbWFsOntzY2FsZToxZTMsc3VmZml4ZXM6aCxtYXJrZXI6XCJkXCJ9fTtmdW5jdGlvbiBjKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxyPTI8YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMl06dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD11LnBhcnNlRm9ybWF0KHQpKSwhby52YWxpZGF0ZUZvcm1hdCh0KSlyZXR1cm5cIkVSUk9SOiBpbnZhbGlkIGZvcm1hdFwiO3ZhciBuPXQucHJlZml4fHxcIlwiLGk9dC5wb3N0Zml4fHxcIlwiLGE9ZnVuY3Rpb24oZSx0LHIpe3N3aXRjaCh0Lm91dHB1dCl7Y2FzZVwiY3VycmVuY3lcIjpyZXR1cm4gdD1zKHQsJC5jdXJyZW50Q3VycmVuY3lEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yLmN1cnJlbnRDdXJyZW5jeSgpLGk9T2JqZWN0LmFzc2lnbih7fSx0KSxhPU9iamVjdC5hc3NpZ24oe30sVixpKSxvPXZvaWQgMCx1PVwiXCIsYz0hIWEudG90YWxMZW5ndGh8fCEhYS5mb3JjZUF2ZXJhZ2V8fGEuYXZlcmFnZSxzPWkuY3VycmVuY3lQb3NpdGlvbnx8bi5wb3NpdGlvbixsPWkuY3VycmVuY3lTeW1ib2x8fG4uc3ltYm9sLGY9dm9pZCAwIT09YS5zcGFjZVNlcGFyYXRlZEN1cnJlbmN5P2Euc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTphLnNwYWNlU2VwYXJhdGVkO3ZvaWQgMD09PWkubG93UHJlY2lzaW9uJiYoaS5sb3dQcmVjaXNpb249ITEpO2YmJih1PVwiIFwiKTtcImluZml4XCI9PT1zJiYobz11K2wrdSk7dmFyIGc9bSh7aW5zdGFuY2U6ZSxwcm92aWRlZEZvcm1hdDppLHN0YXRlOnIsZGVjaW1hbFNlcGFyYXRvcjpvfSk7XCJwcmVmaXhcIj09PXMmJihnPWUuX3ZhbHVlPDAmJlwic2lnblwiPT09YS5uZWdhdGl2ZT9cIi1cIi5jb25jYXQodSkuY29uY2F0KGwpLmNvbmNhdChnLnNsaWNlKDEpKTowPGUuX3ZhbHVlJiZhLmZvcmNlU2lnbj9cIitcIi5jb25jYXQodSkuY29uY2F0KGwpLmNvbmNhdChnLnNsaWNlKDEpKTpsK3UrZyk7cyYmXCJwb3N0Zml4XCIhPT1zfHwodT0hYS5zcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbiYmYz9cIlwiOnUsZz1nK3UrbCk7cmV0dXJuIGd9KGUsdCwkKTtjYXNlXCJwZXJjZW50XCI6cmV0dXJuIHQ9cyh0LCQuY3VycmVudFBlcmNlbnRhZ2VEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXQucHJlZml4U3ltYm9sLGE9bSh7aW5zdGFuY2U6bigxMDAqZS5fdmFsdWUpLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cn0pLG89T2JqZWN0LmFzc2lnbih7fSxWLHQpO2lmKGkpcmV0dXJuXCIlXCIuY29uY2F0KG8uc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIikuY29uY2F0KGEpO3JldHVyblwiXCIuY29uY2F0KGEpLmNvbmNhdChvLnNwYWNlU2VwYXJhdGVkP1wiIFwiOlwiXCIsXCIlXCIpfShlLHQsJCxyKTtjYXNlXCJieXRlXCI6cmV0dXJuIHQ9cyh0LCQuY3VycmVudEJ5dGVEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXQuYmFzZXx8XCJiaW5hcnlcIixhPU9iamVjdC5hc3NpZ24oe30sVix0KSxvPXIuY3VycmVudEJ5dGVzKCksdT1vLmJpbmFyeVN1ZmZpeGVzLGM9by5kZWNpbWFsU3VmZml4ZXMscz17Z2VuZXJhbDp7c2NhbGU6MTAyNCxzdWZmaXhlczpjfHxoLG1hcmtlcjpcImJkXCJ9LGJpbmFyeTp7c2NhbGU6MTAyNCxzdWZmaXhlczp1fHxkLG1hcmtlcjpcImJcIn0sZGVjaW1hbDp7c2NhbGU6MWUzLHN1ZmZpeGVzOmN8fGgsbWFya2VyOlwiZFwifX1baV0sbD12KGUuX3ZhbHVlLHMuc3VmZml4ZXMscy5zY2FsZSksZj1sLnZhbHVlLGc9bC5zdWZmaXgscD1tKHtpbnN0YW5jZTpuKGYpLHByb3ZpZGVkRm9ybWF0OnQsc3RhdGU6cixkZWZhdWx0czpyLmN1cnJlbnRCeXRlRGVmYXVsdEZvcm1hdCgpfSk7cmV0dXJuXCJcIi5jb25jYXQocCkuY29uY2F0KGEuc3BhY2VTZXBhcmF0ZWQ/XCIgXCI6XCJcIikuY29uY2F0KGcpfShlLHQsJCxyKTtjYXNlXCJ0aW1lXCI6cmV0dXJuIHQ9cyh0LCQuY3VycmVudFRpbWVEZWZhdWx0Rm9ybWF0KCkpLGZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoZS5fdmFsdWUvNjAvNjApLHI9TWF0aC5mbG9vcigoZS5fdmFsdWUtNjAqdCo2MCkvNjApLG49TWF0aC5yb3VuZChlLl92YWx1ZS02MCp0KjYwLTYwKnIpO3JldHVyblwiXCIuY29uY2F0KHQsXCI6XCIpLmNvbmNhdChyPDEwP1wiMFwiOlwiXCIpLmNvbmNhdChyLFwiOlwiKS5jb25jYXQobjwxMD9cIjBcIjpcIlwiKS5jb25jYXQobil9KGUpO2Nhc2VcIm9yZGluYWxcIjpyZXR1cm4gdD1zKHQsJC5jdXJyZW50T3JkaW5hbERlZmF1bHRGb3JtYXQoKSksZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIuY3VycmVudE9yZGluYWwoKSxpPU9iamVjdC5hc3NpZ24oe30sVix0KSxhPW0oe2luc3RhbmNlOmUscHJvdmlkZWRGb3JtYXQ6dCxzdGF0ZTpyfSksbz1uKGUuX3ZhbHVlKTtyZXR1cm5cIlwiLmNvbmNhdChhKS5jb25jYXQoaS5zcGFjZVNlcGFyYXRlZD9cIiBcIjpcIlwiKS5jb25jYXQobyl9KGUsdCwkKTtjYXNlXCJudW1iZXJcIjpkZWZhdWx0OnJldHVybiBtKHtpbnN0YW5jZTplLHByb3ZpZGVkRm9ybWF0OnQsbnVtYnJvOnJ9KX19KGUsdCxyKTtyZXR1cm4gYT0oYT1uK2EpK2l9ZnVuY3Rpb24gdihlLHQscil7dmFyIG49dFswXSxpPU1hdGguYWJzKGUpO2lmKHI8PWkpe2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7KythKXt2YXIgbz1NYXRoLnBvdyhyLGEpLHU9TWF0aC5wb3cocixhKzEpO2lmKG88PWkmJmk8dSl7bj10W2FdLGUvPW87YnJlYWt9fW49PT10WzBdJiYoZS89TWF0aC5wb3cocix0Lmxlbmd0aC0xKSxuPXRbdC5sZW5ndGgtMV0pfXJldHVybnt2YWx1ZTplLHN1ZmZpeDpufX1mdW5jdGlvbiBnKGUpe2Zvcih2YXIgdD1cIlwiLHI9MDtyPGU7cisrKXQrPVwiMFwiO3JldHVybiB0fWZ1bmN0aW9uIHEoZSx0LHIpe3ZhciBuPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09cj9yOk1hdGgucm91bmQ7cmV0dXJuLTEhPT1lLnRvU3RyaW5nKCkuaW5kZXhPZihcImVcIik/ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLnRvU3RyaW5nKCksbj1JKHIuc3BsaXQoXCJlXCIpLDIpLGk9blswXSxhPW5bMV0sbz1JKGkuc3BsaXQoXCIuXCIpLDIpLHU9b1swXSxjPW9bMV0scz12b2lkIDA9PT1jP1wiXCI6YztpZigwPCthKXI9dStzK2coYS1zLmxlbmd0aCk7ZWxzZXt2YXIgbD1cIi5cIjtsPSt1PDA/XCItMFwiLmNvbmNhdChsKTpcIjBcIi5jb25jYXQobCk7dmFyIGY9KGcoLWEtMSkrTWF0aC5hYnModSkrcykuc3Vic3RyKDAsdCk7Zi5sZW5ndGg8dCYmKGYrPWcodC1mLmxlbmd0aCkpLHI9bCtmfXJldHVybiAwPCthJiYwPHQmJihyKz1cIi5cIi5jb25jYXQoZyh0KSkpLHJ9KGUsdCk6bmV3IGkobigrXCJcIi5jb25jYXQoZSxcImUrXCIpLmNvbmNhdCh0KSkvTWF0aC5wb3coMTAsdCkpLnRvRml4ZWQodCl9ZnVuY3Rpb24gWihlLHQscixuLGkpe3ZhciBhPW4uY3VycmVudERlbGltaXRlcnMoKSxvPWEudGhvdXNhbmRzO2k9aXx8YS5kZWNpbWFsO3ZhciB1PWEudGhvdXNhbmRzU2l6ZXx8MyxjPWUudG9TdHJpbmcoKSxzPWMuc3BsaXQoXCIuXCIpWzBdLGw9Yy5zcGxpdChcIi5cIilbMV0sZj10PDAmJjA9PT1zLmluZGV4T2YoXCItXCIpO3ImJihmJiYocz1zLnNsaWNlKDEpKSxmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1bXSxuPTAsaT1lOzA8aTtpLS0pbj09PXQmJihyLnVuc2hpZnQoaSksbj0wKSxuKys7cmV0dXJuIHJ9KHMubGVuZ3RoLHUpLmZvckVhY2goZnVuY3Rpb24oZSx0KXtzPXMuc2xpY2UoMCxlK3QpK28rcy5zbGljZShlK3QpfSksZiYmKHM9XCItXCIuY29uY2F0KHMpKSk7cmV0dXJuIGM9bD9zK2krbDpzfWZ1bmN0aW9uIG0oZSl7dmFyIHQ9ZS5pbnN0YW5jZSxyPWUucHJvdmlkZWRGb3JtYXQsbj1lLnN0YXRlLGk9dm9pZCAwPT09bj8kOm4sYT1lLmRlY2ltYWxTZXBhcmF0b3Isbz1lLmRlZmF1bHRzLHU9dm9pZCAwPT09bz9pLmN1cnJlbnREZWZhdWx0cygpOm8sYz10Ll92YWx1ZTtpZigwPT09YyYmaS5oYXNaZXJvRm9ybWF0KCkpcmV0dXJuIGkuZ2V0WmVyb0Zvcm1hdCgpO2lmKCFpc0Zpbml0ZShjKSlyZXR1cm4gYy50b1N0cmluZygpO3ZhciBzLGwsZixnLHAsZCxoLHYsbT1PYmplY3QuYXNzaWduKHt9LFYsdSxyKSx5PW0udG90YWxMZW5ndGgsYj15PzA6bS5jaGFyYWN0ZXJpc3RpYyx3PW0ub3B0aW9uYWxDaGFyYWN0ZXJpc3RpYyxTPW0uZm9yY2VBdmVyYWdlLE89bS5sb3dQcmVjaXNpb24seD0hIXl8fCEhU3x8bS5hdmVyYWdlLE49eT8tMTp4JiZ2b2lkIDA9PT1yLm1hbnRpc3NhPzA6bS5tYW50aXNzYSxCPSF5JiYodm9pZCAwPT09ci5vcHRpb25hbE1hbnRpc3NhPy0xPT09TjptLm9wdGlvbmFsTWFudGlzc2EpLE09bS50cmltTWFudGlzc2EsQT1tLnRob3VzYW5kU2VwYXJhdGVkLEQ9bS5zcGFjZVNlcGFyYXRlZCxFPW0ubmVnYXRpdmUsRj1tLmZvcmNlU2lnbixrPW0uZXhwb25lbnRpYWwsXz1tLnJvdW5kaW5nRnVuY3Rpb24sTD1cIlwiO2lmKHgpe3ZhciBqPWZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWUscj1lLmZvcmNlQXZlcmFnZSxuPWUubG93UHJlY2lzaW9uLGk9dm9pZCAwPT09bnx8bixhPWUuYWJicmV2aWF0aW9ucyxvPWUuc3BhY2VTZXBhcmF0ZWQsdT12b2lkIDAhPT1vJiZvLGM9ZS50b3RhbExlbmd0aCxzPXZvaWQgMD09PWM/MDpjLGw9ZS5yb3VuZGluZ0Z1bmN0aW9uLGY9dm9pZCAwPT09bD9NYXRoLnJvdW5kOmwsZz1cIlwiLHA9TWF0aC5hYnModCksZD0tMTtpZihyJiZhW3JdJiZHW3JdPyhnPWFbcl0sdC89R1tyXSk6cD49Ry50cmlsbGlvbnx8aSYmMT09PWYocC9HLnRyaWxsaW9uKT8oZz1hLnRyaWxsaW9uLHQvPUcudHJpbGxpb24pOnA8Ry50cmlsbGlvbiYmcD49Ry5iaWxsaW9ufHxpJiYxPT09ZihwL0cuYmlsbGlvbik/KGc9YS5iaWxsaW9uLHQvPUcuYmlsbGlvbik6cDxHLmJpbGxpb24mJnA+PUcubWlsbGlvbnx8aSYmMT09PWYocC9HLm1pbGxpb24pPyhnPWEubWlsbGlvbix0Lz1HLm1pbGxpb24pOihwPEcubWlsbGlvbiYmcD49Ry50aG91c2FuZHx8aSYmMT09PWYocC9HLnRob3VzYW5kKSkmJihnPWEudGhvdXNhbmQsdC89Ry50aG91c2FuZCksZz1nJiYodT9cIiBcIjpcIlwiKStnLHMpe3ZhciBoPXQ8MCx2PXQudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMF0sbT1oP3YubGVuZ3RoLTE6di5sZW5ndGg7ZD1NYXRoLm1heChzLW0sMCl9cmV0dXJue3ZhbHVlOnQsYWJicmV2aWF0aW9uOmcsbWFudGlzc2FQcmVjaXNpb246ZH19KHt2YWx1ZTpjLGZvcmNlQXZlcmFnZTpTLGxvd1ByZWNpc2lvbjpPLGFiYnJldmlhdGlvbnM6aS5jdXJyZW50QWJicmV2aWF0aW9ucygpLHNwYWNlU2VwYXJhdGVkOkQscm91bmRpbmdGdW5jdGlvbjpfLHRvdGFsTGVuZ3RoOnl9KTtjPWoudmFsdWUsTCs9ai5hYmJyZXZpYXRpb24seSYmKE49ai5tYW50aXNzYVByZWNpc2lvbil9aWYoayl7dmFyIFA9KGw9KHM9e3ZhbHVlOmMsY2hhcmFjdGVyaXN0aWNQcmVjaXNpb246Yn0pLnZhbHVlLGY9cy5jaGFyYWN0ZXJpc3RpY1ByZWNpc2lvbixnPXZvaWQgMD09PWY/MDpmLHA9SShsLnRvRXhwb25lbnRpYWwoKS5zcGxpdChcImVcIiksMiksZD1wWzBdLGg9cFsxXSx2PStkLGcmJjE8ZyYmKHYqPU1hdGgucG93KDEwLGctMSksaD0wPD0oaC09Zy0xKT9cIitcIi5jb25jYXQoaCk6aCkse3ZhbHVlOnYsYWJicmV2aWF0aW9uOlwiZVwiLmNvbmNhdChoKX0pO2M9UC52YWx1ZSxMPVAuYWJicmV2aWF0aW9uK0x9dmFyIFQsQyxVLFI9ZnVuY3Rpb24oZSx0LHIsbixpLGEpe2lmKC0xPT09bilyZXR1cm4gZTt2YXIgbz1xKHQsbixhKSx1PUkoby50b1N0cmluZygpLnNwbGl0KFwiLlwiKSwyKSxjPXVbMF0scz11WzFdLGw9dm9pZCAwPT09cz9cIlwiOnM7aWYobC5tYXRjaCgvXjArJC8pJiYocnx8aSkpcmV0dXJuIGM7dmFyIGY9bC5tYXRjaCgvMCskLyk7cmV0dXJuIGkmJmY/XCJcIi5jb25jYXQoYyxcIi5cIikuY29uY2F0KGwudG9TdHJpbmcoKS5zbGljZSgwLGYuaW5kZXgpKTpvLnRvU3RyaW5nKCl9KGMudG9TdHJpbmcoKSxjLEIsTixNLF8pO3JldHVybiBSPVooUj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT1lLGE9SShpLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLDIpLG89YVswXSx1PWFbMV07aWYoby5tYXRjaCgvXi0/MCQvKSYmcilyZXR1cm4gdT9cIlwiLmNvbmNhdChvLnJlcGxhY2UoXCIwXCIsXCJcIiksXCIuXCIpLmNvbmNhdCh1KTpvLnJlcGxhY2UoXCIwXCIsXCJcIik7dmFyIGM9dDwwJiYwPT09by5pbmRleE9mKFwiLVwiKTtpZihjJiYobz1vLnNsaWNlKDEpLGk9aS5zbGljZSgxKSksby5sZW5ndGg8bilmb3IodmFyIHM9bi1vLmxlbmd0aCxsPTA7bDxzO2wrKylpPVwiMFwiLmNvbmNhdChpKTtyZXR1cm4gYyYmKGk9XCItXCIuY29uY2F0KGkpKSxpLnRvU3RyaW5nKCl9KFIsYyx3LGIpLGMsQSxpLGEpLCh4fHxrKSYmKFI9UitMKSwoRnx8YzwwKSYmKFQ9UixVPUUsUj0wPT09KEM9Yyk/VDowPT0rVD9ULnJlcGxhY2UoXCItXCIsXCJcIik6MDxDP1wiK1wiLmNvbmNhdChUKTpcInNpZ25cIj09PVU/VDpcIihcIi5jb25jYXQoVC5yZXBsYWNlKFwiLVwiLFwiXCIpLFwiKVwiKSksUn1mdW5jdGlvbiBzKGUsdCl7aWYoIWUpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmtleXMoZSk7cmV0dXJuIDE9PT1yLmxlbmd0aCYmXCJvdXRwdXRcIj09PXJbMF0/dDplfXQuZXhwb3J0cz1mdW5jdGlvbihuKXtyZXR1cm57Zm9ybWF0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGMuYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxnZXRCeXRlVW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1hLmdlbmVyYWw7cmV0dXJuIHYoZS5fdmFsdWUsdC5zdWZmaXhlcyx0LnNjYWxlKS5zdWZmaXh9LmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZ2V0QmluYXJ5Qnl0ZVVuaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9YS5iaW5hcnk7cmV0dXJuIHYoZS5fdmFsdWUsdC5zdWZmaXhlcyx0LnNjYWxlKS5zdWZmaXh9LmFwcGx5KHZvaWQgMCx0LmNvbmNhdChbbl0pKX0sZ2V0RGVjaW1hbEJ5dGVVbml0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWEuZGVjaW1hbDtyZXR1cm4gdihlLl92YWx1ZSx0LnN1ZmZpeGVzLHQuc2NhbGUpLnN1ZmZpeH0uYXBwbHkodm9pZCAwLHQuY29uY2F0KFtuXSkpfSxmb3JtYXRPckRlZmF1bHQ6c319fSx7XCIuL2dsb2JhbFN0YXRlXCI6NCxcIi4vcGFyc2luZ1wiOjgsXCIuL3ZhbGlkYXRpbmdcIjoxMCxcImJpZ251bWJlci5qc1wiOjF9XSw0OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4vZW4tVVNcIiksbj1lKFwiLi92YWxpZGF0aW5nXCIpLGE9ZShcIi4vcGFyc2luZ1wiKSxvPXt9LHU9dm9pZCAwLGM9e30scz1udWxsLGw9e307ZnVuY3Rpb24gZihlKXt1PWV9ZnVuY3Rpb24gZygpe3JldHVybiBjW3VdfW8ubGFuZ3VhZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sYyl9LG8uY3VycmVudExhbmd1YWdlPWZ1bmN0aW9uKCl7cmV0dXJuIHV9LG8uY3VycmVudEJ5dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIGcoKS5ieXRlc3x8e319LG8uY3VycmVudEN1cnJlbmN5PWZ1bmN0aW9uKCl7cmV0dXJuIGcoKS5jdXJyZW5jeX0sby5jdXJyZW50QWJicmV2aWF0aW9ucz1mdW5jdGlvbigpe3JldHVybiBnKCkuYWJicmV2aWF0aW9uc30sby5jdXJyZW50RGVsaW1pdGVycz1mdW5jdGlvbigpe3JldHVybiBnKCkuZGVsaW1pdGVyc30sby5jdXJyZW50T3JkaW5hbD1mdW5jdGlvbigpe3JldHVybiBnKCkub3JkaW5hbH0sby5jdXJyZW50RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxnKCkuZGVmYXVsdHMsbCl9LG8uY3VycmVudE9yZGluYWxEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxnKCkub3JkaW5hbEZvcm1hdCl9LG8uY3VycmVudEJ5dGVEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxnKCkuYnl0ZUZvcm1hdCl9LG8uY3VycmVudFBlcmNlbnRhZ2VEZWZhdWx0Rm9ybWF0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sby5jdXJyZW50RGVmYXVsdHMoKSxnKCkucGVyY2VudGFnZUZvcm1hdCl9LG8uY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdD1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LG8uY3VycmVudERlZmF1bHRzKCksZygpLmN1cnJlbmN5Rm9ybWF0KX0sby5jdXJyZW50VGltZURlZmF1bHRGb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxvLmN1cnJlbnREZWZhdWx0cygpLGcoKS50aW1lRm9ybWF0KX0sby5zZXREZWZhdWx0cz1mdW5jdGlvbihlKXtlPWEucGFyc2VGb3JtYXQoZSksbi52YWxpZGF0ZUZvcm1hdChlKSYmKGw9ZSl9LG8uZ2V0WmVyb0Zvcm1hdD1mdW5jdGlvbigpe3JldHVybiBzfSxvLnNldFplcm9Gb3JtYXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHM9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpudWxsfSxvLmhhc1plcm9Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXN9LG8ubGFuZ3VhZ2VEYXRhPWZ1bmN0aW9uKGUpe2lmKGUpe2lmKGNbZV0pcmV0dXJuIGNbZV07dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRhZyBcIicuY29uY2F0KGUsJ1wiJykpfXJldHVybiBnKCl9LG8ucmVnaXN0ZXJMYW5ndWFnZT1mdW5jdGlvbihlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO2lmKCFuLnZhbGlkYXRlTGFuZ3VhZ2UoZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsYW5ndWFnZSBkYXRhXCIpO2NbZS5sYW5ndWFnZVRhZ109ZSx0JiZmKGUubGFuZ3VhZ2VUYWcpfSxvLnNldExhbmd1YWdlPWZ1bmN0aW9uKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTppLmxhbmd1YWdlVGFnO2lmKCFjW2VdKXt2YXIgcj1lLnNwbGl0KFwiLVwiKVswXSxuPU9iamVjdC5rZXlzKGMpLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCItXCIpWzBdPT09cn0pO3JldHVybiBjW25dP3ZvaWQgZihuKTp2b2lkIGYodCl9ZihlKX0sby5yZWdpc3Rlckxhbmd1YWdlKGkpLHU9aS5sYW5ndWFnZVRhZyx0LmV4cG9ydHM9b30se1wiLi9lbi1VU1wiOjIsXCIuL3BhcnNpbmdcIjo4LFwiLi92YWxpZGF0aW5nXCI6MTB9XSw1OltmdW5jdGlvbihuLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybntsb2FkTGFuZ3VhZ2VzSW5Ob2RlOmZ1bmN0aW9uKGUpe3JldHVybiByPXQsdm9pZCBlLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwO3RyeXtlPW4oXCIuLi9sYW5ndWFnZXMvXCIuY29uY2F0KHQpKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gbG9hZCBcIicuY29uY2F0KHQsJ1wiLiBObyBtYXRjaGluZyBsYW5ndWFnZSBmaWxlIGZvdW5kLicpKX1lJiZyLnJlZ2lzdGVyTGFuZ3VhZ2UoZSl9KTt2YXIgcn19fX0se31dLDY6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1lKFwiYmlnbnVtYmVyLmpzXCIpO2Z1bmN0aW9uIGEoZSx0LHIpe3ZhciBuPW5ldyBjKGUuX3ZhbHVlKSxpPXQ7cmV0dXJuIHIuaXNOdW1icm8odCkmJihpPXQuX3ZhbHVlKSxpPW5ldyBjKGkpLGUuX3ZhbHVlPW4ubWludXMoaSkudG9OdW1iZXIoKSxlfXQuZXhwb3J0cz1mdW5jdGlvbih1KXtyZXR1cm57YWRkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG49dCxpPXUsYT1uZXcgYygocj1lKS5fdmFsdWUpLG89bixpLmlzTnVtYnJvKG4pJiYobz1uLl92YWx1ZSksbz1uZXcgYyhvKSxyLl92YWx1ZT1hLnBsdXMobykudG9OdW1iZXIoKSxyO3ZhciByLG4saSxhLG99LHN1YnRyYWN0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGEoZSx0LHUpfSxtdWx0aXBseTpmdW5jdGlvbihlLHQpe3JldHVybiBuPXQsaT11LGE9bmV3IGMoKHI9ZSkuX3ZhbHVlKSxvPW4saS5pc051bWJybyhuKSYmKG89bi5fdmFsdWUpLG89bmV3IGMobyksci5fdmFsdWU9YS50aW1lcyhvKS50b051bWJlcigpLHI7dmFyIHIsbixpLGEsb30sZGl2aWRlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG49dCxpPXUsYT1uZXcgYygocj1lKS5fdmFsdWUpLG89bixpLmlzTnVtYnJvKG4pJiYobz1uLl92YWx1ZSksbz1uZXcgYyhvKSxyLl92YWx1ZT1hLmRpdmlkZWRCeShvKS50b051bWJlcigpLHI7dmFyIHIsbixpLGEsb30sc2V0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHI9ZSxpPW49dCx1LmlzTnVtYnJvKG4pJiYoaT1uLl92YWx1ZSksci5fdmFsdWU9aSxyO3ZhciByLG4saX0sZGlmZmVyZW5jZTpmdW5jdGlvbihlLHQpe3JldHVybiByPXQsYShpPShuPXUpKGUuX3ZhbHVlKSxyLG4pLE1hdGguYWJzKGkuX3ZhbHVlKTt2YXIgcixuLGl9LEJpZ051bWJlcjpjfX19LHtcImJpZ251bWJlci5qc1wiOjF9XSw3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19dmFyIGE9ZShcIi4vZ2xvYmFsU3RhdGVcIiksbj1lKFwiLi92YWxpZGF0aW5nXCIpLG89ZShcIi4vbG9hZGluZ1wiKShwKSx1PWUoXCIuL3VuZm9ybWF0dGluZ1wiKSxjPWUoXCIuL2Zvcm1hdHRpbmdcIikocCkscz1lKFwiLi9tYW5pcHVsYXRpbmdcIikocCksbD1lKFwiLi9wYXJzaW5nXCIpLGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksdGhpcy5fdmFsdWU9ZX12YXIgZSxyLG47cmV0dXJuIGU9dCwocj1be2tleTpcImNsb25lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzLl92YWx1ZSl9fSx7a2V5OlwiZm9ybWF0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJuIGMuZm9ybWF0KHRoaXMsdCl9fSx7a2V5OlwiZm9ybWF0Q3VycmVuY3lcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bC5wYXJzZUZvcm1hdChlKSksKGU9Yy5mb3JtYXRPckRlZmF1bHQoZSxhLmN1cnJlbnRDdXJyZW5jeURlZmF1bHRGb3JtYXQoKSkpLm91dHB1dD1cImN1cnJlbmN5XCIsYy5mb3JtYXQodGhpcyxlKX19LHtrZXk6XCJmb3JtYXRUaW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lP2U6e307cmV0dXJuIHQub3V0cHV0PVwidGltZVwiLGMuZm9ybWF0KHRoaXMsdCl9fSx7a2V5OlwiYmluYXJ5Qnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXRCaW5hcnlCeXRlVW5pdCh0aGlzKX19LHtrZXk6XCJkZWNpbWFsQnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXREZWNpbWFsQnl0ZVVuaXQodGhpcyl9fSx7a2V5OlwiYnl0ZVVuaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXRCeXRlVW5pdCh0aGlzKX19LHtrZXk6XCJkaWZmZXJlbmNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuZGlmZmVyZW5jZSh0aGlzLGUpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLmFkZCh0aGlzLGUpfX0se2tleTpcInN1YnRyYWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuc3VidHJhY3QodGhpcyxlKX19LHtrZXk6XCJtdWx0aXBseVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBzLm11bHRpcGx5KHRoaXMsZSl9fSx7a2V5OlwiZGl2aWRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuZGl2aWRlKHRoaXMsZSl9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuc2V0KHRoaXMsZyhlKSl9fSx7a2V5OlwidmFsdWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX19LHtrZXk6XCJ2YWx1ZU9mXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWV9fV0pJiZpKGUucHJvdG90eXBlLHIpLG4mJmkoZSxuKSx0fSgpO2Z1bmN0aW9uIGcoZSl7dmFyIHQ9ZTtyZXR1cm4gcC5pc051bWJybyhlKT90PWUuX3ZhbHVlOlwic3RyaW5nXCI9PXR5cGVvZiBlP3Q9cC51bmZvcm1hdChlKTppc05hTihlKSYmKHQ9TmFOKSx0fWZ1bmN0aW9uIHAoZSl7cmV0dXJuIG5ldyBmKGcoZSkpfXAudmVyc2lvbj1cIjIuMy42XCIscC5pc051bWJybz1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGZ9LHAubGFuZ3VhZ2U9YS5jdXJyZW50TGFuZ3VhZ2UscC5yZWdpc3Rlckxhbmd1YWdlPWEucmVnaXN0ZXJMYW5ndWFnZSxwLnNldExhbmd1YWdlPWEuc2V0TGFuZ3VhZ2UscC5sYW5ndWFnZXM9YS5sYW5ndWFnZXMscC5sYW5ndWFnZURhdGE9YS5sYW5ndWFnZURhdGEscC56ZXJvRm9ybWF0PWEuc2V0WmVyb0Zvcm1hdCxwLmRlZmF1bHRGb3JtYXQ9YS5jdXJyZW50RGVmYXVsdHMscC5zZXREZWZhdWx0cz1hLnNldERlZmF1bHRzLHAuZGVmYXVsdEN1cnJlbmN5Rm9ybWF0PWEuY3VycmVudEN1cnJlbmN5RGVmYXVsdEZvcm1hdCxwLnZhbGlkYXRlPW4udmFsaWRhdGUscC5sb2FkTGFuZ3VhZ2VzSW5Ob2RlPW8ubG9hZExhbmd1YWdlc0luTm9kZSxwLnVuZm9ybWF0PXUudW5mb3JtYXQscC5CaWdOdW1iZXI9cy5CaWdOdW1iZXIsdC5leHBvcnRzPXB9LHtcIi4vZm9ybWF0dGluZ1wiOjMsXCIuL2dsb2JhbFN0YXRlXCI6NCxcIi4vbG9hZGluZ1wiOjUsXCIuL21hbmlwdWxhdGluZ1wiOjYsXCIuL3BhcnNpbmdcIjo4LFwiLi91bmZvcm1hdHRpbmdcIjo5LFwiLi92YWxpZGF0aW5nXCI6MTB9XSw4OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXtwYXJzZUZvcm1hdDpmdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLG8sdSxjLHMsbCxmLGcscCxkLGgsdixtLHksYix3LFMsTyx4PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZT9lOihyPXgsZT0obj0odD1lKS5tYXRjaCgvXnsoW159XSopfS8pKT8oci5wcmVmaXg9blsxXSx0LnNsaWNlKG5bMF0ubGVuZ3RoKSk6dCxhPXgsZnVuY3Rpb24oZSx0KXtpZigtMT09PWUuaW5kZXhPZihcIiRcIikpe2lmKC0xPT09ZS5pbmRleE9mKFwiJVwiKSlyZXR1cm4tMSE9PWUuaW5kZXhPZihcImJkXCIpPyh0Lm91dHB1dD1cImJ5dGVcIix0LmJhc2U9XCJnZW5lcmFsXCIpOi0xIT09ZS5pbmRleE9mKFwiYlwiKT8odC5vdXRwdXQ9XCJieXRlXCIsdC5iYXNlPVwiYmluYXJ5XCIpOi0xIT09ZS5pbmRleE9mKFwiZFwiKT8odC5vdXRwdXQ9XCJieXRlXCIsdC5iYXNlPVwiZGVjaW1hbFwiKTotMT09PWUuaW5kZXhPZihcIjpcIik/LTEhPT1lLmluZGV4T2YoXCJvXCIpJiYodC5vdXRwdXQ9XCJvcmRpbmFsXCIpOnQub3V0cHV0PVwidGltZVwiO3Qub3V0cHV0PVwicGVyY2VudFwifWVsc2UgdC5vdXRwdXQ9XCJjdXJyZW5jeVwifShlPShvPShpPWUpLm1hdGNoKC97KFtefV0qKX0kLykpPyhhLnBvc3RmaXg9b1sxXSxpLnNsaWNlKDAsLW9bMF0ubGVuZ3RoKSk6aSx4KSx1PXgsKGM9ZS5tYXRjaCgvWzEtOV0rWzAtOV0qLykpJiYodS50b3RhbExlbmd0aD0rY1swXSkscz14LChsPWUuc3BsaXQoXCIuXCIpWzBdLm1hdGNoKC8wKy8pKSYmKHMuY2hhcmFjdGVyaXN0aWM9bFswXS5sZW5ndGgpLGZ1bmN0aW9uKGUsdCl7aWYoLTEhPT1lLmluZGV4T2YoXCIuXCIpKXt2YXIgcj1lLnNwbGl0KFwiLlwiKVswXTt0Lm9wdGlvbmFsQ2hhcmFjdGVyaXN0aWM9LTE9PT1yLmluZGV4T2YoXCIwXCIpfX0oZSx4KSxmPXgsLTEhPT1lLmluZGV4T2YoXCJhXCIpJiYoZi5hdmVyYWdlPSEwKSxwPXgsLTEhPT0oZz1lKS5pbmRleE9mKFwiS1wiKT9wLmZvcmNlQXZlcmFnZT1cInRob3VzYW5kXCI6LTEhPT1nLmluZGV4T2YoXCJNXCIpP3AuZm9yY2VBdmVyYWdlPVwibWlsbGlvblwiOi0xIT09Zy5pbmRleE9mKFwiQlwiKT9wLmZvcmNlQXZlcmFnZT1cImJpbGxpb25cIjotMSE9PWcuaW5kZXhPZihcIlRcIikmJihwLmZvcmNlQXZlcmFnZT1cInRyaWxsaW9uXCIpLGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5zcGxpdChcIi5cIilbMV07aWYocil7dmFyIG49ci5tYXRjaCgvMCsvKTtuJiYodC5tYW50aXNzYT1uWzBdLmxlbmd0aCl9fShlLHgpLGg9eCwoZD1lKS5tYXRjaCgvXFxbXFwuXS8pP2gub3B0aW9uYWxNYW50aXNzYT0hMDpkLm1hdGNoKC9cXC4vKSYmKGgub3B0aW9uYWxNYW50aXNzYT0hMSksdj14LChtPWUuc3BsaXQoXCIuXCIpWzFdKSYmKHYudHJpbU1hbnRpc3NhPS0xIT09bS5pbmRleE9mKFwiW1wiKSkseT14LC0xIT09ZS5pbmRleE9mKFwiLFwiKSYmKHkudGhvdXNhbmRTZXBhcmF0ZWQ9ITApLGI9eCwtMSE9PWUuaW5kZXhPZihcIiBcIikmJihiLnNwYWNlU2VwYXJhdGVkPSEwLGIuc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeT0hMCwoYi5hdmVyYWdlfHxiLmZvcmNlQXZlcmFnZSkmJihiLnNwYWNlU2VwYXJhdGVkQWJicmV2aWF0aW9uPSEwKSksUz14LCh3PWUpLm1hdGNoKC9eXFwrP1xcKFteKV0qXFwpJC8pJiYoUy5uZWdhdGl2ZT1cInBhcmVudGhlc2lzXCIpLHcubWF0Y2goL15cXCs/LS8pJiYoUy5uZWdhdGl2ZT1cInNpZ25cIiksTz14LGUubWF0Y2goL15cXCsvKSYmKE8uZm9yY2VTaWduPSEwKSx4KX19fSx7fV0sOTpbZnVuY3Rpb24oZyxlLHQpe1widXNlIHN0cmljdFwiO3ZhciBNPVt7a2V5OlwiWmlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNyl9LHtrZXk6XCJaQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNyl9LHtrZXk6XCJZaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw4KX0se2tleTpcIllCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw4KX0se2tleTpcIlRpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDQpfSx7a2V5OlwiVEJcIixmYWN0b3I6TWF0aC5wb3coMWUzLDQpfSx7a2V5OlwiUGlCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsNSl9LHtrZXk6XCJQQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsNSl9LHtrZXk6XCJNaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCwyKX0se2tleTpcIk1CXCIsZmFjdG9yOk1hdGgucG93KDFlMywyKX0se2tleTpcIktpQlwiLGZhY3RvcjpNYXRoLnBvdygxMDI0LDEpfSx7a2V5OlwiS0JcIixmYWN0b3I6TWF0aC5wb3coMWUzLDEpfSx7a2V5OlwiR2lCXCIsZmFjdG9yOk1hdGgucG93KDEwMjQsMyl9LHtrZXk6XCJHQlwiLGZhY3RvcjpNYXRoLnBvdygxZTMsMyl9LHtrZXk6XCJFaUJcIixmYWN0b3I6TWF0aC5wb3coMTAyNCw2KX0se2tleTpcIkVCXCIsZmFjdG9yOk1hdGgucG93KDFlMyw2KX0se2tleTpcIkJcIixmYWN0b3I6MX1dO2Z1bmN0aW9uIEEoZSl7cmV0dXJuIGUucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBwKGUsdCxyLG4saSxhLG8pe3ZhciB1PTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09cj9yOlwiXCIsYz0zPGFyZ3VtZW50cy5sZW5ndGg/bjp2b2lkIDAscz00PGFyZ3VtZW50cy5sZW5ndGg/aTp2b2lkIDAsbD01PGFyZ3VtZW50cy5sZW5ndGg/YTp2b2lkIDAsZj02PGFyZ3VtZW50cy5sZW5ndGg/bzp2b2lkIDA7aWYoXCJcIiE9PWUpcmV0dXJuIGU9PT1zPzA6ZnVuY3Rpb24gZSh0LHIsbixpLGEsbyx1KXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PW4/bjpcIlwiLHM9Mzxhcmd1bWVudHMubGVuZ3RoP2k6dm9pZCAwLGw9NDxhcmd1bWVudHMubGVuZ3RoP2E6dm9pZCAwLGY9NTxhcmd1bWVudHMubGVuZ3RoP286dm9pZCAwLGc9Njxhcmd1bWVudHMubGVuZ3RoP3U6dm9pZCAwO2lmKCFpc05hTigrdCkpcmV0dXJuK3Q7dmFyIHA9XCJcIixkPXQucmVwbGFjZSgvKF5bXihdKilcXCgoLiopXFwpKFteKV0qJCkvLFwiJDEkMiQzXCIpO2lmKGQhPT10KXJldHVybi0xKmUoZCxyLGMscyxsLGYsZyk7Zm9yKHZhciBoPTA7aDxNLmxlbmd0aDtoKyspe3ZhciB2PU1baF07aWYoKHA9dC5yZXBsYWNlKFJlZ0V4cChcIihbMC05IF0pKFwiLmNvbmNhdCh2LmtleSxcIikkXCIpKSxcIiQxXCIpKSE9PXQpcmV0dXJuIGUocCxyLGMscyxsLGYsZykqdi5mYWN0b3J9aWYoKHA9dC5yZXBsYWNlKFwiJVwiLFwiXCIpKSE9PXQpcmV0dXJuIGUocCxyLGMscyxsLGYsZykvMTAwO3ZhciBtPXBhcnNlRmxvYXQodCk7aWYoIWlzTmFOKG0pKXt2YXIgeT1zKG0pO2lmKHkmJlwiLlwiIT09eSYmKHA9dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoQSh5KSxcIiRcIikpLFwiXCIpKSE9PXQpcmV0dXJuIGUocCxyLGMscyxsLGYsZyk7dmFyIGI9e307T2JqZWN0LmtleXMoZikuZm9yRWFjaChmdW5jdGlvbihlKXtiW2ZbZV1dPWV9KTtmb3IodmFyIHc9T2JqZWN0LmtleXMoYikuc29ydCgpLnJldmVyc2UoKSxTPXcubGVuZ3RoLE89MDtPPFM7TysrKXt2YXIgeD13W09dLE49Ylt4XTtpZigocD10LnJlcGxhY2UoeCxcIlwiKSkhPT10KXt2YXIgQj12b2lkIDA7c3dpdGNoKE4pe2Nhc2VcInRob3VzYW5kXCI6Qj1NYXRoLnBvdygxMCwzKTticmVhaztjYXNlXCJtaWxsaW9uXCI6Qj1NYXRoLnBvdygxMCw2KTticmVhaztjYXNlXCJiaWxsaW9uXCI6Qj1NYXRoLnBvdygxMCw5KTticmVhaztjYXNlXCJ0cmlsbGlvblwiOkI9TWF0aC5wb3coMTAsMTIpfXJldHVybiBlKHAscixjLHMsbCxmLGcpKkJ9fX19KGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PXI/cjpcIlwiLGk9ZS5yZXBsYWNlKG4sXCJcIik7cmV0dXJuIGk9KGk9aS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoWzAtOV0pXCIuY29uY2F0KEEodC50aG91c2FuZHMpLFwiKFswLTldKVwiKSxcImdcIiksXCIkMSQyXCIpKS5yZXBsYWNlKHQuZGVjaW1hbCxcIi5cIil9KGUsdCx1KSx0LHUsYyxzLGwsZil9ZS5leHBvcnRzPXt1bmZvcm1hdDpmdW5jdGlvbihlLHQpe3ZhciByLG4saSxhPWcoXCIuL2dsb2JhbFN0YXRlXCIpLG89YS5jdXJyZW50RGVsaW1pdGVycygpLHU9YS5jdXJyZW50Q3VycmVuY3koKS5zeW1ib2wsYz1hLmN1cnJlbnRPcmRpbmFsKCkscz1hLmdldFplcm9Gb3JtYXQoKSxsPWEuY3VycmVudEFiYnJldmlhdGlvbnMoKSxmPXZvaWQgMDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlmPWZ1bmN0aW9uKGUsdCl7aWYoZS5pbmRleE9mKFwiOlwiKSYmXCI6XCIhPT10LnRob3VzYW5kcyl7dmFyIHI9ZS5zcGxpdChcIjpcIik7aWYoMz09PXIubGVuZ3RoKXt2YXIgbj0rclswXSxpPStyWzFdLGE9K3JbMl07cmV0dXJuIWlzTmFOKG4pJiYhaXNOYU4oaSkmJiFpc05hTihhKX19fShlLG8pPyhyPWUuc3BsaXQoXCI6XCIpLG49K3JbMF0saT0rclsxXSwrclsyXSs2MCppKzM2MDAqbik6cChlLG8sdSxjLHMsbCx0KTtlbHNle2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXJldHVybjtmPWV9aWYodm9pZCAwIT09ZilyZXR1cm4gZn19fSx7XCIuL2dsb2JhbFN0YXRlXCI6NH1dLDEwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAscj1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKXJbdF09ZVt0XTtyZXR1cm4gcn19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gZihlKXtyZXR1cm4oZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9dmFyIGk9ZShcIi4vdW5mb3JtYXR0aW5nXCIpLGE9L15bYS16XXsyLDN9KC1bYS16QS1aXXs0fSk/KC0oW0EtWl17Mn18WzAtOV17M30pKT8kLyxnPXtvdXRwdXQ6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJjdXJyZW5jeVwiLFwicGVyY2VudFwiLFwiYnl0ZVwiLFwidGltZVwiLFwib3JkaW5hbFwiLFwibnVtYmVyXCJdfSxiYXNlOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wiZGVjaW1hbFwiLFwiYmluYXJ5XCIsXCJnZW5lcmFsXCJdLHJlc3RyaWN0aW9uOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJieXRlXCI9PT10Lm91dHB1dH0sbWVzc2FnZTpcImBiYXNlYCBtdXN0IGJlIHByb3ZpZGVkIG9ubHkgd2hlbiB0aGUgb3V0cHV0IGlzIGBieXRlYFwiLG1hbmRhdG9yeTpmdW5jdGlvbihlKXtyZXR1cm5cImJ5dGVcIj09PWUub3V0cHV0fX0sY2hhcmFjdGVyaXN0aWM6e3R5cGU6XCJudW1iZXJcIixyZXN0cmljdGlvbjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZX0sbWVzc2FnZTpcInZhbHVlIG11c3QgYmUgcG9zaXRpdmVcIn0scHJlZml4Olwic3RyaW5nXCIscG9zdGZpeDpcInN0cmluZ1wiLGZvcmNlQXZlcmFnZTp7dHlwZTpcInN0cmluZ1wiLHZhbGlkVmFsdWVzOltcInRyaWxsaW9uXCIsXCJiaWxsaW9uXCIsXCJtaWxsaW9uXCIsXCJ0aG91c2FuZFwiXX0sYXZlcmFnZTpcImJvb2xlYW5cIixsb3dQcmVjaXNpb246e3R5cGU6XCJib29sZWFuXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4hMD09PXQuYXZlcmFnZX0sbWVzc2FnZTpcImBsb3dQcmVjaXNpb25gIG11c3QgYmUgcHJvdmlkZWQgb25seSB3aGVuIHRoZSBvcHRpb24gYGF2ZXJhZ2VgIGlzIHNldFwifSxjdXJyZW5jeVBvc2l0aW9uOnt0eXBlOlwic3RyaW5nXCIsdmFsaWRWYWx1ZXM6W1wicHJlZml4XCIsXCJpbmZpeFwiLFwicG9zdGZpeFwiXX0sY3VycmVuY3lTeW1ib2w6XCJzdHJpbmdcIix0b3RhbExlbmd0aDp7dHlwZTpcIm51bWJlclwiLHJlc3RyaWN0aW9uczpbe3Jlc3RyaWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lfSxtZXNzYWdlOlwidmFsdWUgbXVzdCBiZSBwb3NpdGl2ZVwifSx7cmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm4hdC5leHBvbmVudGlhbH0sbWVzc2FnZTpcImB0b3RhbExlbmd0aGAgaXMgaW5jb21wYXRpYmxlIHdpdGggYGV4cG9uZW50aWFsYFwifV19LG1hbnRpc3NhOnt0eXBlOlwibnVtYmVyXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWV9LG1lc3NhZ2U6XCJ2YWx1ZSBtdXN0IGJlIHBvc2l0aXZlXCJ9LG9wdGlvbmFsTWFudGlzc2E6XCJib29sZWFuXCIsdHJpbU1hbnRpc3NhOlwiYm9vbGVhblwiLHJvdW5kaW5nRnVuY3Rpb246XCJmdW5jdGlvblwiLG9wdGlvbmFsQ2hhcmFjdGVyaXN0aWM6XCJib29sZWFuXCIsdGhvdXNhbmRTZXBhcmF0ZWQ6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWQ6XCJib29sZWFuXCIsc3BhY2VTZXBhcmF0ZWRDdXJyZW5jeTpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZEFiYnJldmlhdGlvbjpcImJvb2xlYW5cIixhYmJyZXZpYXRpb25zOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3Rob3VzYW5kOlwic3RyaW5nXCIsbWlsbGlvbjpcInN0cmluZ1wiLGJpbGxpb246XCJzdHJpbmdcIix0cmlsbGlvbjpcInN0cmluZ1wifX0sbmVnYXRpdmU6e3R5cGU6XCJzdHJpbmdcIix2YWxpZFZhbHVlczpbXCJzaWduXCIsXCJwYXJlbnRoZXNpc1wiXX0sZm9yY2VTaWduOlwiYm9vbGVhblwiLGV4cG9uZW50aWFsOnt0eXBlOlwiYm9vbGVhblwifSxwcmVmaXhTeW1ib2w6e3R5cGU6XCJib29sZWFuXCIscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInBlcmNlbnRcIj09PXQub3V0cHV0fSxtZXNzYWdlOlwiYHByZWZpeFN5bWJvbGAgY2FuIGJlIHByb3ZpZGVkIG9ubHkgd2hlbiB0aGUgb3V0cHV0IGlzIGBwZXJjZW50YFwifX0sbz17bGFuZ3VhZ2VUYWc6e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITAscmVzdHJpY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIGUubWF0Y2goYSl9LG1lc3NhZ2U6XCJ0aGUgbGFuZ3VhZ2UgdGFnIG11c3QgZm9sbG93IHRoZSBCQ1AgNDcgc3BlY2lmaWNhdGlvbiAoc2VlIGh0dHBzOi8vdG9vbHMuaWVmdC5vcmcvaHRtbC9iY3A0NylcIn0sZGVsaW1pdGVyczp7dHlwZTpcIm9iamVjdFwiLGNoaWxkcmVuOnt0aG91c2FuZHM6XCJzdHJpbmdcIixkZWNpbWFsOlwic3RyaW5nXCIsdGhvdXNhbmRzU2l6ZTpcIm51bWJlclwifSxtYW5kYXRvcnk6ITB9LGFiYnJldmlhdGlvbnM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7dGhvdXNhbmQ6e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LG1pbGxpb246e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LGJpbGxpb246e3R5cGU6XCJzdHJpbmdcIixtYW5kYXRvcnk6ITB9LHRyaWxsaW9uOnt0eXBlOlwic3RyaW5nXCIsbWFuZGF0b3J5OiEwfX0sbWFuZGF0b3J5OiEwfSxzcGFjZVNlcGFyYXRlZDpcImJvb2xlYW5cIixzcGFjZVNlcGFyYXRlZEN1cnJlbmN5OlwiYm9vbGVhblwiLG9yZGluYWw6e3R5cGU6XCJmdW5jdGlvblwiLG1hbmRhdG9yeTohMH0sYnl0ZXM6e3R5cGU6XCJvYmplY3RcIixjaGlsZHJlbjp7YmluYXJ5U3VmZml4ZXM6XCJvYmplY3RcIixkZWNpbWFsU3VmZml4ZXM6XCJvYmplY3RcIn19LGN1cnJlbmN5Ont0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e3N5bWJvbDpcInN0cmluZ1wiLHBvc2l0aW9uOlwic3RyaW5nXCIsY29kZTpcInN0cmluZ1wifSxtYW5kYXRvcnk6ITB9LGRlZmF1bHRzOlwiZm9ybWF0XCIsb3JkaW5hbEZvcm1hdDpcImZvcm1hdFwiLGJ5dGVGb3JtYXQ6XCJmb3JtYXRcIixwZXJjZW50YWdlRm9ybWF0OlwiZm9ybWF0XCIsY3VycmVuY3lGb3JtYXQ6XCJmb3JtYXRcIix0aW1lRGVmYXVsdHM6XCJmb3JtYXRcIixmb3JtYXRzOnt0eXBlOlwib2JqZWN0XCIsY2hpbGRyZW46e2ZvdXJEaWdpdHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9LGZ1bGxXaXRoVHdvRGVjaW1hbHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9LGZ1bGxXaXRoVHdvRGVjaW1hbHNOb0N1cnJlbmN5Ont0eXBlOlwiZm9ybWF0XCIsbWFuZGF0b3J5OiEwfSxmdWxsV2l0aE5vRGVjaW1hbHM6e3R5cGU6XCJmb3JtYXRcIixtYW5kYXRvcnk6ITB9fX19O2Z1bmN0aW9uIHUoZSl7cmV0dXJuIHZvaWQgMCE9PWkudW5mb3JtYXQoZSl9ZnVuY3Rpb24gcChjLHMsbCxlKXt2YXIgdD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWUmJmUscj1PYmplY3Qua2V5cyhjKS5tYXAoZnVuY3Rpb24oZSl7aWYoIXNbZV0pcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBJbnZhbGlkIGtleTogXCIpLmNvbmNhdChlKSksITE7dmFyIHQ9Y1tlXSxyPXNbZV07aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJihyPXt0eXBlOnJ9KSxcImZvcm1hdFwiPT09ci50eXBlKXtpZighcCh0LGcsXCJbVmFsaWRhdGUgXCIuY29uY2F0KGUsXCJdXCIpLCEwKSlyZXR1cm4hMX1lbHNlIGlmKGYodCkhPT1yLnR5cGUpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsJyB0eXBlIG1pc21hdGNoZWQ6IFwiJykuY29uY2F0KHIudHlwZSwnXCIgZXhwZWN0ZWQsIFwiJykuY29uY2F0KGYodCksJ1wiIHByb3ZpZGVkJykpLCExO2lmKHIucmVzdHJpY3Rpb25zJiZyLnJlc3RyaWN0aW9ucy5sZW5ndGgpZm9yKHZhciBuPXIucmVzdHJpY3Rpb25zLmxlbmd0aCxpPTA7aTxuO2krKyl7dmFyIGE9ci5yZXN0cmljdGlvbnNbaV0sbz1hLnJlc3RyaWN0aW9uLHU9YS5tZXNzYWdlO2lmKCFvKHQsYykpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCxcIiBcIikuY29uY2F0KGUsXCIgaW52YWxpZCB2YWx1ZTogXCIpLmNvbmNhdCh1KSksITF9aWYoci5yZXN0cmljdGlvbiYmIXIucmVzdHJpY3Rpb24odCxjKSlyZXR1cm4gY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChsLFwiIFwiKS5jb25jYXQoZSxcIiBpbnZhbGlkIHZhbHVlOiBcIikuY29uY2F0KHIubWVzc2FnZSkpLCExO2lmKHIudmFsaWRWYWx1ZXMmJi0xPT09ci52YWxpZFZhbHVlcy5pbmRleE9mKHQpKXJldHVybiBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChlLFwiIGludmFsaWQgdmFsdWU6IG11c3QgYmUgYW1vbmcgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShyLnZhbGlkVmFsdWVzKSwnLCBcIicpLmNvbmNhdCh0LCdcIiBwcm92aWRlZCcpKSwhMTtpZihyLmNoaWxkcmVuJiYhcCh0LHIuY2hpbGRyZW4sXCJbVmFsaWRhdGUgXCIuY29uY2F0KGUsXCJdXCIpKSlyZXR1cm4hMTtyZXR1cm4hMH0pO3JldHVybiB0fHxyLnB1c2guYXBwbHkocixuKE9iamVjdC5rZXlzKHMpLm1hcChmdW5jdGlvbihlKXt2YXIgdD1zW2VdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD17dHlwZTp0fSksdC5tYW5kYXRvcnkpe3ZhciByPXQubWFuZGF0b3J5O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJihyPXIoYykpLHImJnZvaWQgMD09PWNbZV0pcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQobCwnIE1pc3NpbmcgbWFuZGF0b3J5IGtleSBcIicpLmNvbmNhdChlLCdcIicpKSwhMX1yZXR1cm4hMH0pKSksci5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSYmdH0sITApfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIHAoZSxnLFwiW1ZhbGlkYXRlIGZvcm1hdF1cIil9dC5leHBvcnRzPXt2YWxpZGF0ZTpmdW5jdGlvbihlLHQpe3ZhciByPXUoZSksbj1jKHQpO3JldHVybiByJiZufSx2YWxpZGF0ZUZvcm1hdDpjLHZhbGlkYXRlSW5wdXQ6dSx2YWxpZGF0ZUxhbmd1YWdlOmZ1bmN0aW9uKGUpe3JldHVybiBwKGUsbyxcIltWYWxpZGF0ZSBsYW5ndWFnZV1cIil9fX0se1wiLi91bmZvcm1hdHRpbmdcIjo5fV19LHt9LFs3XSkoNyl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJyby5taW4uanMubWFwXG4iLCIvLyBAdHMtbm9jaGVja1xuaW1wb3J0IG51bWJybyBmcm9tICdudW1icm8nO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgZm9ybWF0LCBzaG93TnVtYmVyU2NhbGUgPSB0cnVlKSB7XG4gIGxldCBudW1iZXJGb3JtYXRPcHRpb25zID0gZ2V0Rm9ybWF0T3B0aW9ucyhmb3JtYXQpO1xuICBsZXQgaXNDdXN0b21Sb3VuZCA9IHRydWU7XG5cbiAgLy8gbnVtYnJvLnJlZ2lzdGVyTGFuZ3VhZ2UoZml4TnVtYnJvKG51bWJyb19lblVTKSk7IC8vIE5PVEU6IHRoaXMgZml4ZXMgYW4gaXNzdWUgd2hlcmUgZW4tVVMgaXMgcmVzZXQgdG8gZGVmYXVsdCBpbiBoYW5kc29udGFibGVcblxuICBjb25zdCB7XG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBpc1Rob3VzYW5kc1NlcGFyYXRlZCA9IGZhbHNlLFxuICAgIHByZWZpeCA9ICcnLFxuICAgIHN1ZmZpeCA9ICcnLFxuICAgIGlzUGVyY2VudCA9IGZhbHNlXG4gIH0gPSBudW1iZXJGb3JtYXRPcHRpb25zID8/IHt9O1xuXG4gIGNvbnN0IHNob3dBdmVyYWdlID0gc2hvd051bWJlclNjYWxlICE9PSBmYWxzZTtcbiAgY29uc3QgbnVtYnJvT3B0aW9ucyA9IHtcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBwb3N0Zml4OiBzdWZmaXgsXG4gICAgdGhvdXNhbmRTZXBhcmF0ZWQ6IGlzVGhvdXNhbmRzU2VwYXJhdGVkLFxuICAgIG91dHB1dDogaXNQZXJjZW50ID8gJ3BlcmNlbnQnIDogJ251bWJlcicsXG4gICAgYXZlcmFnZTogc2hvd0F2ZXJhZ2VcbiAgfTtcblxuICBjb25zdCBhYnNOdW0gPSBNYXRoLmFicyhudW1iZXIpO1xuICBpZiAoZGVjaW1hbFBsYWNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IGRlY2ltYWxQbGFjZXM7XG4gICAgaWYgKGRlY2ltYWxQbGFjZXMgPT09IDAgJiYgaXNDdXN0b21Sb3VuZCkge1xuICAgICAgbnVtYnJvT3B0aW9ucy50cmltTWFudGlzc2EgPSB0cnVlOyAvLyBOT1RFOiBjYW4gYWRkIFwiJiYgYWJzTnVtIDwgMVwiIHdpdGhvdXQgdHJpbU1hbnRpc3NhLCBidXQgb2xkLWxvZ2ljIGZvcmNlIDItZGVjaW1hbHMgKGluY2FzZSBmcmFjdGlvbnMgZXhpc3QpIHdoZW4gaXNDdXN0b21Sb3VuZFxuICAgICAgaWYgKGFic051bSA+PSAwLjEpIHtcbiAgICAgICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IDI7XG4gICAgICB9IGVsc2UgaWYgKGFic051bSA+PSAwLjAxKSB7XG4gICAgICAgIG51bWJyb09wdGlvbnMubWFudGlzc2EgPSAzO1xuICAgICAgfSBlbHNlIGlmIChhYnNOdW0gPj0gMC4wMDEpIHtcbiAgICAgICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IDU7XG4gICAgICB9IGVsc2UgaWYgKGFic051bSA+PSAwLjAwMDEpIHtcbiAgICAgICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IDY7XG4gICAgICB9IGVsc2UgaWYgKGFic051bSA+PSAwLjAwMDAxKSB7XG4gICAgICAgIG51bWJyb09wdGlvbnMubWFudGlzc2EgPSA3O1xuICAgICAgfSBlbHNlIGlmIChhYnNOdW0gPj0gMC4wMDAwMDEpIHtcbiAgICAgICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IDg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRml4IG1hbnRpc3NhIGluY2FzZSBvZiBzaG93QXZlcmFnZVxuICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdW5kZWZpbmVkICYmIHNob3dBdmVyYWdlKSB7XG4gICAgbnVtYnJvT3B0aW9ucy5tYW50aXNzYSA9IE1BWF9NQU5USVNTQTtcbiAgICBudW1icm9PcHRpb25zLnRyaW1NYW50aXNzYSA9IHRydWU7XG4gIH1cblxuICAvLyBGb3JjZSBhdmVyYWdlIHNlbGVjdGlvblxuICBpZiAoc2hvd0F2ZXJhZ2UpIHtcbiAgICBjb25zdCBOdW1iZXJTY2FsZXMgPSBbXG4gICAgICB7IGtleTogJ3RyaWxsaW9uJywgdmFsdWU6IDEwMDAwMDAwMDAwMDAgfSxcbiAgICAgIHsga2V5OiAnYmlsbGlvbicsIHZhbHVlOiAxMDAwMDAwMDAwIH0sXG4gICAgICB7IGtleTogJ21pbGxpb24nLCB2YWx1ZTogMTAwMDAwMCB9LFxuICAgICAgeyBrZXk6ICd0aG91c2FuZCcsIHZhbHVlOiAxMDAwIH1cbiAgICBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTnVtYmVyU2NhbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobnVtYmVyKSA+PSBOdW1iZXJTY2FsZXNbaV0udmFsdWUpIHtcbiAgICAgICAgbnVtYnJvT3B0aW9ucy5mb3JjZUF2ZXJhZ2UgPSBOdW1iZXJTY2FsZXNbaV0ua2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtYnJvKG51bWJlcikuZm9ybWF0KG51bWJyb09wdGlvbnMpPy50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWF0T3B0aW9ucyh2YWx1ZTogc3RyaW5nKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICAvL0ZhbGxiYWNrIHRvIGRlZmF1bHQgZm9ybWF0IHRvIHByZXZlbnQgY2hhcnRzIGNyYXNoXG4gICAgLy9Mb2cgc3RhY2sgdHJhY2UgdG8gY2F0Y2ggdGhlc2Ugc2NlbmFyaW9zXG4gICAgdmFsdWUgPSAnIyMjLCMjMC4wMCc7XG4gICAgLy8gY29uc29sZS50cmFjZSgnVW5leHBlY3RlZCBlbXB0eSBmb3JtYXQgdmFsdWUnKTtcbiAgfVxuICBjb25zdCBbLCBwcmVmaXgsIHRob3VzYW5kc0Zvcm1hdCwgZGVjaW1hbEZvcm1hdCwgcGVyY2VudCwgc3VmZml4XSA9XG4gICAgL14oJ1teJ10rJ3xbXjAjLiUnO10qKShbI10qLFsjXSopPyhbMCNdKlxcLlswI10qKT8oIyolKT8oJ1teJ10rJ3xbXjAjLiUnO10qKS9nLmV4ZWModmFsdWUpID8/IFtdO1xuXG4gIGxldCBkZWNpbWFsUGxhY2VzOiBudW1iZXIgfCB1bmRlZmluZWQgPSAwOyAvLyBjYXNlIHJvdW5kZWRcbiAgaWYgKGRlY2ltYWxGb3JtYXQ/Lmxlbmd0aCkge1xuICAgIGRlY2ltYWxQbGFjZXMgPSAvXFwuKDArKS9nLmV4ZWMoZGVjaW1hbEZvcm1hdCk/LlsxXT8ubGVuZ3RoOyAvLyB2YWx1ZSBvciB1bmRlZmluZWQgKGkuZS4gYXV0byBkZWNpbWFsIHBsYWNlcylcbiAgfVxuXG4gIGNvbnN0IHVud3JhcHBlZFByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC8nL2csICcnKTtcbiAgY29uc3QgdW53cmFwcGVkU3VmZml4ID0gc3VmZml4LnJlcGxhY2UoLycvZywgJycpO1xuXG4gIHJldHVybiB7XG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBpc1Rob3VzYW5kc1NlcGFyYXRlZDogISF0aG91c2FuZHNGb3JtYXQsXG4gICAgcHJlZml4OiB1bndyYXBwZWRQcmVmaXgsXG4gICAgc3VmZml4OiB1bndyYXBwZWRTdWZmaXgsXG4gICAgaXNQZXJjZW50OiAhIXBlcmNlbnRcbiAgfTtcbn1cblxuLy8gZnVuY3Rpb24gZml4TnVtYnJvKGxhbmc6IGFueSkge1xuLy8gICBjb25zdCBhYmJyZXZpYXRpb25zID0gT2JqZWN0LmtleXMobGFuZy5hYmJyZXZpYXRpb25zKS5yZWR1Y2U8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4oXG4vLyAgICAgKGFjYywga2V5KSA9PiB7XG4vLyAgICAgICBjb25zdCBuZXdWYWwgPVxuLy8gICAgICAgICBsYW5nLmFiYnJldmlhdGlvbnNba2V5XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxhbmcuYWJicmV2aWF0aW9uc1trZXldLnNsaWNlKDEpO1xuLy8gICAgICAgYWNjW2tleV0gPSBuZXdWYWw7XG4vLyAgICAgICByZXR1cm4gYWNjO1xuLy8gICAgIH0sXG4vLyAgICAge31cbi8vICAgKTtcbi8vICAgcmV0dXJuIHsgLi4ubGFuZywgYWJicmV2aWF0aW9ucyB9O1xuLy8gfVxuIiwiLyohXG4gKiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIHYxLjAuMFxuICogaHR0cHM6Ly9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLm5ldGxpZnkuYXBwXG4gKiAoYykgMjAxNy0yMDIxIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdjaGFydC5qcycpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydjaGFydC5qcyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ2hhcnREYXRhTGFiZWxzID0gZmFjdG9yeShnbG9iYWwuQ2hhcnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChDaGFydCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgQ2hhcnRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KENoYXJ0KTtcblxudmFyIGhlbHBlcnMkNCA9IENoYXJ0X19kZWZhdWx0WydkZWZhdWx0J10uaGVscGVycztcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIC8vIGRldmljZVBpeGVsUmF0aW8gaXMgdW5kZWZpbmVkIG9uIElFMTBcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMDQxODAvODgzNzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XG4gICAgdmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbikge1xuICAgICAgcmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59KCkpO1xuXG52YXIgdXRpbHMgPSB7XG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICBpbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzKTtcbiAgICB3aGlsZSAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgaW5wdXQgPSBpbnB1dHMucG9wKCk7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsaW5lcy51bnNoaWZ0LmFwcGx5KGxpbmVzLCBpbnB1dC5zcGxpdCgnXFxuJykpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWhlbHBlcnMkNC5pc051bGxPclVuZGVmKGlucHV0cykpIHtcbiAgICAgICAgbGluZXMudW5zaGlmdCgnJyArIGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH0sXG5cbiAgLy8gQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLmNhbnZhcy50b0ZvbnQgKGRlcHJlY2F0ZXMgaGVscGVycy5mb250U3RyaW5nKVxuICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gIHRvRm9udFN0cmluZzogZnVuY3Rpb24oZm9udCkge1xuICAgIGlmICghZm9udCB8fCBoZWxwZXJzJDQuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnMkNC5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuICAgICAgKyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuICAgICAgKyBmb250LnNpemUgKyAncHggJ1xuICAgICAgKyBmb250LmZhbWlseTtcbiAgfSxcblxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG4gIHRleHRTaXplOiBmdW5jdGlvbihjdHgsIGxpbmVzLCBmb250KSB7XG4gICAgdmFyIGl0ZW1zID0gW10uY29uY2F0KGxpbmVzKTtcbiAgICB2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgcHJldiA9IGN0eC5mb250O1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGk7XG5cbiAgICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChjdHgubWVhc3VyZVRleHQoaXRlbXNbaV0pLndpZHRoLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZvbnQgPSBwcmV2O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogaWxlbiAqIGZvbnQubGluZUhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aFxuICAgIH07XG4gIH0sXG5cbiAgLy8gQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLm9wdGlvbnMudG9Gb250XG4gIHBhcnNlRm9udDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZ2xvYmFsID0gQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5kZWZhdWx0cy5nbG9iYWw7XG4gICAgdmFyIHNpemUgPSBoZWxwZXJzJDQudmFsdWVPckRlZmF1bHQodmFsdWUuc2l6ZSwgZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG4gICAgdmFyIGZvbnQgPSB7XG4gICAgICBmYW1pbHk6IGhlbHBlcnMkNC52YWx1ZU9yRGVmYXVsdCh2YWx1ZS5mYW1pbHksIGdsb2JhbC5kZWZhdWx0Rm9udEZhbWlseSksXG4gICAgICBsaW5lSGVpZ2h0OiBoZWxwZXJzJDQub3B0aW9ucy50b0xpbmVIZWlnaHQodmFsdWUubGluZUhlaWdodCwgc2l6ZSksXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgc3R5bGU6IGhlbHBlcnMkNC52YWx1ZU9yRGVmYXVsdCh2YWx1ZS5zdHlsZSwgZ2xvYmFsLmRlZmF1bHRGb250U3R5bGUpLFxuICAgICAgd2VpZ2h0OiBoZWxwZXJzJDQudmFsdWVPckRlZmF1bHQodmFsdWUud2VpZ2h0LCBudWxsKSxcbiAgICAgIHN0cmluZzogJydcbiAgICB9O1xuXG4gICAgZm9udC5zdHJpbmcgPSB1dGlscy50b0ZvbnRTdHJpbmcoZm9udCk7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuICAgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG4gICAqL1xuICBib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG4gICAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuICAgKi9cbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcbiAgICB2YXIgcHJldiA9IGEwLnNsaWNlKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBbXTtcbiAgICB2YXIgaSwgaiwgaWxlbiwgdjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhMS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHYgPSBhMVtpXTtcbiAgICAgIGogPSBwcmV2LmluZGV4T2Yodik7XG5cbiAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICB1cGRhdGVzLnB1c2goW3YsIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwcmV2Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdXBkYXRlcy5wdXNoKFtwcmV2W2ldLCAtMV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuICAgKi9cbiAgcmFzdGVyaXplOiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JpZW50KHBvaW50LCBvcmlnaW4pIHtcbiAgdmFyIHgwID0gb3JpZ2luLng7XG4gIHZhciB5MCA9IG9yaWdpbi55O1xuXG4gIGlmICh4MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMCwgeTogLTF9O1xuICB9XG4gIGlmICh5MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMSwgeTogMH07XG4gIH1cblxuICB2YXIgZHggPSBwb2ludC54IC0geDA7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5MDtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICByZXR1cm4ge1xuICAgIHg6IGxuID8gZHggLyBsbiA6IDAsXG4gICAgeTogbG4gPyBkeSAvIGxuIDogLTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25lZCh4LCB5LCB2eCwgdnksIGFsaWduKSB7XG4gIHN3aXRjaCAoYWxpZ24pIHtcbiAgY2FzZSAnY2VudGVyJzpcbiAgICB2eCA9IHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnYm90dG9tJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAxO1xuICAgIGJyZWFrO1xuICBjYXNlICdyaWdodCc6XG4gICAgdnggPSAxO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnbGVmdCc6XG4gICAgdnggPSAtMTtcbiAgICB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RvcCc6XG4gICAgdnggPSAwO1xuICAgIHZ5ID0gLTE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXJ0JzpcbiAgICB2eCA9IC12eDtcbiAgICB2eSA9IC12eTtcbiAgICBicmVhaztcbiAgY2FzZSAnZW5kJzpcbiAgICAvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICAvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcbiAgICBhbGlnbiAqPSAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdnggPSBNYXRoLmNvcyhhbGlnbik7XG4gICAgdnkgPSBNYXRoLnNpbihhbGlnbik7XG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB2eDogdngsXG4gICAgdnk6IHZ5XG4gIH07XG59XG5cbi8vIExpbmUgY2xpcHBpbmcgKENvaGVu4oCTU3V0aGVybGFuZCBhbGdvcml0aG0pXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbuKAk1N1dGhlcmxhbmRfYWxnb3JpdGhtXG5cbnZhciBSX0lOU0lERSA9IDA7XG52YXIgUl9MRUZUID0gMTtcbnZhciBSX1JJR0hUID0gMjtcbnZhciBSX0JPVFRPTSA9IDQ7XG52YXIgUl9UT1AgPSA4O1xuXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xuICB2YXIgcmVzID0gUl9JTlNJREU7XG5cbiAgaWYgKHggPCByZWN0LmxlZnQpIHtcbiAgICByZXMgfD0gUl9MRUZUO1xuICB9IGVsc2UgaWYgKHggPiByZWN0LnJpZ2h0KSB7XG4gICAgcmVzIHw9IFJfUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCByZWN0LnRvcCkge1xuICAgIHJlcyB8PSBSX1RPUDtcbiAgfSBlbHNlIGlmICh5ID4gcmVjdC5ib3R0b20pIHtcbiAgICByZXMgfD0gUl9CT1RUT007XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjbGlwcGVkKHNlZ21lbnQsIGFyZWEpIHtcbiAgdmFyIHgwID0gc2VnbWVudC54MDtcbiAgdmFyIHkwID0gc2VnbWVudC55MDtcbiAgdmFyIHgxID0gc2VnbWVudC54MTtcbiAgdmFyIHkxID0gc2VnbWVudC55MTtcbiAgdmFyIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG4gIHZhciByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICB2YXIgciwgeCwgeTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCEocjAgfCByMSkgfHwgKHIwICYgcjEpKSB7XG4gICAgICAvLyBib3RoIHBvaW50cyBpbnNpZGUgb3Igb24gdGhlIHNhbWUgc2lkZTogbm8gY2xpcHBpbmdcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXG4gICAgciA9IHIwIHx8IHIxO1xuXG4gICAgaWYgKHIgJiBSX1RPUCkge1xuICAgICAgeCA9IHgwICsgKHgxIC0geDApICogKGFyZWEudG9wIC0geTApIC8gKHkxIC0geTApO1xuICAgICAgeSA9IGFyZWEudG9wO1xuICAgIH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS5ib3R0b20gLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEucmlnaHQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcbiAgICAgIHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLmxlZnQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChyID09PSByMCkge1xuICAgICAgeDAgPSB4O1xuICAgICAgeTAgPSB5O1xuICAgICAgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDEgPSB4O1xuICAgICAgeTEgPSB5O1xuICAgICAgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHgwOiB4MCxcbiAgICB4MTogeDEsXG4gICAgeTA6IHkwLFxuICAgIHkxOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlJDEocmFuZ2UsIGNvbmZpZykge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmFuY2hvcjtcbiAgdmFyIHNlZ21lbnQgPSByYW5nZTtcbiAgdmFyIHgsIHk7XG5cbiAgaWYgKGNvbmZpZy5jbGFtcCkge1xuICAgIHNlZ21lbnQgPSBjbGlwcGVkKHNlZ21lbnQsIGNvbmZpZy5hcmVhKTtcbiAgfVxuXG4gIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICB4ID0gc2VnbWVudC54MDtcbiAgICB5ID0gc2VnbWVudC55MDtcbiAgfSBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgeCA9IHNlZ21lbnQueDE7XG4gICAgeSA9IHNlZ21lbnQueTE7XG4gIH0gZWxzZSB7XG4gICAgeCA9IChzZWdtZW50LngwICsgc2VnbWVudC54MSkgLyAyO1xuICAgIHkgPSAoc2VnbWVudC55MCArIHNlZ21lbnQueTEpIC8gMjtcbiAgfVxuXG4gIHJldHVybiBhbGlnbmVkKHgsIHksIHJhbmdlLnZ4LCByYW5nZS52eSwgY29uZmlnLmFsaWduKTtcbn1cblxudmFyIHBvc2l0aW9uZXJzID0ge1xuICBhcmM6IGZ1bmN0aW9uKHZtLCBjb25maWcpIHtcbiAgICB2YXIgYW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIHZ4ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB2eSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgcjAgPSB2bS5pbm5lclJhZGl1cztcbiAgICB2YXIgcjEgPSB2bS5vdXRlclJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IHZtLnggKyB2eCAqIHIwLFxuICAgICAgeTA6IHZtLnkgKyB2eSAqIHIwLFxuICAgICAgeDE6IHZtLnggKyB2eCAqIHIxLFxuICAgICAgeTE6IHZtLnkgKyB2eSAqIHIxLFxuICAgICAgdng6IHZ4LFxuICAgICAgdnk6IHZ5XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBwb2ludDogZnVuY3Rpb24odm0sIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KHZtLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgcnggPSB2LnggKiB2bS5yYWRpdXM7XG4gICAgdmFyIHJ5ID0gdi55ICogdm0ucmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogdm0ueCAtIHJ4LFxuICAgICAgeTA6IHZtLnkgLSByeSxcbiAgICAgIHgxOiB2bS54ICsgcngsXG4gICAgICB5MTogdm0ueSArIHJ5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIHJlY3Q6IGZ1bmN0aW9uKHZtLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudCh2bSwgY29uZmlnLm9yaWdpbik7XG4gICAgdmFyIHggPSB2bS54O1xuICAgIHZhciB5ID0gdm0ueTtcbiAgICB2YXIgc3ggPSAwO1xuICAgIHZhciBzeSA9IDA7XG5cbiAgICBpZiAodm0uaG9yaXpvbnRhbCkge1xuICAgICAgeCA9IE1hdGgubWluKHZtLngsIHZtLmJhc2UpO1xuICAgICAgc3ggPSBNYXRoLmFicyh2bS5iYXNlIC0gdm0ueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcbiAgICAgIHN5ID0gTWF0aC5hYnModm0uYmFzZSAtIHZtLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IHgsXG4gICAgICB5MDogeSArIHN5LFxuICAgICAgeDE6IHggKyBzeCxcbiAgICAgIHkxOiB5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbih2bSwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQodm0sIGNvbmZpZy5vcmlnaW4pO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogdm0ueCxcbiAgICAgIHkwOiB2bS55LFxuICAgICAgeDE6IHZtLngsXG4gICAgICB5MTogdm0ueSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfVxufTtcblxudmFyIGhlbHBlcnMkMyA9IENoYXJ0X19kZWZhdWx0WydkZWZhdWx0J10uaGVscGVycztcbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMobW9kZWwpIHtcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcbiAgdmFyIHBhZGRpbmcgPSBtb2RlbC5wYWRkaW5nO1xuICB2YXIgdGggPSBtb2RlbC5zaXplLmhlaWdodDtcbiAgdmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcbiAgdmFyIHR4ID0gLXR3IC8gMjtcbiAgdmFyIHR5ID0gLXRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIGZyYW1lOiB7XG4gICAgICB4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxuICAgICAgeTogdHkgLSBwYWRkaW5nLnRvcCAtIGJvcmRlcldpZHRoLFxuICAgICAgdzogdHcgKyBwYWRkaW5nLndpZHRoICsgYm9yZGVyV2lkdGggKiAyLFxuICAgICAgaDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgeDogdHgsXG4gICAgICB5OiB0eSxcbiAgICAgIHc6IHR3LFxuICAgICAgaDogdGhcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlT3JpZ2luKGVsKSB7XG4gIHZhciBob3Jpem9udGFsID0gZWwuX21vZGVsLmhvcml6b250YWw7XG4gIHZhciBzY2FsZSA9IGVsLl9zY2FsZSB8fCAoaG9yaXpvbnRhbCAmJiBlbC5feFNjYWxlKSB8fCBlbC5feVNjYWxlO1xuXG4gIGlmICghc2NhbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzY2FsZS54Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgc2NhbGUueUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcbiAgfVxuXG4gIHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICByZXR1cm4gaG9yaXpvbnRhbCA/XG4gICAge3g6IHBpeGVsLCB5OiBudWxsfSA6XG4gICAge3g6IG51bGwsIHk6IHBpeGVsfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xuICBpZiAoZWwgaW5zdGFuY2VvZiBDaGFydF9fZGVmYXVsdFsnZGVmYXVsdCddLmVsZW1lbnRzLkFyYykge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5hcmM7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5lbGVtZW50cy5Qb2ludCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5wb2ludDtcbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBDaGFydF9fZGVmYXVsdFsnZGVmYXVsdCddLmVsZW1lbnRzLlJlY3RhbmdsZSkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5yZWN0O1xuICB9XG4gIHJldHVybiBwb3NpdGlvbmVycy5mYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZHJhd0ZyYW1lKGN0eCwgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciBib3JkZXJDb2xvciA9IG1vZGVsLmJvcmRlckNvbG9yO1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aDtcblxuICBpZiAoIWJnQ29sb3IgJiYgKCFib3JkZXJDb2xvciB8fCAhYm9yZGVyV2lkdGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGhlbHBlcnMkMy5jYW52YXMucm91bmRlZFJlY3QoXG4gICAgY3R4LFxuICAgIHJhc3Rlcml6ZShyZWN0LngpICsgYm9yZGVyV2lkdGggLyAyLFxuICAgIHJhc3Rlcml6ZShyZWN0LnkpICsgYm9yZGVyV2lkdGggLyAyLFxuICAgIHJhc3Rlcml6ZShyZWN0LncpIC0gYm9yZGVyV2lkdGgsXG4gICAgcmFzdGVyaXplKHJlY3QuaCkgLSBib3JkZXJXaWR0aCxcbiAgICBtb2RlbC5ib3JkZXJSYWRpdXMpO1xuXG4gIGN0eC5jbG9zZVBhdGgoKTtcblxuICBpZiAoYmdDb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBpZiAoYm9yZGVyQ29sb3IgJiYgYm9yZGVyV2lkdGgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KSB7XG4gIHZhciBoID0gZm9udC5saW5lSGVpZ2h0O1xuICB2YXIgdyA9IHJlY3QudztcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55ICsgaCAvIDI7XG5cbiAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggKz0gdyAvIDI7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnIHx8IGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSB3O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoOiBoLFxuICAgIHc6IHcsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0TGluZShjdHgsIHRleHQsIGNmZykge1xuICB2YXIgc2hhZG93ID0gY3R4LnNoYWRvd0JsdXI7XG4gIHZhciBzdHJva2VkID0gY2ZnLnN0cm9rZWQ7XG4gIHZhciB4ID0gcmFzdGVyaXplKGNmZy54KTtcbiAgdmFyIHkgPSByYXN0ZXJpemUoY2ZnLnkpO1xuICB2YXIgdyA9IHJhc3Rlcml6ZShjZmcudyk7XG5cbiAgaWYgKHN0cm9rZWQpIHtcbiAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5LCB3KTtcbiAgfVxuXG4gIGlmIChjZmcuZmlsbGVkKSB7XG4gICAgaWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG4gICAgICAvLyBQcmV2ZW50IGRyYXdpbmcgc2hhZG93IG9uIGJvdGggdGhlIHRleHQgc3Ryb2tlIGFuZCBmaWxsLCBzb1xuICAgICAgLy8gaWYgdGhlIHRleHQgaXMgc3Ryb2tlZCwgcmVtb3ZlIHRoZSBzaGFkb3cgZm9yIHRoZSB0ZXh0IGZpbGwuXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHksIHcpO1xuXG4gICAgaWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1RleHQoY3R4LCBsaW5lcywgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGFsaWduID0gbW9kZWwudGV4dEFsaWduO1xuICB2YXIgY29sb3IgPSBtb2RlbC5jb2xvcjtcbiAgdmFyIGZpbGxlZCA9ICEhY29sb3I7XG4gIHZhciBmb250ID0gbW9kZWwuZm9udDtcbiAgdmFyIGlsZW4gPSBsaW5lcy5sZW5ndGg7XG4gIHZhciBzdHJva2VDb2xvciA9IG1vZGVsLnRleHRTdHJva2VDb2xvcjtcbiAgdmFyIHN0cm9rZVdpZHRoID0gbW9kZWwudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgc3Ryb2tlZCA9IHN0cm9rZUNvbG9yICYmIHN0cm9rZVdpZHRoO1xuICB2YXIgaTtcblxuICBpZiAoIWlsZW4gfHwgKCFmaWxsZWQgJiYgIXN0cm9rZWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWRqdXN0IGNvb3JkaW5hdGVzIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50IGFuZCBsaW5lIGhlaWdodFxuICByZWN0ID0gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KTtcblxuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBjdHgudGV4dEFsaWduID0gYWxpZ247XG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgY3R4LnNoYWRvd0JsdXIgPSBtb2RlbC50ZXh0U2hhZG93Qmx1cjtcbiAgY3R4LnNoYWRvd0NvbG9yID0gbW9kZWwudGV4dFNoYWRvd0NvbG9yO1xuXG4gIGlmIChmaWxsZWQpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gIH1cbiAgaWYgKHN0cm9rZWQpIHtcbiAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkcmF3VGV4dExpbmUoY3R4LCBsaW5lc1tpXSwge1xuICAgICAgc3Ryb2tlZDogc3Ryb2tlZCxcbiAgICAgIGZpbGxlZDogZmlsbGVkLFxuICAgICAgdzogcmVjdC53LFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55ICsgcmVjdC5oICogaVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBMYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZywgY3R4LCBlbCwgaW5kZXgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBtZS5fY29uZmlnID0gY29uZmlnO1xuICBtZS5faW5kZXggPSBpbmRleDtcbiAgbWUuX21vZGVsID0gbnVsbDtcbiAgbWUuX3JlY3RzID0gbnVsbDtcbiAgbWUuX2N0eCA9IGN0eDtcbiAgbWUuX2VsID0gZWw7XG59O1xuXG5oZWxwZXJzJDMuZXh0ZW5kKExhYmVsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb2RlbGl6ZTogZnVuY3Rpb24oZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciByZXNvbHZlID0gaGVscGVycyQzLm9wdGlvbnMucmVzb2x2ZTtcbiAgICB2YXIgZm9udCA9IHV0aWxzLnBhcnNlRm9udChyZXNvbHZlKFtjb25maWcuZm9udCwge31dLCBjb250ZXh0LCBpbmRleCkpO1xuICAgIHZhciBjb2xvciA9IHJlc29sdmUoW2NvbmZpZy5jb2xvciwgQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcl0sIGNvbnRleHQsIGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBhbGlnbjogcmVzb2x2ZShbY29uZmlnLmFsaWduLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGFuY2hvcjogcmVzb2x2ZShbY29uZmlnLmFuY2hvciwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBhcmVhOiBjb250ZXh0LmNoYXJ0LmNoYXJ0QXJlYSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogcmVzb2x2ZShbY29uZmlnLmJhY2tncm91bmRDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlckNvbG9yOiByZXNvbHZlKFtjb25maWcuYm9yZGVyQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJSYWRpdXM6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJSYWRpdXMsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJXaWR0aDogcmVzb2x2ZShbY29uZmlnLmJvcmRlcldpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY2xhbXA6IHJlc29sdmUoW2NvbmZpZy5jbGFtcCwgZmFsc2VdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjbGlwOiByZXNvbHZlKFtjb25maWcuY2xpcCwgZmFsc2VdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBkaXNwbGF5OiBkaXNwbGF5LFxuICAgICAgZm9udDogZm9udCxcbiAgICAgIGxpbmVzOiBsaW5lcyxcbiAgICAgIG9mZnNldDogcmVzb2x2ZShbY29uZmlnLm9mZnNldCwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIG9wYWNpdHk6IHJlc29sdmUoW2NvbmZpZy5vcGFjaXR5LCAxXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgb3JpZ2luOiBnZXRTY2FsZU9yaWdpbihtZS5fZWwpLFxuICAgICAgcGFkZGluZzogaGVscGVycyQzLm9wdGlvbnMudG9QYWRkaW5nKHJlc29sdmUoW2NvbmZpZy5wYWRkaW5nLCAwXSwgY29udGV4dCwgaW5kZXgpKSxcbiAgICAgIHBvc2l0aW9uZXI6IGdldFBvc2l0aW9uZXIobWUuX2VsKSxcbiAgICAgIHJvdGF0aW9uOiByZXNvbHZlKFtjb25maWcucm90YXRpb24sIDBdLCBjb250ZXh0LCBpbmRleCkgKiAoTWF0aC5QSSAvIDE4MCksXG4gICAgICBzaXplOiB1dGlscy50ZXh0U2l6ZShtZS5fY3R4LCBsaW5lcywgZm9udCksXG4gICAgICB0ZXh0QWxpZ246IHJlc29sdmUoW2NvbmZpZy50ZXh0QWxpZ24sICdzdGFydCddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U2hhZG93Qmx1cjogcmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dCbHVyLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFNoYWRvd0NvbG9yOiByZXNvbHZlKFtjb25maWcudGV4dFNoYWRvd0NvbG9yLCBjb2xvcl0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogcmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IHJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlV2lkdGgsIDBdLCBjb250ZXh0LCBpbmRleClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG1vZGVsID0gbnVsbDtcbiAgICB2YXIgcmVjdHMgPSBudWxsO1xuICAgIHZhciBpbmRleCA9IG1lLl9pbmRleDtcbiAgICB2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcbiAgICB2YXIgdmFsdWUsIGxhYmVsLCBsaW5lcztcblxuICAgIC8vIFdlIGZpcnN0IHJlc29sdmUgdGhlIGRpc3BsYXkgb3B0aW9uIChzZXBhcmF0ZWx5KSB0byBhdm9pZCBjb21wdXRpbmdcbiAgICAvLyBvdGhlciBvcHRpb25zIGluIGNhc2UgdGhlIGxhYmVsIGlzIGhpZGRlbiAoaS5lLiBkaXNwbGF5OiBmYWxzZSkuXG4gICAgdmFyIGRpc3BsYXkgPSBoZWxwZXJzJDMub3B0aW9ucy5yZXNvbHZlKFtjb25maWcuZGlzcGxheSwgdHJ1ZV0sIGNvbnRleHQsIGluZGV4KTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICB2YWx1ZSA9IGNvbnRleHQuZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGxhYmVsID0gaGVscGVycyQzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMkMy5jYWxsYmFjayhjb25maWcuZm9ybWF0dGVyLCBbdmFsdWUsIGNvbnRleHRdKSwgdmFsdWUpO1xuICAgICAgbGluZXMgPSBoZWxwZXJzJDMuaXNOdWxsT3JVbmRlZihsYWJlbCkgPyBbXSA6IHV0aWxzLnRvVGV4dExpbmVzKGxhYmVsKTtcblxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCkge1xuICAgICAgICBtb2RlbCA9IG1lLl9tb2RlbGl6ZShkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KTtcbiAgICAgICAgcmVjdHMgPSBib3VuZGluZ1JlY3RzKG1vZGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZS5fbW9kZWwgPSBtb2RlbDtcbiAgICBtZS5fcmVjdHMgPSByZWN0cztcbiAgfSxcblxuICBnZW9tZXRyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY3RzID8gdGhpcy5fcmVjdHMuZnJhbWUgOiB7fTtcbiAgfSxcblxuICByb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsID8gdGhpcy5fbW9kZWwucm90YXRpb24gOiAwO1xuICB9LFxuXG4gIHZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5vcGFjaXR5O1xuICB9LFxuXG4gIG1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oY2hhcnQsIGNlbnRlcikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICB2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XG4gICAgdmFyIHJlY3RzID0gbWUuX3JlY3RzO1xuICAgIHZhciBhcmVhO1xuXG4gICAgaWYgKCF0aGlzLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAobW9kZWwuY2xpcCkge1xuICAgICAgYXJlYSA9IG1vZGVsLmFyZWE7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgucmVjdChcbiAgICAgICAgYXJlYS5sZWZ0LFxuICAgICAgICBhcmVhLnRvcCxcbiAgICAgICAgYXJlYS5yaWdodCAtIGFyZWEubGVmdCxcbiAgICAgICAgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH1cblxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHV0aWxzLmJvdW5kKDAsIG1vZGVsLm9wYWNpdHksIDEpO1xuICAgIGN0eC50cmFuc2xhdGUocmFzdGVyaXplKGNlbnRlci54KSwgcmFzdGVyaXplKGNlbnRlci55KSk7XG4gICAgY3R4LnJvdGF0ZShtb2RlbC5yb3RhdGlvbik7XG5cbiAgICBkcmF3RnJhbWUoY3R4LCByZWN0cy5mcmFtZSwgbW9kZWwpO1xuICAgIGRyYXdUZXh0KGN0eCwgbW9kZWwubGluZXMsIHJlY3RzLnRleHQsIG1vZGVsKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn0pO1xuXG52YXIgaGVscGVycyQyID0gQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5oZWxwZXJzO1xuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWluc2FmZWludGVnZXJcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1tYXhzYWZlaW50ZWdlclxuXG5mdW5jdGlvbiByb3RhdGVkKHBvaW50LCBjZW50ZXIsIGFuZ2xlKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHZhciBjeCA9IGNlbnRlci54O1xuICB2YXIgY3kgPSBjZW50ZXIueTtcblxuICByZXR1cm4ge1xuICAgIHg6IGN4ICsgY29zICogKHBvaW50LnggLSBjeCkgLSBzaW4gKiAocG9pbnQueSAtIGN5KSxcbiAgICB5OiBjeSArIHNpbiAqIChwb2ludC54IC0gY3gpICsgY29zICogKHBvaW50LnkgLSBjeSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGVkKHBvaW50cywgYXhpcykge1xuICB2YXIgbWluID0gTUFYX0lOVEVHRVI7XG4gIHZhciBtYXggPSBNSU5fSU5URUdFUjtcbiAgdmFyIG9yaWdpbiA9IGF4aXMub3JpZ2luO1xuICB2YXIgaSwgcHQsIHZ4LCB2eSwgZHA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHB0ID0gcG9pbnRzW2ldO1xuICAgIHZ4ID0gcHQueCAtIG9yaWdpbi54O1xuICAgIHZ5ID0gcHQueSAtIG9yaWdpbi55O1xuICAgIGRwID0gYXhpcy52eCAqIHZ4ICsgYXhpcy52eSAqIHZ5O1xuICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZHApO1xuICAgIG1heCA9IE1hdGgubWF4KG1heCwgZHApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0F4aXMocDAsIHAxKSB7XG4gIHZhciB2eCA9IHAxLnggLSBwMC54O1xuICB2YXIgdnkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcblxuICByZXR1cm4ge1xuICAgIHZ4OiAocDEueCAtIHAwLngpIC8gbG4sXG4gICAgdnk6IChwMS55IC0gcDAueSkgLyBsbixcbiAgICBvcmlnaW46IHAwLFxuICAgIGxuOiBsblxuICB9O1xufVxuXG52YXIgSGl0Qm94ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgdGhpcy5fcmVjdCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgdzogMCxcbiAgICBoOiAwXG4gIH07XG59O1xuXG5oZWxwZXJzJDIuZXh0ZW5kKEhpdEJveC5wcm90b3R5cGUsIHtcbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXMuX3JlY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHIueCArIHIudyAvIDIsXG4gICAgICB5OiByLnkgKyByLmggLyAyXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNlbnRlciwgcmVjdCwgcm90YXRpb24pIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuX3JlY3QgPSB7XG4gICAgICB4OiByZWN0LnggKyBjZW50ZXIueCxcbiAgICAgIHk6IHJlY3QueSArIGNlbnRlci55LFxuICAgICAgdzogcmVjdC53LFxuICAgICAgaDogcmVjdC5oXG4gICAgfTtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtYXJnaW4gPSAxO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG5cbiAgICBwb2ludCA9IHJvdGF0ZWQocG9pbnQsIG1lLmNlbnRlcigpLCAtbWUuX3JvdGF0aW9uKTtcblxuICAgIHJldHVybiAhKHBvaW50LnggPCByZWN0LnggLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnkgPCByZWN0LnkgLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnggPiByZWN0LnggKyByZWN0LncgKyBtYXJnaW4gKiAyXG4gICAgICB8fCBwb2ludC55ID4gcmVjdC55ICsgcmVjdC5oICsgbWFyZ2luICogMik7XG4gIH0sXG5cbiAgLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW1cbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2YXIgcjAgPSB0aGlzLl9wb2ludHMoKTtcbiAgICB2YXIgcjEgPSBvdGhlci5fcG9pbnRzKCk7XG4gICAgdmFyIGF4ZXMgPSBbXG4gICAgICB0b0F4aXMocjBbMF0sIHIwWzFdKSxcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbM10pXG4gICAgXTtcbiAgICB2YXIgaSwgcHIwLCBwcjE7XG5cbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IG90aGVyLl9yb3RhdGlvbikge1xuICAgICAgLy8gT25seSBzZXBhcmF0ZSB3aXRoIHIxIGF4aXMgaWYgdGhlIHJvdGF0aW9uIGlzIGRpZmZlcmVudCxcbiAgICAgIC8vIGVsc2UgaXQncyBlbm91Z2ggdG8gc2VwYXJhdGUgcjAgYW5kIHIxIHdpdGggcjAgYXhpcyBvbmx5IVxuICAgICAgYXhlcy5wdXNoKFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzFdKSxcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVszXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHByMCA9IHByb2plY3RlZChyMCwgYXhlc1tpXSk7XG4gICAgICBwcjEgPSBwcm9qZWN0ZWQocjEsIGF4ZXNbaV0pO1xuXG4gICAgICBpZiAocHIwLm1heCA8IHByMS5taW4gfHwgcHIxLm1heCA8IHByMC5taW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xuICAgIHZhciBhbmdsZSA9IG1lLl9yb3RhdGlvbjtcbiAgICB2YXIgY2VudGVyID0gbWUuY2VudGVyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LnggKyByZWN0LncsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0Lmh9LCBjZW50ZXIsIGFuZ2xlKVxuICAgIF07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb29yZGluYXRlcyh2aWV3LCBtb2RlbCwgZ2VvbWV0cnkpIHtcbiAgdmFyIHBvaW50ID0gbW9kZWwucG9zaXRpb25lcih2aWV3LCBtb2RlbCk7XG4gIHZhciB2eCA9IHBvaW50LnZ4O1xuICB2YXIgdnkgPSBwb2ludC52eTtcblxuICBpZiAoIXZ4ICYmICF2eSkge1xuICAgIC8vIGlmIGFsaWduZWQgY2VudGVyLCB3ZSBkb24ndCB3YW50IHRvIG9mZnNldCB0aGUgY2VudGVyIHBvaW50XG4gICAgcmV0dXJuIHt4OiBwb2ludC54LCB5OiBwb2ludC55fTtcbiAgfVxuXG4gIHZhciB3ID0gZ2VvbWV0cnkudztcbiAgdmFyIGggPSBnZW9tZXRyeS5oO1xuXG4gIC8vIHRha2UgaW4gYWNjb3VudCB0aGUgbGFiZWwgcm90YXRpb25cbiAgdmFyIHJvdGF0aW9uID0gbW9kZWwucm90YXRpb247XG4gIHZhciBkeCA9IE1hdGguYWJzKHcgLyAyICogTWF0aC5jb3Mocm90YXRpb24pKSArIE1hdGguYWJzKGggLyAyICogTWF0aC5zaW4ocm90YXRpb24pKTtcbiAgdmFyIGR5ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpO1xuXG4gIC8vIHNjYWxlIHRoZSB1bml0IHZlY3RvciAodngsIHZ5KSB0byBnZXQgYXQgbGVhc3QgZHggb3IgZHkgZXF1YWwgdG9cbiAgLy8gdyBvciBoIHJlc3BlY3RpdmVseSAoZWxzZSB3ZSB3b3VsZCBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZVxuICAvLyBlbGxpcHNlIGluc2NyaWJlZCBpbiB0aGUgYm91bmRpbmcgcmVjdClcbiAgdmFyIHZzID0gMSAvIE1hdGgubWF4KE1hdGguYWJzKHZ4KSwgTWF0aC5hYnModnkpKTtcbiAgZHggKj0gdnggKiB2cztcbiAgZHkgKj0gdnkgKiB2cztcblxuICAvLyBmaW5hbGx5LCBpbmNsdWRlIHRoZSBleHBsaWNpdCBvZmZzZXRcbiAgZHggKz0gbW9kZWwub2Zmc2V0ICogdng7XG4gIGR5ICs9IG1vZGVsLm9mZnNldCAqIHZ5O1xuXG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQueCArIGR4LFxuICAgIHk6IHBvaW50LnkgKyBkeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xsaWRlKGxhYmVscywgY29sbGlkZXIpIHtcbiAgdmFyIGksIGosIHMwLCBzMTtcblxuICAvLyBJTVBPUlRBTlQgSXRlcmF0ZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBzaW5jZSBpdGVtcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAvLyBsaXN0IGhhdmUgYW4gaGlnaGVyIHdlaWdodC9wcmlvcml0eSBhbmQgdGh1cyBzaG91bGQgYmUgbGVzcyBpbXBhY3RlZFxuICAvLyBieSB0aGUgb3ZlcmxhcHBpbmcgc3RyYXRlZ3kuXG5cbiAgZm9yIChpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgczAgPSBsYWJlbHNbaV0uJGxheW91dDtcblxuICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDAgJiYgczAuX3Zpc2libGU7IC0taikge1xuICAgICAgczEgPSBsYWJlbHNbal0uJGxheW91dDtcblxuICAgICAgaWYgKHMxLl92aXNpYmxlICYmIHMwLl9ib3guaW50ZXJzZWN0cyhzMS5fYm94KSkge1xuICAgICAgICBjb2xsaWRlcihzMCwgczEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGUobGFiZWxzKSB7XG4gIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXI7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYWJlbHMgZm9yIG92ZXJsYXAgZGV0ZWN0aW9uXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICBnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XG4gICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhsYWJlbC5fZWwuX21vZGVsLCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvIGhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzXG4gIHJldHVybiBjb2xsaWRlKGxhYmVscywgZnVuY3Rpb24oczAsIHMxKSB7XG4gICAgdmFyIGgwID0gczAuX2hpZGFibGU7XG4gICAgdmFyIGgxID0gczEuX2hpZGFibGU7XG5cbiAgICBpZiAoKGgwICYmIGgxKSB8fCBoMSkge1xuICAgICAgczEuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGgwKSB7XG4gICAgICBzMC5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXlvdXQgPSB7XG4gIHByZXBhcmU6IGZ1bmN0aW9uKGRhdGFzZXRzKSB7XG4gICAgdmFyIGxhYmVscyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBsYWJlbDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhc2V0c1tpXS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgbGFiZWwgPSBkYXRhc2V0c1tpXVtqXTtcbiAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICBsYWJlbC4kbGF5b3V0ID0ge1xuICAgICAgICAgIF9ib3g6IG5ldyBIaXRCb3goKSxcbiAgICAgICAgICBfaGlkYWJsZTogZmFsc2UsXG4gICAgICAgICAgX3Zpc2libGU6IHRydWUsXG4gICAgICAgICAgX3NldDogaSxcbiAgICAgICAgICBfaWR4OiBqXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyBOZXcgYHpgIG9wdGlvbjogbGFiZWxzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd25cbiAgICAvLyBvZiB0b3Agb2YgdGhlIG9uZXMgd2l0aCBhIGxvd2VyIGluZGV4LiBMb3dlc3Qgei1pbmRleCBsYWJlbHNcbiAgICAvLyBhcmUgYWxzbyBkaXNjYXJkZWQgZmlyc3Qgd2hlbiBoaWRpbmcgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuICAgIGxhYmVscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBzYSA9IGEuJGxheW91dDtcbiAgICAgIHZhciBzYiA9IGIuJGxheW91dDtcblxuICAgICAgcmV0dXJuIHNhLl9pZHggPT09IHNiLl9pZHhcbiAgICAgICAgPyBzYi5fc2V0IC0gc2EuX3NldFxuICAgICAgICA6IHNiLl9pZHggLSBzYS5faWR4O1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGUobGFiZWxzKTtcblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihsYWJlbHMpIHtcbiAgICB2YXIgZGlydHkgPSBmYWxzZTtcbiAgICB2YXIgaSwgaWxlbiwgbGFiZWwsIG1vZGVsLCBzdGF0ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgIG1vZGVsID0gbGFiZWwubW9kZWwoKTtcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcbiAgICAgIHN0YXRlLl9oaWRhYmxlID0gbW9kZWwgJiYgbW9kZWwuZGlzcGxheSA9PT0gJ2F1dG8nO1xuICAgICAgc3RhdGUuX3Zpc2libGUgPSBsYWJlbC52aXNpYmxlKCk7XG4gICAgICBkaXJ0eSB8PSBzdGF0ZS5faGlkYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoZGlydHkpIHtcbiAgICAgIGNvbXB1dGUobGFiZWxzKTtcbiAgICB9XG4gIH0sXG5cbiAgbG9va3VwOiBmdW5jdGlvbihsYWJlbHMsIHBvaW50KSB7XG4gICAgdmFyIGksIHN0YXRlO1xuXG4gICAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBsaXN0IGhhdmUgYW4gaGlnaGVyIHotaW5kZXgsIHRodXMgc2hvdWxkIGJlIHBpY2tlZCBmaXJzdC5cblxuICAgIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgc3RhdGUgPSBsYWJlbHNbaV0uJGxheW91dDtcblxuICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLl92aXNpYmxlICYmIHN0YXRlLl9ib3guY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oY2hhcnQsIGxhYmVscykge1xuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXI7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzdGF0ZS5fdmlzaWJsZSkge1xuICAgICAgICBnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XG4gICAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKGxhYmVsLl9lbC5fdmlldywgbGFiZWwubW9kZWwoKSwgZ2VvbWV0cnkpO1xuICAgICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICAgICAgbGFiZWwuZHJhdyhjaGFydCwgY2VudGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoZWxwZXJzJDEgPSBDaGFydF9fZGVmYXVsdFsnZGVmYXVsdCddLmhlbHBlcnM7XG5cbnZhciBmb3JtYXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGFiZWwgPSB2YWx1ZTtcbiAgdmFyIGtleXMsIGtsZW4sIGs7XG4gIGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKCFoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih2YWx1ZS5sYWJlbCkpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUubGFiZWw7XG4gICAgfSBlbHNlIGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUucikpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUucjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgICAgbGFiZWwgKz0gKGsgIT09IDAgPyAnLCAnIDogJycpICsga2V5c1trXSArICc6ICcgKyB2YWx1ZVtrZXlzW2tdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJycgKyBsYWJlbDtcbn07XG5cbi8qKlxuICogSU1QT1JUQU5UOiBtYWtlIHN1cmUgdG8gYWxzbyB1cGRhdGUgdGVzdHMgYW5kIFR5cGVTY3JpcHQgZGVmaW5pdGlvblxuICogZmlsZXMgKGAvdGVzdC9zcGVjcy9kZWZhdWx0cy5zcGVjLmpzYCBhbmQgYC90eXBlcy9vcHRpb25zLmQudHNgKVxuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBhbmNob3I6ICdjZW50ZXInLFxuICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gIGJvcmRlckNvbG9yOiBudWxsLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBjbGFtcDogZmFsc2UsXG4gIGNsaXA6IGZhbHNlLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBkaXNwbGF5OiB0cnVlLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgbGluZUhlaWdodDogMS4yLFxuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgIHdlaWdodDogbnVsbFxuICB9LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgbGFiZWxzOiB1bmRlZmluZWQsXG4gIGxpc3RlbmVyczoge30sXG4gIG9mZnNldDogNCxcbiAgb3BhY2l0eTogMSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogNCxcbiAgICByaWdodDogNCxcbiAgICBib3R0b206IDQsXG4gICAgbGVmdDogNFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB0ZXh0U2hhZG93Qmx1cjogMCxcbiAgdGV4dFNoYWRvd0NvbG9yOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE3NlxuICovXG5cbnZhciBoZWxwZXJzID0gQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5oZWxwZXJzO1xudmFyIEVYUEFORE9fS0VZID0gJyRkYXRhbGFiZWxzJztcbnZhciBERUZBVUxUX0tFWSA9ICckZGVmYXVsdCc7XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKSB7XG4gIHZhciBvdmVycmlkZSA9IGRhdGFzZXQuZGF0YWxhYmVscztcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xuICB2YXIgY29uZmlncyA9IFtdO1xuICB2YXIgbGFiZWxzLCBrZXlzO1xuXG4gIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICBvdmVycmlkZSA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IGhlbHBlcnMubWVyZ2Uoe30sIFtvcHRpb25zLCBvdmVycmlkZV0pO1xuICBsYWJlbHMgPSBvcHRpb25zLmxhYmVscyB8fCB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XG4gIGRlbGV0ZSBvcHRpb25zLmxhYmVscztcblxuICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAobGFiZWxzW2tleV0pIHtcbiAgICAgICAgY29uZmlncy5wdXNoKGhlbHBlcnMubWVyZ2Uoe30sIFtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGxhYmVsc1trZXldLFxuICAgICAgICAgIHtfa2V5OiBrZXl9XG4gICAgICAgIF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGxhYmVsIGlmIG5vIFwibmFtZWRcIiBsYWJlbCBkZWZpbmVkLlxuICAgIGNvbmZpZ3MucHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGxpc3RlbmVyczogezxldmVudC10eXBlPjogezxsYWJlbC1rZXk+OiA8Zm4+fX1cbiAgbGlzdGVuZXJzID0gY29uZmlncy5yZWR1Y2UoZnVuY3Rpb24odGFyZ2V0LCBjb25maWcpIHtcbiAgICBoZWxwZXJzLmVhY2goY29uZmlnLmxpc3RlbmVycyB8fCB7fSwgZnVuY3Rpb24oZm4sIGV2ZW50KSB7XG4gICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcbiAgICAgIHRhcmdldFtldmVudF1bY29uZmlnLl9rZXkgfHwgREVGQVVMVF9LRVldID0gZm47XG4gICAgfSk7XG5cbiAgICBkZWxldGUgY29uZmlnLmxpc3RlbmVycztcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsYWJlbHM6IGNvbmZpZ3MsXG4gICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLCBsYWJlbCkge1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gbGFiZWwuJGNvbnRleHQ7XG4gIHZhciBncm91cHMgPSBsYWJlbC4kZ3JvdXBzO1xuICB2YXIgY2FsbGJhY2s7XG5cbiAgaWYgKCFsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdW2dyb3Vwcy5fa2V5XTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChoZWxwZXJzLmNhbGxiYWNrKGNhbGxiYWNrLCBbY29udGV4dF0pID09PSB0cnVlKSB7XG4gICAgLy8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxuICAgIC8vIHVzZWQgaW4gc2NyaXB0YWJsZSBvcHRpb25zIHRvIGRpc3BsYXkgbGFiZWxzIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZXZlbnQgKGUuZy4gaGlnaGxpZ2h0IGFuIGhvdmVyZWQgbGFiZWwpLiBUaGF0J3Mgd2h5IHdlIHVwZGF0ZSB0aGUgbGFiZWwgd2l0aFxuICAgIC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9kaXJ0eSA9IHRydWU7XG4gICAgbGFiZWwudXBkYXRlKGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwpIHtcbiAgdmFyIGVudGVyLCBsZWF2ZTtcblxuICBpZiAoIXByZXZpb3VzICYmICFsYWJlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghcHJldmlvdXMpIHtcbiAgICBlbnRlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoIWxhYmVsKSB7XG4gICAgbGVhdmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzICE9PSBsYWJlbCkge1xuICAgIGxlYXZlID0gZW50ZXIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGxlYXZlKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmxlYXZlLCBwcmV2aW91cyk7XG4gIH1cbiAgaWYgKGVudGVyKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmVudGVyLCBsYWJlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBsaXN0ZW5lcnMgPSBleHBhbmRvLl9saXN0ZW5lcnM7XG4gIHZhciBwcmV2aW91cywgbGFiZWw7XG5cbiAgaWYgKCFsaXN0ZW5lcnMuZW50ZXIgJiYgIWxpc3RlbmVycy5sZWF2ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChldmVudC50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJldmlvdXMgPSBleHBhbmRvLl9ob3ZlcmVkO1xuICBleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XG4gIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBoYW5kbGVycyA9IGV4cGFuZG8uX2xpc3RlbmVycy5jbGljaztcbiAgdmFyIGxhYmVsID0gaGFuZGxlcnMgJiYgbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgaWYgKGxhYmVsKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgaGFuZGxlcnMsIGxhYmVsKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8xMDhcbmZ1bmN0aW9uIGludmFsaWRhdGUoY2hhcnQpIHtcbiAgaWYgKGNoYXJ0LmFuaW1hdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGBjaGFydC5hbmltYXRpbmdgIGNhbiBiZSBgZmFsc2VgIGV2ZW4gaWYgdGhlcmUgaXMgYW5pbWF0aW9uIGluIHByb2dyZXNzLFxuICAvLyBzbyBsZXQncyBpdGVyYXRlIGFsbCBhbmltYXRpb25zIHRvIGZpbmQgaWYgdGhlcmUgaXMgb25lIGZvciB0aGUgYGNoYXJ0YC5cbiAgdmFyIGFuaW1hdGlvbnMgPSBDaGFydF9fZGVmYXVsdFsnZGVmYXVsdCddLmFuaW1hdGlvblNlcnZpY2UuYW5pbWF0aW9ucztcbiAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5vIHJlbmRlciBzY2hlZHVsZWQ6IHRyaWdnZXIgYSBcImxhenlcIiByZW5kZXIgdGhhdCBjYW4gYmUgY2FuY2VsZWQgaW4gY2FzZVxuICAvLyBvZiBob3ZlciBpbnRlcmFjdGlvbnMuIFRoZSAxbXMgZHVyYXRpb24gaXMgYSB3b3JrYXJvdW5kIHRvIG1ha2Ugc3VyZSBhblxuICAvLyBhbmltYXRpb24gaXMgY3JlYXRlZCBzbyB0aGUgY29udHJvbGxlciBjYW4gc3RvcCBpdCBiZWZvcmUgYW55IHRyYW5zaXRpb24uXG4gIGNoYXJ0LnJlbmRlcih7ZHVyYXRpb246IDEsIGxhenk6IHRydWV9KTtcbn1cblxuQ2hhcnRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5kZWZhdWx0cy5nbG9iYWwucGx1Z2lucy5kYXRhbGFiZWxzID0gZGVmYXVsdHM7XG5cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnZGF0YWxhYmVscycsXG5cbiAgYmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0gPSB7XG4gICAgICBfYWN0aXZlczogW11cbiAgICB9O1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICBleHBhbmRvLl9saXN0ZW5lZCA9IGZhbHNlO1xuICAgIGV4cGFuZG8uX2xpc3RlbmVycyA9IHt9OyAgICAgLy8gezxldmVudC10eXBlPjogezxkYXRhc2V0LWluZGV4PjogezxsYWJlbC1rZXk+OiA8Zm4+fX19XG4gICAgZXhwYW5kby5fZGF0YXNldHMgPSBbXTsgICAgICAvLyBwZXIgZGF0YXNldCBsYWJlbHM6IFtMYWJlbFtdXVxuICAgIGV4cGFuZG8uX2xhYmVscyA9IFtdOyAgICAgICAgLy8gbGF5b3V0ZWQgbGFiZWxzOiBMYWJlbFtdXG4gIH0sXG5cbiAgYWZ0ZXJEYXRhc2V0VXBkYXRlOiBmdW5jdGlvbihjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIHZhciBkYXRhc2V0SW5kZXggPSBhcmdzLmluZGV4O1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIHZhciBsYWJlbHMgPSBleHBhbmRvLl9kYXRhc2V0c1tkYXRhc2V0SW5kZXhdID0gW107XG4gICAgdmFyIHZpc2libGUgPSBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCk7XG4gICAgdmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgdmFyIGNvbmZpZyA9IGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKTtcbiAgICB2YXIgZWxlbWVudHMgPSBhcmdzLm1ldGEuZGF0YSB8fCBbXTtcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBjZmcsIGtleSwgZWwsIGxhYmVsO1xuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGVsID0gZWxlbWVudHNbaV07XG4gICAgICBlbFtFWFBBTkRPX0tFWV0gPSBbXTtcblxuICAgICAgaWYgKHZpc2libGUgJiYgZWwgJiYgIWVsLmhpZGRlbiAmJiAhZWwuX21vZGVsLnNraXApIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGNvbmZpZy5sYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgY2ZnID0gY29uZmlnLmxhYmVsc1tqXTtcbiAgICAgICAgICBrZXkgPSBjZmcuX2tleTtcblxuICAgICAgICAgIGxhYmVsID0gbmV3IExhYmVsKGNmZywgY3R4LCBlbCwgaSk7XG4gICAgICAgICAgbGFiZWwuJGdyb3VwcyA9IHtcbiAgICAgICAgICAgIF9zZXQ6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgIF9rZXk6IGtleSB8fCBERUZBVUxUX0tFWVxuICAgICAgICAgIH07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQgPSB7XG4gICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgY2hhcnQ6IGNoYXJ0LFxuICAgICAgICAgICAgZGF0YUluZGV4OiBpLFxuICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxhYmVsLnVwZGF0ZShsYWJlbC4kY29udGV4dCk7XG4gICAgICAgICAgZWxbRVhQQU5ET19LRVldLnB1c2gobGFiZWwpO1xuICAgICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBTdG9yZSBsaXN0ZW5lcnMgYXQgdGhlIGNoYXJ0IGxldmVsIGFuZCBwZXIgZXZlbnQgdHlwZSB0byBvcHRpbWl6ZVxuICAgIC8vIGNhc2VzIHdoZXJlIG5vIGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICBoZWxwZXJzLm1lcmdlKGV4cGFuZG8uX2xpc3RlbmVycywgY29uZmlnLmxpc3RlbmVycywge1xuICAgICAgbWVyZ2VyOiBmdW5jdGlvbihldmVudCwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICAgIHRhcmdldFtldmVudF1bYXJncy5pbmRleF0gPSBzb3VyY2VbZXZlbnRdO1xuICAgICAgICBleHBhbmRvLl9saXN0ZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMgPSBsYXlvdXQucHJlcGFyZShcbiAgICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fZGF0YXNldHMsXG4gICAgICBvcHRpb25zKTtcbiAgfSxcblxuICAvLyBEcmF3IGxhYmVscyBvbiB0b3Agb2YgYWxsIGRhdGFzZXQgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMjlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcbiAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgbGF5b3V0LmRyYXcoY2hhcnQsIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzKTtcbiAgfSxcblxuICBiZWZvcmVFdmVudDogZnVuY3Rpb24oY2hhcnQsIGV2ZW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIgcmVnaXN0ZXJlZCBmb3IgdGhpcyBjaGFydCwgYGxpc3RlbmVkYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIG1lYW5pbmcgd2UgY2FuIGltbWVkaWF0ZWx5IGlnbm9yZSB0aGUgaW5jb21pbmcgZXZlbnQgYW5kIGF2b2lkIHVzZWxlc3MgZXh0cmFcbiAgICAvLyBjb21wdXRhdGlvbiBmb3IgdXNlcnMgd2hvIGRvbid0IGltcGxlbWVudCBsYWJlbCBpbnRlcmFjdGlvbnMuXG4gICAgaWYgKGNoYXJ0W0VYUEFORE9fS0VZXS5fbGlzdGVuZWQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIHByZXZpb3VzID0gZXhwYW5kby5fYWN0aXZlcztcbiAgICB2YXIgYWN0aXZlcyA9IGV4cGFuZG8uX2FjdGl2ZXMgPSBjaGFydC5sYXN0QWN0aXZlIHx8IFtdOyAgLy8gcHVibGljIEFQST8hXG4gICAgdmFyIHVwZGF0ZXMgPSB1dGlscy5hcnJheURpZmYocHJldmlvdXMsIGFjdGl2ZXMpO1xuICAgIHZhciBpLCBpbGVuLCBqLCBqbGVuLCB1cGRhdGUsIGxhYmVsLCBsYWJlbHM7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdXBkYXRlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlWzFdKSB7XG4gICAgICAgIGxhYmVscyA9IHVwZGF0ZVswXVtFWFBBTkRPX0tFWV0gfHwgW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQuYWN0aXZlID0gKHVwZGF0ZVsxXSA9PT0gMSk7XG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBhbmRvLl9kaXJ0eSB8fCB1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgbGF5b3V0LnVwZGF0ZShleHBhbmRvLl9sYWJlbHMpO1xuICAgICAgaW52YWxpZGF0ZShjaGFydCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGV4cGFuZG8uX2RpcnR5O1xuICB9XG59O1xuXG5yZXR1cm4gcGx1Z2luO1xuXG59KSkpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5pbXBvcnQge1xuICBBcHBsaWVkUHJvbXB0cyxcbiAgQ29udGV4dCxcbiAgb25EcmlsbERvd25GdW5jdGlvbixcbiAgUmVzcG9uc2VEYXRhLFxuICBUQ29udGV4dFxufSBmcm9tICdAaW5jb3J0YS1vcmcvY29tcG9uZW50LXNkayc7XG5pbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ybWF0TnVtYmVyIH0gZnJvbSAnLi9mb3JtYXROdW1iZXInO1xuaW1wb3J0IENoYXJ0RGF0YUxhYmVscyBmcm9tICdjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgY29udGV4dDogQ29udGV4dDxUQ29udGV4dD47XG4gIHByb21wdHM6IEFwcGxpZWRQcm9tcHRzO1xuICBkYXRhOiBSZXNwb25zZURhdGE7XG4gIGRyaWxsRG93bjogb25EcmlsbERvd25GdW5jdGlvbjtcbn1cblxuY29uc3QgVG9ybmFkb0NoYXJ0ID0gKHsgY29udGV4dCwgcHJvbXB0cywgZGF0YSwgZHJpbGxEb3duIH06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgc2hvd1ZhbHVlcyA9IHRydWUgfSA9IGNvbnRleHQuY29tcG9uZW50LnNldHRpbmdzID8/IHt9O1xuXG4gIGNvbnN0IGNvbG9yMSA9XG4gICAgY29udGV4dC5jb21wb25lbnQuYmluZGluZ3M/Lm1lYXN1cmU/LlswXS5zZXR0aW5ncz8uY29sb3IgPz8gY29udGV4dC5hcHAuY29sb3JfcGFsZXR0ZVswXTtcbiAgY29uc3QgY29sb3IyID1cbiAgICBjb250ZXh0LmNvbXBvbmVudC5iaW5kaW5ncz8ubWVhc3VyZT8uWzFdLnNldHRpbmdzPy5jb2xvciA/PyBjb250ZXh0LmFwcC5jb2xvcl9wYWxldHRlWzFdO1xuICBjb25zdCBmb3JtYXQxID0gY29udGV4dC5jb21wb25lbnQuYmluZGluZ3M/Lm1lYXN1cmU/LlswXS5zZXR0aW5ncz8uZm9ybWF0O1xuICBjb25zdCBmb3JtYXQyID0gY29udGV4dC5jb21wb25lbnQuYmluZGluZ3M/Lm1lYXN1cmU/LlsxXS5zZXR0aW5ncz8uZm9ybWF0O1xuXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG5cbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250ZXh0LmNvbXBvbmVudC5kaW1lbnNpb25zO1xuXG4gIGNvbnN0IHsgYmFyQ2hhcnREYXRhLCBjYXRMYWJlbCwgZGF0YTFMYWJlbCwgZGF0YTJMYWJlbCB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGRhdGExOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IGRhdGEyOiBhbnlbXSA9IFtdO1xuXG4gICAgY29uc3QgY2F0TGFiZWwgPSBkYXRhLnJvd0hlYWRlcnM/LlswXS5sYWJlbDtcbiAgICBjb25zdCBkYXRhMUxhYmVsID0gZGF0YS5tZWFzdXJlSGVhZGVyc1swXS5sYWJlbDtcbiAgICBjb25zdCBkYXRhMkxhYmVsID0gZGF0YS5tZWFzdXJlSGVhZGVyc1sxXS5sYWJlbDtcblxuICAgIGRhdGEuZGF0YS5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgIGxhYmVscy5wdXNoKHBvaW50WzBdLnZhbHVlKTtcbiAgICAgIGRhdGExLnB1c2gocG9pbnRbMV0udmFsdWUpO1xuICAgICAgZGF0YTIucHVzaChwb2ludFsyXS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxzLFxuICAgICAgZGF0YTEsXG4gICAgICBkYXRhMixcbiAgICAgIGNhdExhYmVsLFxuICAgICAgZGF0YTFMYWJlbCxcbiAgICAgIGRhdGEyTGFiZWwsXG4gICAgICBiYXJDaGFydERhdGE6IHtcbiAgICAgICAgbGFiZWxzLFxuICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBkYXRhMUxhYmVsLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcjEsXG4gICAgICAgICAgICBkYXRhOiBkYXRhMS5tYXAoTnVtYmVyKS5tYXAoayA9PiAtayksXG4gICAgICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgYWxpZ246ICdzdGFydCcsXG4gICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKF86IGFueSwgYzogYW55KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihcbiAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YT8uW2MuZGF0YUluZGV4IV0/LltjLmRhdGFzZXRJbmRleCEgKyAxXS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogZGF0YTJMYWJlbCxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IyLFxuICAgICAgICAgICAgZGF0YTogZGF0YTIubWFwKE51bWJlciksXG4gICAgICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgICAgIGFuY2hvcjogJ2VuZCcsXG4gICAgICAgICAgICAgIGFsaWduOiAnZW5kJyxcbiAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoXzogYW55LCBjOiBhbnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKFxuICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhPy5bYy5kYXRhSW5kZXghXT8uW2MuZGF0YXNldEluZGV4ISArIDFdLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZm9ybWF0MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZGF0YSwgY29sb3IxLCBjb2xvcjJdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSBjYW52YXNSZWYuY3VycmVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGNvbnN0IGNoYXJ0UmVuZGVyID0gbmV3IENoYXJ0KGN0eCwge1xuICAgICAgICB0eXBlOiAnaG9yaXpvbnRhbEJhcicsXG4gICAgICAgIGRhdGE6IGJhckNoYXJ0RGF0YSxcbiAgICAgICAgcGx1Z2luczogW3Nob3dWYWx1ZXMgJiYgQ2hhcnREYXRhTGFiZWxzXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwczoge1xuICAgICAgICAgICAgaW50ZXJzZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICB0aXRsZSh0b29sdGlwSXRlbSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gdG9vbHRpcEl0ZW1bMF0ubGFiZWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2NhdExhYmVsfTogJHtsYWJlbH1gO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYWJlbDogYyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJldFN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjLmRhdGFzZXRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0U3RyICs9IGAke2RhdGExTGFiZWx9OiAke2Zvcm1hdE51bWJlcigtYy52YWx1ZSEsIGZvcm1hdDEsIGZhbHNlKX1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXRTdHIgKz0gYCR7ZGF0YTJMYWJlbH06ICR7Zm9ybWF0TnVtYmVyKGMudmFsdWUsIGZvcm1hdDIsIGZhbHNlKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0U3RyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgcG9zaXRpb246ICdib3R0b20nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIHhBeGVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTMsXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogKHY6IGFueSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdiA8IDAgPyBmb3JtYXROdW1iZXIoLXYsIGZvcm1hdDEpIDogZm9ybWF0TnVtYmVyKHYsIGZvcm1hdDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHlBeGVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6IGNhdExhYmVsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFja2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxM1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdsZWZ0J1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2hhcnRSZW5kZXIuZGVzdHJveSgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtiYXJDaGFydERhdGEsIHNob3dWYWx1ZXMsIHdpZHRoLCBoZWlnaHRdKTtcblxuICByZXR1cm4gPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gc3R5bGU9e3sgd2lkdGgsIGhlaWdodCB9fSAvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRvcm5hZG9DaGFydDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICB1c2VDb250ZXh0LFxuICBMb2FkaW5nT3ZlcmxheSxcbiAgRXJyb3JPdmVybGF5LFxuICB1c2VQcm9tcHRzLFxuICB1c2VRdWVyeVxufSBmcm9tICdAaW5jb3J0YS1vcmcvY29tcG9uZW50LXNkayc7XG5pbXBvcnQgVG9ybmFkb0NoYXJ0IGZyb20gJy4vVG9ybmFkb0NoYXJ0JztcbmltcG9ydCAnLi9zdHlsZXMubGVzcyc7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgY29uc3QgeyBwcm9tcHRzLCBkcmlsbERvd24gfSA9IHVzZVByb21wdHMoKTtcbiAgY29uc3QgeyBkYXRhLCBjb250ZXh0LCBpc0xvYWRpbmcsIGlzRXJyb3IsIGVycm9yIH0gPSB1c2VRdWVyeSh1c2VDb250ZXh0KCksIHByb21wdHMpO1xuICByZXR1cm4gKFxuICAgIDxFcnJvck92ZXJsYXkgaXNFcnJvcj17aXNFcnJvcn0gZXJyb3I9e2Vycm9yfT5cbiAgICAgIDxMb2FkaW5nT3ZlcmxheSBpc0xvYWRpbmc9e2lzTG9hZGluZ30gZGF0YT17ZGF0YX0+XG4gICAgICAgIHtjb250ZXh0ICYmIGRhdGEgPyAoXG4gICAgICAgICAgPFRvcm5hZG9DaGFydCBkYXRhPXtkYXRhfSBjb250ZXh0PXtjb250ZXh0fSBwcm9tcHRzPXtwcm9tcHRzfSBkcmlsbERvd249e2RyaWxsRG93bn0gLz5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICA8L0xvYWRpbmdPdmVybGF5PlxuICAgIDwvRXJyb3JPdmVybGF5PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJmb3JtYXQiLCJsb2NhbGUiLCJ0byIsImZyb20iLCJub3ciLCJzaWduIiwidG9rZW4iLCJvcmRpbmFsIiwiaSIsImRpZmYiLCJsb2NhbGVEYXRhIiwiaG91cnMiLCJtaW51dGVzIiwidG9rZW5zIiwibWVyaWRpZW0iLCJ5ZWFycyIsIm1vbnRocyIsIndlZWtzIiwiZGF5cyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJvZmZzZXQiLCJpbmRleCIsInRocmVzaG9sZHMiLCJnbG9iYWwiLCJtb2R1bGUiLCJ0aGlzIiwibW9tZW50IiwiY29udmVydCIsIm1pbiIsIm1heCIsImsiLCJrZXl3b3JkIiwiY29sb3JTdHJpbmciLCJtb2RlbHMiLCJrZXlzIiwib3B0aW9ucyIsInNyYyIsImRlZmF1bHRzIiwicnRsIiwic2NhbGVzIiwiZWxlbWVudHMiLCJkZWZhdWx0Q29sb3IiLCJza2lwIiwic2NhbGUiLCJuYW1lIiwiY2FudmFzIiwidmFsdWVPckRlZmF1bHQiLCJleHRlbmQiLCJwbHVnaW5zIiwidGl0bGUiLCJDaGFydCIsImFuaW1hdGlvbiIsInJvdW5kIiwiaXNBcnJheSIsIm1ldGEiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwibWFwIiwiZmlsbFRleHQiLCJsZWdlbmQiLCJlIiwicmVxdWlyZSIsInQiLCJyIiwibiIsImEiLCJvIiwidSIsImMiLCJzIiwibCIsImYiLCJnIiwicCIsImQiLCJoIiwidiIsIm0iLCJ5IiwiYiIsInciLCJTIiwiTyIsIngiLCJOIiwicmVxdWlyZSQkMCIsInVzZVJlZiIsInVzZU1lbW8iLCJjYXRMYWJlbCIsIl9hIiwiZGF0YTFMYWJlbCIsImRhdGEyTGFiZWwiLCJfYiIsInVzZUVmZmVjdCIsImRhdGEiLCJSZWFjdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFJO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGLElBQUksT0FBTyxpQkFBaUIsQ0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUNUOUI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBRUEsTUFBSTtBQUVKLFdBQVMsUUFBUTtBQUNiLFdBQU8sYUFBYSxNQUFNLE1BQU0sU0FBUztB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LE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQztBQUFBLFVBQ2pCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQzNCLGFBQWEsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLFVBQzFCLGVBQWUsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLFVBQzNCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3hCLGNBQWMsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLFVBQzNCLFlBQVksQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLFVBQ3hCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQzFCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLFVBQ3RCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3hCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3pCLGFBQWEsQ0FBQyxLQUFLLElBQUksR0FBRztBQUFBLFVBQzFCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQzNCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQzNCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3RCLGVBQWUsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLFVBQzNCLGFBQWEsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLFVBQzFCLE9BQU8sQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3JCLFFBQVEsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLFVBQ3BCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3pCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLFVBQ3RCLGFBQWEsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLFVBQzFCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3hCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3ZCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ3ZC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RSxFQUFFLFNBQVMsQ0FBQyxNQUFJLElBQUUsRUFBRSxTQUFRLElBQUUsSUFBSSxFQUFFLENBQUMsR0FBRUcsR0FBRSxTQUFPRSxHQUFFLEtBQUssQ0FBQyxFQUFFLFNBQVEsR0FBR0Y7QUFBRSxnQkFBSUEsSUFBRSxHQUFFLEdBQUVFLElBQUU7QUFBQSxVQUFDLEdBQUUsVUFBUyxTQUFTTCxJQUFFRSxJQUFFO0FBQUMsbUJBQU8sRUFBRUYsSUFBRUUsSUFBRSxDQUFDO0FBQUEsVUFBQyxHQUFFLFVBQVMsU0FBU0YsSUFBRUUsSUFBRTtBQUFDLG1CQUFPLElBQUVBLElBQUUsSUFBRSxHQUFFRyxLQUFFLElBQUksR0FBR0YsS0FBRUgsSUFBRyxNQUFNLEdBQUUsSUFBRSxHQUFFLEVBQUUsU0FBUyxDQUFDLE1BQUksSUFBRSxFQUFFLFNBQVEsSUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFFRyxHQUFFLFNBQU9FLEdBQUUsTUFBTSxDQUFDLEVBQUUsU0FBVSxHQUFDRjtBQUFFLGdCQUFJQSxJQUFFLEdBQUUsR0FBRUUsSUFBRTtBQUFBLFVBQUMsR0FBRSxRQUFPLFNBQVNMLElBQUVFLElBQUU7QUFBQyxtQkFBTyxJQUFFQSxJQUFFLElBQUUsR0FBRUcsS0FBRSxJQUFJLEdBQUdGLEtBQUVILElBQUcsTUFBTSxHQUFFLElBQUUsR0FBRSxFQUFFLFNBQVMsQ0FBQyxNQUFJLElBQUUsRUFBRSxTQUFRLElBQUUsSUFBSSxFQUFFLENBQUMsR0FBRUcsR0FBRSxTQUFPRSxHQUFFLFVBQVUsQ0FBQyxFQUFFLFNBQVEsR0FBR0Y7QUFBRSxnQkFBSUEsSUFBRSxHQUFFLEdBQUVFLElBQUU7QUFBQSxVQUFDLEdBQUUsS0FBSSxTQUFTTCxJQUFFRSxJQUFFO0FBQUMsbUJBQU9DLEtBQUVILElBQUUsSUFBRSxJQUFFRSxJQUFFLEVBQUUsU0FBUyxDQUFDLE1BQUksSUFBRSxFQUFFLFNBQVFDLEdBQUUsU0FBTyxHQUFFQTtBQUFFLGdCQUFJQSxJQUFFLEdBQUU7QUFBQSxVQUFDLEdBQUUsWUFBVyxTQUFTSCxJQUFFRSxJQUFF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SyxJQUFJLE1BQUssQ0FBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLE1BQUssUUFBTyxLQUFLLElBQUksS0FBSSxDQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksT0FBTSxRQUFPLEtBQUssSUFBSSxNQUFLLENBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxNQUFLLFFBQU8sS0FBSyxJQUFJLEtBQUksQ0FBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLE9BQU0sUUFBTyxLQUFLLElBQUksTUFBSyxDQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksTUFBSyxRQUFPLEtBQUssSUFBSSxLQUFJLENBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxPQUFNLFFBQU8sS0FBSyxJQUFJLE1BQUssQ0FBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLE1BQUssUUFBTyxLQUFLLElBQUksS0FBSSxDQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksT0FBTSxRQUFPLEtBQUssSUFBSSxNQUFLLENBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxNQUFLLFFBQU8sS0FBSyxJQUFJLEtBQUksQ0FBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLE9BQU0sUUFBTyxLQUFLLElBQUksTUFBSyxDQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksTUFBSyxRQUFPLEtBQUssSUFBSSxLQUFJLENBQUMsRUFBQyxHQUFFLEVBQUMsS0FBSSxPQUFNLFFBQU8sS0FBSyxJQUFJLE1BQUssQ0FBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLE1BQUssUUFBTyxLQUFLLElBQUksS0FBSSxDQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksS0FBSSxRQUFPLEVBQUMsQ0FBQztBQUFFLGlCQUFTLEVBQUVBLElBQUU7QUFBQyxpQkFBT0EsR0FBRSxRQUFRLHlCQUF3QixNQUFNO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVBLElBQUVFLElBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFO0FBQUMsY0FBSSxJQUFFLElBQUUsVUFBVSxVQUFRLFdBQVMsSUFBRSxJQUFFLElBQUcsSUFBRSxJQUFFLFVBQVUsU0FBTyxJQUFF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
//# sourceURL=render.js
